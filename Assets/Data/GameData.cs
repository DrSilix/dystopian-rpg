/* # move to ProjectSetting.cs */

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Data
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	/// <summary>
	/// Project Settings with Text id. Settings..
	/// </summary>
	[GeneratedCode(GameData.GeneratorName, GameData.GeneratorVersion)]
	public sealed partial class ProjectSetting : Document, IEquatable<ProjectSetting>, IComparable, IComparable<ProjectSetting>
	{
		private readonly int hashCode;

		/// <summary>
		/// Id property of Text type. Not Empty, Unique..
		/// </summary>
		public System.String Id { get; }
		/// <summary>
		/// Project Name property of Text type. Not Null..
		/// </summary>
		public System.String Name { get; }
		/// <summary>
		/// Primary Language property of Text type. Can Be Null..
		/// </summary>
		public System.String PrimaryLanguage { get; }
		/// <summary>
		/// Languages property of Text type. Can Be Null..
		/// </summary>
		public System.String Languages { get; }
		/// <summary>
		/// Copyright property of Text type. Can Be Null..
		/// </summary>
		public System.String Copyright { get; }
		/// <summary>
		/// Version property of Text type. Not Empty..
		/// </summary>
		public System.String Version { get; }
		/// <summary>
		/// Constructor for ProjectSetting.
		/// </summary>
		public ProjectSetting(System.String id, System.String name, System.String primaryLanguage, System.String languages, System.String copyright, System.String version)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.Name = name;
			this.PrimaryLanguage = primaryLanguage;
			this.Languages = languages;
			this.Copyright = copyright;
			this.Version = version;
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(ProjectSetting other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is ProjectSetting == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (ProjectSetting)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.Name, other.Name)
				&& AreEquals(this.PrimaryLanguage, other.PrimaryLanguage)
				&& AreEquals(this.Languages, other.Languages)
				&& AreEquals(this.Copyright, other.Copyright)
				&& AreEquals(this.Version, other.Version)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as ProjectSetting);
		}
		/// <inheritdoc />
		public int CompareTo(ProjectSetting other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(ProjectSetting value1, ProjectSetting value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(ProjectSetting value1, ProjectSetting value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.Name)
				+ GetHashCodeFor(this.PrimaryLanguage)
				+ GetHashCodeFor(this.Languages)
				+ GetHashCodeFor(this.Copyright)
				+ GetHashCodeFor(this.Version)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Project Name: ").Append(this.Name).Append(", ");
				sb.Append("Primary Language: ").Append(this.PrimaryLanguage).Append(", ");
				sb.Append("Languages: ").Append(this.Languages).Append(", ");
				sb.Append("Copyright: ").Append(this.Copyright).Append(", ");
				sb.Append("Version: ").Append(this.Version).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
/* # move to Armor.cs */

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Data
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	/// <summary>
	/// Armors with Text id..
	/// </summary>
	[GeneratedCode(GameData.GeneratorName, GameData.GeneratorVersion)]
	public sealed partial class Armor : Document, IEquatable<Armor>, IComparable, IComparable<Armor>
	{
		private readonly int hashCode;

		/// <summary>
		/// Id property of Text type. Not Empty, Unique..
		/// </summary>
		public System.String Id { get; }
		/// <summary>
		/// Name property of Text type. Not Null..
		/// </summary>
		public System.String Name { get; }
		/// <summary>
		/// Defense property of Integer type. Not Null..
		/// </summary>
		public System.Int32 Defense { get; }
		/// <summary>
		/// Weight property of Integer type. Not Null..
		/// </summary>
		public System.Int32 Weight { get; }
		/// <summary>
		/// Constructor for Armor.
		/// </summary>
		public Armor(System.String id, System.String name, System.Int32 defense, System.Int32 weight)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.Name = name;
			this.Defense = defense;
			this.Weight = weight;
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Armor other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Armor == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Armor)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.Name, other.Name)
				&& AreEquals(this.Defense, other.Defense)
				&& AreEquals(this.Weight, other.Weight)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Armor);
		}
		/// <inheritdoc />
		public int CompareTo(Armor other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Armor value1, Armor value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Armor value1, Armor value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.Name)
				+ GetHashCodeFor(this.Defense)
				+ GetHashCodeFor(this.Weight)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Name: ").Append(this.Name).Append(", ");
				sb.Append("Defense: ").Append(this.Defense).Append(", ");
				sb.Append("Weight: ").Append(this.Weight).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
/* # move to Pistol.cs */

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Data
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	/// <summary>
	/// Pistols with Text id..
	/// </summary>
	[GeneratedCode(GameData.GeneratorName, GameData.GeneratorVersion)]
	public sealed partial class Pistol : Document, IEquatable<Pistol>, IComparable, IComparable<Pistol>
	{
		private readonly int hashCode;

		/// <summary>
		/// Id property of Text type. Not Empty, Unique..
		/// </summary>
		public System.String Id { get; }
		/// <summary>
		/// Name property of Text type. Not Null..
		/// </summary>
		public System.String Name { get; }
		/// <summary>
		/// Accuracy property of Integer type. Not Null..
		/// </summary>
		public System.Int32 Accuracy { get; }
		/// <summary>
		/// Damage property of Integer type. Not Null..
		/// </summary>
		public System.Int32 Damage { get; }
		/// <summary>
		/// Armor _Penetration property of Integer type. Not Null..
		/// </summary>
		public System.Int32 ArmorPenetration { get; }
		/// <summary>
		/// Modes property of Multi Pick List type. Not Null..
		/// </summary>
		public PistolsModes Modes { get; }
		/// <summary>
		/// Recoil property of Integer type. Not Null..
		/// </summary>
		public System.Int32 Recoil { get; }
		/// <summary>
		/// Ammo property of Integer type. Not Null..
		/// </summary>
		public System.Int32 Ammo { get; }
		/// <summary>
		/// Constructor for Pistol.
		/// </summary>
		public Pistol(System.String id, System.String name, System.Int32 accuracy, System.Int32 damage, System.Int32 armorPenetration, PistolsModes modes, System.Int32 recoil, System.Int32 ammo)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.Name = name;
			this.Accuracy = accuracy;
			this.Damage = damage;
			this.ArmorPenetration = armorPenetration;
			this.Modes = modes;
			this.Recoil = recoil;
			this.Ammo = ammo;
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(Pistol other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is Pistol == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (Pistol)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.Name, other.Name)
				&& AreEquals(this.Accuracy, other.Accuracy)
				&& AreEquals(this.Damage, other.Damage)
				&& AreEquals(this.ArmorPenetration, other.ArmorPenetration)
				&& AreEquals(this.Modes, other.Modes)
				&& AreEquals(this.Recoil, other.Recoil)
				&& AreEquals(this.Ammo, other.Ammo)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as Pistol);
		}
		/// <inheritdoc />
		public int CompareTo(Pistol other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(Pistol value1, Pistol value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(Pistol value1, Pistol value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.Name)
				+ GetHashCodeFor(this.Accuracy)
				+ GetHashCodeFor(this.Damage)
				+ GetHashCodeFor(this.ArmorPenetration)
				+ GetHashCodeFor(this.Modes)
				+ GetHashCodeFor(this.Recoil)
				+ GetHashCodeFor(this.Ammo)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Name: ").Append(this.Name).Append(", ");
				sb.Append("Accuracy: ").Append(this.Accuracy).Append(", ");
				sb.Append("Damage: ").Append(this.Damage).Append(", ");
				sb.Append("Armor _Penetration: ").Append(this.ArmorPenetration).Append(", ");
				sb.Append("Modes: ").Append(this.Modes).Append(", ");
				sb.Append("Recoil: ").Append(this.Recoil).Append(", ");
				sb.Append("Ammo: ").Append(this.Ammo).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
/* # move to FileSizeTest.cs */

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Data
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	/// <summary>
	/// File Size Test with Text id..
	/// </summary>
	[GeneratedCode(GameData.GeneratorName, GameData.GeneratorVersion)]
	public sealed partial class FileSizeTest : Document, IEquatable<FileSizeTest>, IComparable, IComparable<FileSizeTest>
	{
		private readonly int hashCode;

		/// <summary>
		/// Id property of Text type. Not Empty, Unique..
		/// </summary>
		public System.String Id { get; }
		/// <summary>
		/// Test Text property of Text type. Not Null..
		/// </summary>
		public System.String TestText { get; }
		/// <summary>
		/// Constructor for FileSizeTest.
		/// </summary>
		public FileSizeTest(System.String id, System.String testText)
		{
			this.OnBeforeInitialize();
			this.Id = id;
			this.TestText = testText;
			this.hashCode = this.ComputeHashCode();
			this.OnInitialize();
		}

		partial void OnBeforeInitialize();
		partial void OnInitialize();

		/// <inheritdoc />
		public bool Equals(FileSizeTest other)
		{
			return this.Equals((object)other);
		}
		/// <inheritdoc />
		public override bool Equals(object value)
		{
			if (value is FileSizeTest == false)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (ReferenceEquals(value, null))
			{
				return false;
			}

			var other = (FileSizeTest)value;
			return (this.GetHashCode() == other.GetHashCode()
				&& AreEquals(this.Id, other.Id)
				&& AreEquals(this.TestText, other.TestText)
			);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.hashCode;
		}

		/// <inheritdoc />
		int IComparable.CompareTo(object obj)
		{
			return this.CompareTo(obj as FileSizeTest);
		}
		/// <inheritdoc />
		public int CompareTo(FileSizeTest other)
		{
			if (ReferenceEquals(other, null))
			{
				return 1;
			}
			return string.Compare(this.Id, other.Id, StringComparison.Ordinal);
		}

		public static bool operator ==(FileSizeTest value1, FileSizeTest value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(FileSizeTest value1, FileSizeTest value2)
		{
			return Equals(value1, value2) == false;
		}

		private int ComputeHashCode()
		{
			return unchecked(this.GetType().Name.GetHashCode()
				+ GetHashCodeFor(this.Id)
				+ GetHashCodeFor(this.TestText)
			);
		}

		/// <inheritdoc />
		public override string ToString()
		{
			var sb = new System.Text.StringBuilder();
				sb.Append("Id: ").Append(this.Id).Append(", ");
				sb.Append("Test Text: ").Append(this.TestText).Append(", ");

			if (sb.Length > 2)
			{
				sb.Length -= 2;
			}
			return sb.ToString();
		}
	}
}
/* # move to PistolsModes.cs */

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Data
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[Flags]
	[GeneratedCode(GameData.GeneratorName, GameData.GeneratorVersion)]
	public enum PistolsModes: System.Int32
	{
		None = 0,
		SingleShot = 1,
		SemiAuto = 2,
		BurstFire = 4,
		FullAuto = 8,
	}
}
/* # move to GameData.cs */

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Data
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	[GeneratedCode(GameData.GeneratorName, GameData.GeneratorVersion)]
	public partial class GameData
	{
		public const string GeneratorName = "Charon";
		public const string GeneratorVersion = "2024.1.0.0";

		private class DocumentCollections
		{
			public DocumentCollection<System.String,ProjectSetting> ProjectSettings = DocumentCollection<System.String,ProjectSetting>.Empty;
			public DocumentCollection<System.String,Armor> Armors = DocumentCollection<System.String,Armor>.Empty;
			public DocumentCollection<System.String,Pistol> Pistols = DocumentCollection<System.String,Pistol>.Empty;
			public DocumentCollection<System.String,FileSizeTest> FileSizeTests = DocumentCollection<System.String,FileSizeTest>.Empty;
		}

		#region Formula fields
		public static readonly Type[] FormulaTypes = new Type[]
		{
				typeof(GameData),
				typeof(ProjectSetting),
				typeof(Armor),
				typeof(Pistol),
				typeof(FileSizeTest),
				typeof(PistolsModes),
		};
#if USE_DYNAMIC_EXPRESSIONS
		public static readonly GameDevWare.Dynamic.Expressions.ITypeResolver TypeResolver = new GameDevWare.Dynamic.Expressions.KnownTypeResolver(FormulaTypes);
#elif !SUPPRESS_BUILD_IN_FORMULAS
		public static readonly Formulas.IFormulaTypeResolver TypeResolver = new Formulas.KnownFormulaTypeResolver(FormulaTypes, Formulas.FormulaOptions.None);
#endif
		#endregion

		#region Schema collections storage fields
		private readonly DocumentCollections rootDocuments;
		private readonly DocumentCollections allDocuments;
		#endregion

		#region Schema collections
		public ProjectSetting ProjectSetting => this.GetOne<ProjectSetting>(this.rootDocuments.ProjectSettings.AsList);
		public DocumentCollection<System.String,Armor> AllArmors => this.allDocuments.Armors;
		public DocumentCollection<System.String,Armor> Armors => this.rootDocuments.Armors;
		public DocumentCollection<System.String,Pistol> AllPistols => this.allDocuments.Pistols;
		public DocumentCollection<System.String,Pistol> Pistols => this.rootDocuments.Pistols;
		public DocumentCollection<System.String,FileSizeTest> AllFileSizeTests => this.allDocuments.FileSizeTests;
		public DocumentCollection<System.String,FileSizeTest> FileSizeTests => this.rootDocuments.FileSizeTests;
		#endregion

		private ReadOnlyCollection<String> languages;
		private LocalizedString.LanguageSwitcher languageSwitcher;
#pragma warning disable 0414 // The variable changeNumber', 'revisionHash' is declared but never used
		private int changeNumber;
		private string revisionHash;
#pragma warning restore 0414

		public ReadOnlyCollection<string> SupportedLanguages { get { return this.languages; } }
		public Func<string, object, Document> FindDocument { get; private set; }


		public GameData(Stream gameDataStream, Formatters.GameDataLoadOptions options)
		{
			if (gameDataStream == null) throw new ArgumentNullException(nameof(gameDataStream));
			if (options == null) throw new ArgumentNullException(nameof(options));

			this.languages = new ReadOnlyCollection<String>(new String[] { "en-US" });
			this.rootDocuments = new DocumentCollections();
			this.allDocuments = new DocumentCollections();
			this.languageSwitcher = new LocalizedString.LanguageSwitcher {
				CurrentLanguageId = "en-US",
				FallbackLanguageId = "en-US",
				PrimaryLanguageId = "en-US",
			};

			this.FindDocument = this.FindDocumentInternal;

			var reader = this.CreateReader(gameDataStream, options);
			var patches = (options.Patches ?? Array.Empty<Stream>());
			if (patches.Count > 0)
			{
				var gameDataDocument = reader.ReadObject();
				foreach (var patchStream in patches)
				{
					using (var patchReader = this.CreateReader(patchStream, options))
					{
						var patchDocument = patchReader.ReadObject();
						gameDataDocument = this.MergeGameData(gameDataDocument, patchDocument);
					}
				}
				reader = new Formatters.GameDataObjectReader(gameDataDocument);
				reader.NextToken();
			}
			try { this.ReadGameData(reader); }
			finally { reader.Dispose(); }

			this.FindAllDocuments();
			this.UpdateLanguageList();


#pragma warning disable 0162 // Unreachable code detected
			this.OnInitialize();
#pragma warning restore 0162
		}

		partial void OnInitialize();

		public IEnumerable<Document> GetAllDocuments()
		{
			return this.EnumerateAll();
		}

		public void SetLanguage(string languageId)
		{
			this.SetLanguage(languageId, languageId);
		}
		public void SetLanguage(string languageId, string fallbackLanguageId = "en-US")
		{
			if (languageId == null) throw new ArgumentNullException(nameof(languageId));
			if (fallbackLanguageId == null) throw new ArgumentNullException(nameof(fallbackLanguageId));

			this.languageSwitcher.CurrentLanguageId = languageId;
			this.languageSwitcher.FallbackLanguageId = fallbackLanguageId ?? languageId;
		}

		private DocumentT GetOne<DocumentT>(IReadOnlyCollection<DocumentT> documents) where DocumentT : Document
		{
			switch(documents.Count)
			{
				case 0: throw new InvalidOperationException($"Unable to find '{typeof(DocumentT)}' document. Please create '{typeof(DocumentT)}' document before using this property.");
				case 1: return System.Linq.Enumerable.Single<DocumentT>(documents);
				default: throw new InvalidOperationException($"There are multiple variants of the '{typeof(DocumentT)}' document. Please remove the excess before using this property.");
			}
		}

		private Document FindDocumentInternal(string schemaId, object id)
		{
			if (schemaId == null) throw new ArgumentNullException(nameof(schemaId));

#pragma warning disable 1522 // Empty switch block
			switch (schemaId)
			{
				case "ProjectSettings":
				case "55a4f32faca22e191098f3d9": return this.allDocuments.ProjectSettings.Get(ChangeType<System.String>(id));
				case "Armors":
				case "6587cace23378b96c0a92c29": return this.allDocuments.Armors.Get(ChangeType<System.String>(id));
				case "Pistols":
				case "6587cbb223378b96c0a92c3d": return this.allDocuments.Pistols.Get(ChangeType<System.String>(id));
				case "FileSizeTest":
				case "65978d40fdfebd55d412343d": return this.allDocuments.FileSizeTests.Get(ChangeType<System.String>(id));
			}
#pragma warning restore 1522
			throw new System.ArgumentException(string.Format("Unable find Schema with id '{0}'.", schemaId) , nameof(schemaId));
		}

		private IEnumerable<Document> EnumerateAll()
		{
			var i = 0;
			var end = 0;
			var ProjectSettingsList = this.allDocuments.ProjectSettings.AsList;
			for (i = 0, end = ProjectSettingsList.Count; i < end; i++)
			{
				yield return ProjectSettingsList[i];
			}
			var ArmorsList = this.allDocuments.Armors.AsList;
			for (i = 0, end = ArmorsList.Count; i < end; i++)
			{
				yield return ArmorsList[i];
			}
			var PistolsList = this.allDocuments.Pistols.AsList;
			for (i = 0, end = PistolsList.Count; i < end; i++)
			{
				yield return PistolsList[i];
			}
			var FileSizeTestsList = this.allDocuments.FileSizeTests.AsList;
			for (i = 0, end = FileSizeTestsList.Count; i < end; i++)
			{
				yield return FileSizeTestsList[i];
			}
			yield break;
		}

		private IEnumerable<Document> EnumerateRoots()
		{
			var i = 0;
			var end = 0;
			var ProjectSettingsList = this.rootDocuments.ProjectSettings.AsList;
			for (i = 0, end = ProjectSettingsList.Count; i < end; i++)
			{
				yield return ProjectSettingsList[i];
			}
			var ArmorsList = this.rootDocuments.Armors.AsList;
			for (i = 0, end = ArmorsList.Count; i < end; i++)
			{
				yield return ArmorsList[i];
			}
			var PistolsList = this.rootDocuments.Pistols.AsList;
			for (i = 0, end = PistolsList.Count; i < end; i++)
			{
				yield return PistolsList[i];
			}
			var FileSizeTestsList = this.rootDocuments.FileSizeTests.AsList;
			for (i = 0, end = FileSizeTestsList.Count; i < end; i++)
			{
				yield return FileSizeTestsList[i];
			}

			yield break;
		}

		private static T ChangeType<T>(object objValue)
		{
			if (objValue is T typeValue)
			{
				return typeValue;
			}
			else if (typeof(T).IsEnum && objValue is string enumValueString)
			{
				return (T)Enum.Parse(typeof(T), enumValueString, ignoreCase: true);
			}
			else if (typeof(T).IsEnum)
			{
				return (T)Enum.ToObject(typeof(T), objValue);
			}
			else if (typeof(T) == typeof(TimeSpan))
			{
				var timeSpanStr = Convert.ToString(objValue, CultureInfo.InvariantCulture);
				return (T)(object)TimeSpan.Parse(timeSpanStr);
			}
			else if (typeof(T) == typeof(DateTime))
			{
				var dateTimeStr = Convert.ToString(objValue, CultureInfo.InvariantCulture);
				return (T)(object)DateTime.ParseExact(dateTimeStr, Formatters.GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
			}
			else if (typeof(T) == typeof(DateTimeOffset))
			{
				var dateTimeOffsetStr = Convert.ToString(objValue, CultureInfo.InvariantCulture);
				return (T)(object)DateTimeOffset.ParseExact(dateTimeOffsetStr, Formatters.GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
			}
			else
			{
				return (T)Convert.ChangeType(objValue, typeof(T), CultureInfo.InvariantCulture);
			}
		}


		#region Read Game Data

		public Formatters.GameDataReader CreateReader(Stream gameDataStream, Formatters.GameDataLoadOptions options)
		{
			if (gameDataStream == null) throw new ArgumentNullException(nameof(gameDataStream));
			if (options == null) throw new ArgumentNullException(nameof(options));

			switch(options.Format)
			{
				case Formatters.GameDataFormat.Json: return new Formatters.JsonGameDataReader(gameDataStream, options.Encoding, options.LeaveStreamsOpen);
				case Formatters.GameDataFormat.MessagePack: return new Formatters.MessagePackGameDataReader(gameDataStream, options.LeaveStreamsOpen);
				default: throw new ArgumentException($"Unknown/Unsupported data format specified '{options.Format}'.", nameof(options));
			}
		}

		public void ReadGameData(Formatters.GameDataReader reader)
		{
			if (reader == null) throw new ArgumentNullException(nameof(reader));

			reader.ReadObjectBegin();
			while(reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var memberName = reader.ReadMember();
				switch(memberName)
				{
					case "ChangeNumber":
						this.changeNumber = (Int32)reader.Node.AsInt32;
						reader.NextToken();
						break;
					case "RevisionHash":
						this.revisionHash = (string)reader.Node.AsString;
						reader.NextToken();
						break;
					case "Collections":
						reader.ReadObjectBegin();
						while(reader.Node.Token != Formatters.ReaderToken.EndOfObject)
						{
							var collectionName = reader.ReadMember();
							switch (collectionName.Length)
							{
								case 6:
									switch(collectionName)
									{
										case "6587cace23378b96c0a92c29":
										case "Armors":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments.Armors = this.ReadArmorsCollection(reader, 7);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								case 7:
									switch(collectionName)
									{
										case "6587cbb223378b96c0a92c3d":
										case "Pistols":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments.Pistols = this.ReadPistolsCollection(reader, 5);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								case 12:
									switch(collectionName)
									{
										case "65978d40fdfebd55d412343d":
										case "FileSizeTest":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments.FileSizeTests = this.ReadFileSizeTestCollection(reader, 1);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								case 15:
									switch(collectionName)
									{
										case "55a4f32faca22e191098f3d9":
										case "ProjectSettings":
										{
											if (reader.IsNull())
											{
												reader.NextToken();
												break;
											}

											this.rootDocuments.ProjectSettings = this.ReadProjectSettingsCollection(reader, 1);
											break;
										}
										default:
											reader.SkipAny();
											break;
									}
									break;
								default:
									reader.SkipAny();
									break;
							}
						}
						reader.ReadObjectEnd();
						break;
					default:
						reader.SkipAny();
						break;
				}
			}

			reader.ReadObjectEnd();
		}

		private void UpdateLanguageList()
		{
			var projectSettings = System.Linq.Enumerable.FirstOrDefault(this.rootDocuments.ProjectSettings.AsList);
			if (projectSettings == null || string.IsNullOrEmpty(projectSettings.Languages))
			{
				return;
			}

			var languages = new List<String>(projectSettings.Languages.Split(";,| ".ToCharArray(), StringSplitOptions.RemoveEmptyEntries));
			if (string.IsNullOrEmpty(projectSettings.PrimaryLanguage) == false)
			{
				this.languageSwitcher.PrimaryLanguageId = projectSettings.PrimaryLanguage;
			}
			else if (languages.Count > 0)
			{
				this.languageSwitcher.PrimaryLanguageId = languages[0];
			}
			else
			{
				this.languageSwitcher.PrimaryLanguageId = "en-US";
			}

			this.languageSwitcher.CurrentLanguageId = this.languageSwitcher.FallbackLanguageId = this.languageSwitcher.PrimaryLanguageId;
			languages.Remove(projectSettings.PrimaryLanguage);
			languages.Add(projectSettings.PrimaryLanguage);
			languages.Sort(StringComparer.OrdinalIgnoreCase);

			this.languages = new ReadOnlyCollection<String>(languages);
		}


		private DocumentCollection<System.String,ProjectSetting> ReadProjectSettingsCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			if (reader.IsNull())
			{
				return DocumentCollection<System.String,ProjectSetting>.Empty;
			}

			var isByIdCollection = reader.Node.Token == Formatters.ReaderToken.BeginObject;
			var collection = default(List<ProjectSetting>);

			if (isByIdCollection)
			{
				reader.ReadObjectBegin();
			}
			else
			{
				reader.ReadArrayBegin();
			}
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray &&
					reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				if (isByIdCollection)
				{
					var _ = reader.ReadMember(); // skip id
				}

				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadProjectSettings(reader);
				if (collection == null)
				{
					collection = new List<ProjectSetting>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			if (isByIdCollection)
			{
				reader.ReadObjectEnd();
			}
			else
			{
				reader.ReadArrayEnd();
			}

			if (collection == null)
			{
				return DocumentCollection<System.String,ProjectSetting>.Empty;
			}
			else
			{
				return new DocumentCollection<System.String,ProjectSetting>(collection, document => document.Id);
			}
		}

		private ProjectSetting ReadProjectSettings(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var _id__ = default(System.String);
			var _name__ = default(System.String);
			var _primaryLanguage__ = default(System.String);
			var _languages__ = default(System.String);
			var _copyright__ = default(System.String);
			var _version__ = default(System.String);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								reader.ThrowIfNull("value of Text type", "Id", "ProjectSettings");
								reader.ThrowIfNotValue();

								_id__ = (System.String)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Name":
							{
								reader.ThrowIfNull("value of Text type", "Name", "ProjectSettings");
								reader.ThrowIfNotValue();

								_name__ = (System.String)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 7:
					{
						switch (propertyName)
						{
							case "Version":
							{
								reader.ThrowIfNull("value of Text type", "Version", "ProjectSettings");
								reader.ThrowIfNotValue();

								_version__ = (System.String)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 9:
					{
						switch (propertyName)
						{
							case "Languages":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								reader.ThrowIfNotValue();

								_languages__ = (System.String)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							case "Copyright":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								reader.ThrowIfNotValue();

								_copyright__ = (System.String)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 15:
					{
						switch (propertyName)
						{
							case "PrimaryLanguage":
							{
								if (reader.IsNull())
								{
									reader.NextToken();
									continue;
								}
								reader.ThrowIfNotValue();

								_primaryLanguage__ = (System.String)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var __ProjectSetting = new ProjectSetting(_id__, _name__, _primaryLanguage__, _languages__, _copyright__, _version__);
			return __ProjectSetting;
		}

		private DocumentCollection<System.String,Armor> ReadArmorsCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			if (reader.IsNull())
			{
				return DocumentCollection<System.String,Armor>.Empty;
			}

			var isByIdCollection = reader.Node.Token == Formatters.ReaderToken.BeginObject;
			var collection = default(List<Armor>);

			if (isByIdCollection)
			{
				reader.ReadObjectBegin();
			}
			else
			{
				reader.ReadArrayBegin();
			}
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray &&
					reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				if (isByIdCollection)
				{
					var _ = reader.ReadMember(); // skip id
				}

				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadArmors(reader);
				if (collection == null)
				{
					collection = new List<Armor>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			if (isByIdCollection)
			{
				reader.ReadObjectEnd();
			}
			else
			{
				reader.ReadArrayEnd();
			}

			if (collection == null)
			{
				return DocumentCollection<System.String,Armor>.Empty;
			}
			else
			{
				return new DocumentCollection<System.String,Armor>(collection, document => document.Id);
			}
		}

		private Armor ReadArmors(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var _id__ = default(System.String);
			var _name__ = default(System.String);
			var _defense__ = default(System.Int32);
			var _weight__ = default(System.Int32);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								reader.ThrowIfNull("value of Text type", "Id", "Armors");
								reader.ThrowIfNotValue();

								_id__ = (System.String)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Name":
							{
								reader.ThrowIfNull("value of Text type", "Name", "Armors");
								reader.ThrowIfNotValue();

								_name__ = (System.String)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 6:
					{
						switch (propertyName)
						{
							case "Weight":
							{
								reader.ThrowIfNull("value of Integer type", "Weight", "Armors");
								reader.ThrowIfNotValue();

								_weight__ = (System.Int32)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 7:
					{
						switch (propertyName)
						{
							case "Defense":
							{
								reader.ThrowIfNull("value of Integer type", "Defense", "Armors");
								reader.ThrowIfNotValue();

								_defense__ = (System.Int32)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var __Armor = new Armor(_id__, _name__, _defense__, _weight__);
			return __Armor;
		}

		private DocumentCollection<System.String,Pistol> ReadPistolsCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			if (reader.IsNull())
			{
				return DocumentCollection<System.String,Pistol>.Empty;
			}

			var isByIdCollection = reader.Node.Token == Formatters.ReaderToken.BeginObject;
			var collection = default(List<Pistol>);

			if (isByIdCollection)
			{
				reader.ReadObjectBegin();
			}
			else
			{
				reader.ReadArrayBegin();
			}
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray &&
					reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				if (isByIdCollection)
				{
					var _ = reader.ReadMember(); // skip id
				}

				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadPistols(reader);
				if (collection == null)
				{
					collection = new List<Pistol>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			if (isByIdCollection)
			{
				reader.ReadObjectEnd();
			}
			else
			{
				reader.ReadArrayEnd();
			}

			if (collection == null)
			{
				return DocumentCollection<System.String,Pistol>.Empty;
			}
			else
			{
				return new DocumentCollection<System.String,Pistol>(collection, document => document.Id);
			}
		}

		private Pistol ReadPistols(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var _id__ = default(System.String);
			var _name__ = default(System.String);
			var _accuracy__ = default(System.Int32);
			var _damage__ = default(System.Int32);
			var _armorPenetration__ = default(System.Int32);
			var _modes__ = default(PistolsModes);
			var _recoil__ = default(System.Int32);
			var _ammo__ = default(System.Int32);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								reader.ThrowIfNull("value of Text type", "Id", "Pistols");
								reader.ThrowIfNotValue();

								_id__ = (System.String)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 4:
					{
						switch (propertyName)
						{
							case "Name":
							{
								reader.ThrowIfNull("value of Text type", "Name", "Pistols");
								reader.ThrowIfNotValue();

								_name__ = (System.String)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							case "Ammo":
							{
								reader.ThrowIfNull("value of Integer type", "Ammo", "Pistols");
								reader.ThrowIfNotValue();

								_ammo__ = (System.Int32)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 5:
					{
						switch (propertyName)
						{
							case "Modes":
							{
								reader.ThrowIfNull("value of MultiPickList type", "Modes", "Pistols");
								reader.ThrowIfNotValue();

								_modes__ = (PistolsModes)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 6:
					{
						switch (propertyName)
						{
							case "Damage":
							{
								reader.ThrowIfNull("value of Integer type", "Damage", "Pistols");
								reader.ThrowIfNotValue();

								_damage__ = (System.Int32)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							case "Recoil":
							{
								reader.ThrowIfNull("value of Integer type", "Recoil", "Pistols");
								reader.ThrowIfNotValue();

								_recoil__ = (System.Int32)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 8:
					{
						switch (propertyName)
						{
							case "Accuracy":
							{
								reader.ThrowIfNull("value of Integer type", "Accuracy", "Pistols");
								reader.ThrowIfNotValue();

								_accuracy__ = (System.Int32)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 17:
					{
						switch (propertyName)
						{
							case "Armor_Penetration":
							{
								reader.ThrowIfNull("value of Integer type", "Armor_Penetration", "Pistols");
								reader.ThrowIfNotValue();

								_armorPenetration__ = (System.Int32)reader.Node.AsInt32;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var __Pistol = new Pistol(_id__, _name__, _accuracy__, _damage__, _armorPenetration__, _modes__, _recoil__, _ammo__);
			return __Pistol;
		}

		private DocumentCollection<System.String,FileSizeTest> ReadFileSizeTestCollection(Formatters.GameDataReader reader, int capacity = 0)
		{
			if (reader.IsNull())
			{
				return DocumentCollection<System.String,FileSizeTest>.Empty;
			}

			var isByIdCollection = reader.Node.Token == Formatters.ReaderToken.BeginObject;
			var collection = default(List<FileSizeTest>);

			if (isByIdCollection)
			{
				reader.ReadObjectBegin();
			}
			else
			{
				reader.ReadArrayBegin();
			}
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray &&
					reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				if (isByIdCollection)
				{
					var _ = reader.ReadMember(); // skip id
				}

				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var document = this.ReadFileSizeTest(reader);
				if (collection == null)
				{
					collection = new List<FileSizeTest>(capacity > 0 ? capacity : 10);
				}

				collection.Add(document);
			}
			if (isByIdCollection)
			{
				reader.ReadObjectEnd();
			}
			else
			{
				reader.ReadArrayEnd();
			}

			if (collection == null)
			{
				return DocumentCollection<System.String,FileSizeTest>.Empty;
			}
			else
			{
				return new DocumentCollection<System.String,FileSizeTest>(collection, document => document.Id);
			}
		}

		private FileSizeTest ReadFileSizeTest(Formatters.GameDataReader reader)
		{
#pragma warning disable 0168 // The variable is declared but never used
			var _id__ = default(System.String);
			var _testText__ = default(System.String);
#pragma warning restore 0168
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var propertyName = reader.ReadMember();
				switch (propertyName.Length)
				{
					case 2:
					{
						switch (propertyName)
						{
							case "Id":
							{
								reader.ThrowIfNull("value of Text type", "Id", "FileSizeTest");
								reader.ThrowIfNotValue();

								_id__ = (System.String)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					case 8:
					{
						switch (propertyName)
						{
							case "TestText":
							{
								reader.ThrowIfNull("value of Text type", "TestText", "FileSizeTest");
								reader.ThrowIfNotValue();

								_testText__ = (System.String)reader.Node.AsString;
								reader.NextToken();
								break;
							}
							default:
							{
								reader.SkipAny();
								break;
							}
						}
						break;
					}
					default:
					{
						reader.SkipAny();
						break;
					}
				}
			}
			reader.ReadObjectEnd();

			var __FileSizeTest = new FileSizeTest(_id__, _testText__);
			return __FileSizeTest;
		}
		private LocalizedString ReadLocalizedString(Formatters.GameDataReader reader, LocalizedString.LanguageSwitcher languageSwitcher, bool nextToken = true)
		{
			if (languageSwitcher == null) throw new ArgumentNullException(nameof(languageSwitcher));

			var locStringDictionary = default(List<KeyValuePair<string, string>>);
			reader.ReadObjectBegin();
			while(reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var key = reader.ReadMember();
				var value = reader.ReadAny()?.ToString();
				if (string.IsNullOrEmpty(key) || string.IsNullOrEmpty(value))
				{
					continue;
				}
				if (locStringDictionary == null)
				{
					locStringDictionary = new List<KeyValuePair<string, string>>(10);
				}
				locStringDictionary.Add(new KeyValuePair<string, string>(key, value));
			}
			reader.ReadObjectEnd(nextToken);

			if (locStringDictionary == null)
			{
				return LocalizedString.Empty;
			}
			else
			{
				return new LocalizedString(locStringDictionary, languageSwitcher);
			}
		}
		private DocumentReferenceCollection<DocumentT> ReadDocumentReferenceCollection<DocumentT>(Formatters.GameDataReader reader, string schemaIdOrName, Func<string, object, Document> findDocument, bool nextToken = true) where DocumentT : Document
		{
			if (reader.IsNull())
			{
				return DocumentReferenceCollection<DocumentT>.Empty;
			}

			var referenceCollection = default(List<DocumentReference<DocumentT>>);
			var isByIdCollection = reader.Node.Token == Formatters.ReaderToken.BeginObject;

			if (isByIdCollection)
			{
				reader.ReadObjectBegin();
			}
			else
			{
				reader.ReadArrayBegin();
			}
			while (reader.Node.Token != Formatters.ReaderToken.EndOfArray &&
					reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				if (isByIdCollection)
				{
					var _ = reader.ReadMember(); // skip id
				}

				if (reader.IsNull())
				{
					reader.NextToken();
					continue;
				}

				var documentReference = this.ReadDocumentReference<DocumentT>(reader, schemaIdOrName, findDocument);
				if (documentReference == null)
				{
					continue;
				}

				if (referenceCollection == null) { referenceCollection = new List<DocumentReference<DocumentT>>(5); }
				referenceCollection.Add(documentReference);
			}
			if (isByIdCollection)
			{
				reader.ReadObjectEnd(nextToken);
			}
			else
			{
				reader.ReadArrayEnd(nextToken);
			}
			if (referenceCollection == null)
			{
				return DocumentReferenceCollection<DocumentT>.Empty;
			}
			else
			{
				return new DocumentReferenceCollection<DocumentT>(referenceCollection);
			}
		}
		private DocumentReference<DocumentT> ReadDocumentReference<DocumentT>(Formatters.GameDataReader reader, string schemaIdOrName, Func<string, object, Document> findDocument, bool nextToken = true) where DocumentT : Document
		{
			if (findDocument == null) throw new ArgumentNullException(nameof(findDocument));

			var reference = default(DocumentReference<DocumentT>);
			reader.ReadObjectBegin();
			while (reader.Node.Token != Formatters.ReaderToken.EndOfObject)
			{
				var key = reader.ReadMember();
				if (key == "Id")
				{
					reference = new DocumentReference<DocumentT>(reader.ReadAny(), schemaIdOrName, findDocument);
				}
				else
				{
					reader.SkipAny();
				}
			}

			 // TODO maybe throw exception if reference is null (broken)?

			reader.ReadObjectEnd(nextToken);
			return reference;
		}

		#endregion // Read Game Data
		#region Merge Game Data

		public Formatters.IndexedDictionary<string, object> MergeGameData(IReadOnlyDictionary<string, object> gameDataDocument, IReadOnlyDictionary<string, object> patchDocument)
		{
			gameDataDocument.TryGetValue("Collections", out var gameDataCollectionsObj);
			var gameDataCollections = gameDataCollectionsObj as IReadOnlyDictionary<string, object> ?? new Formatters.IndexedDictionary<string,object>();
			patchDocument.TryGetValue("Collections", out var patchCollectionsObj);
			var patchCollections = patchCollectionsObj as IReadOnlyDictionary<string, object> ?? new Formatters.IndexedDictionary<string,object>();

			var newGameDataDocument = new Formatters.IndexedDictionary<string, object>(gameDataDocument);
			var newCollections = new Formatters.IndexedDictionary<string, object>(gameDataCollections);
			newGameDataDocument["Collections"] = newCollections;

			var visitedSchemas = new HashSet<string>(StringComparer.Ordinal);
			foreach (var schemaName in gameDataCollections.Keys.Concat(patchCollections.Keys))
			{
				if (visitedSchemas.Contains(schemaName)) {
					continue; // already has been visited
				}

				var gameDataDocumentCollection = default(object);
				var patchDocumentCollection = default(object);
#pragma warning disable 1522 // Empty switch block
				switch (schemaName)
				{
					case "55a4f32faca22e191098f3d9":
					case "ProjectSettings":
						visitedSchemas.Add("55a4f32faca22e191098f3d9");
						visitedSchemas.Add("ProjectSettings");

						if (!gameDataCollections.TryGetValue("55a4f32faca22e191098f3d9", out gameDataDocumentCollection)) {
							gameDataCollections.TryGetValue("ProjectSettings", out gameDataDocumentCollection);
						}
						if (!patchCollections.TryGetValue("55a4f32faca22e191098f3d9", out patchDocumentCollection)) {
							patchCollections.TryGetValue("ProjectSettings", out patchDocumentCollection);
						}

						if (gameDataDocumentCollection == null || patchDocumentCollection == null)
						{
							newCollections["ProjectSettings"] = gameDataDocumentCollection ?? patchDocumentCollection;
						}
						else
						{
							newCollections["ProjectSettings"] = MergeDocumentCollection<ProjectSetting>(gameDataDocumentCollection, patchDocumentCollection, purgeRest: false);
						}
						break;
					case "6587cace23378b96c0a92c29":
					case "Armors":
						visitedSchemas.Add("6587cace23378b96c0a92c29");
						visitedSchemas.Add("Armors");

						if (!gameDataCollections.TryGetValue("6587cace23378b96c0a92c29", out gameDataDocumentCollection)) {
							gameDataCollections.TryGetValue("Armors", out gameDataDocumentCollection);
						}
						if (!patchCollections.TryGetValue("6587cace23378b96c0a92c29", out patchDocumentCollection)) {
							patchCollections.TryGetValue("Armors", out patchDocumentCollection);
						}

						if (gameDataDocumentCollection == null || patchDocumentCollection == null)
						{
							newCollections["Armors"] = gameDataDocumentCollection ?? patchDocumentCollection;
						}
						else
						{
							newCollections["Armors"] = MergeDocumentCollection<Armor>(gameDataDocumentCollection, patchDocumentCollection, purgeRest: false);
						}
						break;
					case "6587cbb223378b96c0a92c3d":
					case "Pistols":
						visitedSchemas.Add("6587cbb223378b96c0a92c3d");
						visitedSchemas.Add("Pistols");

						if (!gameDataCollections.TryGetValue("6587cbb223378b96c0a92c3d", out gameDataDocumentCollection)) {
							gameDataCollections.TryGetValue("Pistols", out gameDataDocumentCollection);
						}
						if (!patchCollections.TryGetValue("6587cbb223378b96c0a92c3d", out patchDocumentCollection)) {
							patchCollections.TryGetValue("Pistols", out patchDocumentCollection);
						}

						if (gameDataDocumentCollection == null || patchDocumentCollection == null)
						{
							newCollections["Pistols"] = gameDataDocumentCollection ?? patchDocumentCollection;
						}
						else
						{
							newCollections["Pistols"] = MergeDocumentCollection<Pistol>(gameDataDocumentCollection, patchDocumentCollection, purgeRest: false);
						}
						break;
					case "65978d40fdfebd55d412343d":
					case "FileSizeTest":
						visitedSchemas.Add("65978d40fdfebd55d412343d");
						visitedSchemas.Add("FileSizeTest");

						if (!gameDataCollections.TryGetValue("65978d40fdfebd55d412343d", out gameDataDocumentCollection)) {
							gameDataCollections.TryGetValue("FileSizeTest", out gameDataDocumentCollection);
						}
						if (!patchCollections.TryGetValue("65978d40fdfebd55d412343d", out patchDocumentCollection)) {
							patchCollections.TryGetValue("FileSizeTest", out patchDocumentCollection);
						}

						if (gameDataDocumentCollection == null || patchDocumentCollection == null)
						{
							newCollections["FileSizeTest"] = gameDataDocumentCollection ?? patchDocumentCollection;
						}
						else
						{
							newCollections["FileSizeTest"] = MergeDocumentCollection<FileSizeTest>(gameDataDocumentCollection, patchDocumentCollection, purgeRest: false);
						}
						break;
				}
#pragma warning restore 1522

			}

			return newGameDataDocument;
		}

		public object MergeDocument<DocumentT>(IReadOnlyDictionary<string, object> originalDocument, IReadOnlyDictionary<string, object> modifiedDocument)
		{
			var mergedDocument = new Formatters.IndexedDictionary<string, object>(Math.Max(originalDocument.Count, modifiedDocument.Count) + 5);

			if (typeof(DocumentT) == typeof(ProjectSetting))
			{
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Id");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Name");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "PrimaryLanguage");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Languages");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Copyright");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Version");
			}
			if (typeof(DocumentT) == typeof(Armor))
			{
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Id");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Name");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Defense");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Weight");
			}
			if (typeof(DocumentT) == typeof(Pistol))
			{
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Id");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Name");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Accuracy");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Damage");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Armor_Penetration");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Modes");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Recoil");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Ammo");
			}
			if (typeof(DocumentT) == typeof(FileSizeTest))
			{
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "Id");
				MergeValue<object>(mergedDocument, originalDocument, modifiedDocument, "TestText");
			}
			return mergedDocument;
		}

		private static void MergeValue<ValueT>(Formatters.IndexedDictionary<string, object> mergedDocument, IReadOnlyDictionary<string, object> originalDocument, IReadOnlyDictionary<string, object> modifiedDocument, string propertyName, Func<ValueT, ValueT, object> mergeFunc = null)
		{
			if (originalDocument == null) throw new ArgumentNullException(nameof(originalDocument));
			if (modifiedDocument == null) throw new ArgumentNullException(nameof(modifiedDocument));
			if (propertyName == null) throw new ArgumentNullException(nameof(propertyName));

			var originalValueExists = originalDocument.TryGetValue(propertyName, out var originalValue);
			var modifiedValueExists = modifiedDocument.TryGetValue(propertyName, out var modifiedValue);

			if (!originalValueExists && !modifiedValueExists)
			{
				return; // nothing to merge
			}

			object mergedValue;
			if (originalValue != null && !modifiedValueExists)
			{
				// unchanged
				mergedValue = originalValue;
			}
			else if (originalValue == null && modifiedValue != null)
			{
				// created
				mergedValue = modifiedValue;
			}
			else if (originalValue != null && modifiedValueExists && modifiedValue == null)
			{
				// deleted
				mergedValue = null;
			}
			else if (originalValue is ValueT originalTypedValue &&
					modifiedValue is ValueT modifiedTypedValue)
			{
				// modified => merge
				if (mergeFunc != null)
				{
					mergedValue = mergeFunc(originalTypedValue, modifiedTypedValue);
				}
				else
				{
					mergedValue = modifiedValue;
				}
			}
			else
			{
				// keep original
				mergedValue = originalValue;
			}

			mergedDocument[propertyName] = mergedValue;
		}

		public object MergeDocumentCollection<DocumentT>(object originalDocumentCollection, object modifiedDocumentCollection, bool purgeRest)
		{
			if (modifiedDocumentCollection == null && !purgeRest)
			{
				return Array.Empty<object>();
			}

			var originalCollectionById = ToDocumentsById(originalDocumentCollection);
			var modifiedCollectionById = ToDocumentsById(modifiedDocumentCollection);
			var collection = new Formatters.IndexedDictionary<string, object>(Math.Max(originalCollectionById.Count, modifiedCollectionById.Count) + 5);
			var keys = purgeRest ? modifiedCollectionById.Keys : originalCollectionById.Keys.Union(modifiedCollectionById.Keys);
			foreach (var id in keys)
			{
				var originalValueExists = originalCollectionById.TryGetValue(id, out var originalValue);
				var modifiedValueExists = modifiedCollectionById.TryGetValue(id, out var modifiedValue);
				var originalIsDeleted = originalValueExists && originalValue == null;

				object mergedDocument;
				if (originalValue != null && !modifiedValueExists)
				{
					// unchanged
					mergedDocument = originalValue;
				}
				else if (originalIsDeleted)
				{
					mergedDocument = null; // keep deleted documents as deleted
				}
				else if (originalValue == null && modifiedValue != null)
				{
					// created
					mergedDocument = modifiedValue;
				}
				else if (originalValue != null && modifiedValueExists && modifiedValue == null)
				{
					// deleted
					mergedDocument = null;
				}
				else if (originalValue is IReadOnlyDictionary<string, object> originalValueDocument &&
						modifiedValue is IReadOnlyDictionary<string, object> modifiedValueDocument)
				{
					// modified
					mergedDocument = MergeDocument<DocumentT>(originalValueDocument, modifiedValueDocument);
				}
				else
				{
					// keep original
					mergedDocument = originalValue;
				}

				collection.Add(id, mergedDocument);
			}
			return collection;
		}

		private static object MergeLocalizedString(IReadOnlyDictionary<string, object> originalLocalizedText, IReadOnlyDictionary<string, object> modifiedLocalizedText)
		{
			if (originalLocalizedText == null && modifiedLocalizedText == null)
			{
				return null;
			}
			else if (originalLocalizedText != null && modifiedLocalizedText == null)
			{
				return null;
			}
			else if (originalLocalizedText == null)
			{
				return modifiedLocalizedText;
			}
			else if (LocalizedStringAreEquals(originalLocalizedText, modifiedLocalizedText))
			{
				return originalLocalizedText;
			}

			var mergedLocalizedString = new Formatters.IndexedDictionary<string, object>();
			foreach (var languageId in originalLocalizedText.Keys.Union(modifiedLocalizedText.Keys))
			{
				if (modifiedLocalizedText.ContainsKey(languageId) == false)
				{
					originalLocalizedText.TryGetValue(languageId, out var originalText);
					mergedLocalizedString[languageId] = originalText;
				}
				else
				{
					modifiedLocalizedText.TryGetValue(languageId, out var modifiedText);
					mergedLocalizedString[languageId] = modifiedText;
				}
			}
			return mergedLocalizedString;
		}

		private static bool LocalizedStringAreEquals(IReadOnlyDictionary<string, object> x, IReadOnlyDictionary<string, object> y)
		{
			if (ReferenceEquals(x, y)) return true;
			if (ReferenceEquals(x, null)) return false;
			if (ReferenceEquals(y, null)) return false;
			if (x.GetType() != y.GetType()) return false;
			if (x.Count != y.Count) return false;

			foreach (var kv in x)
			{
				var xValue = kv.Value;
				y.TryGetValue(kv.Key, out var yValue);
				if (StringComparer.Ordinal.Equals(xValue as string, yValue as string) == false)
				{
					return false;
				}
			}
			return true;
		}

		public IReadOnlyDictionary<string, object> ToDocumentsById(object gameDataDocumentCollection)
		{
			if (gameDataDocumentCollection is IReadOnlyDictionary<string, object> documentsById)
			{
				return documentsById;
			}
			else if (gameDataDocumentCollection is IReadOnlyList<object> list)
			{
				var newDocumentsById = new Formatters.IndexedDictionary<string, object>(list.Count);
				foreach (var documentObj in list)
				{
					if (documentObj is IReadOnlyDictionary<string, object> document &&
						document.TryGetValue("Id", out var idObj) &&
						idObj != null)
					{
						var idStr = Convert.ToString(idObj, CultureInfo.InvariantCulture);
						newDocumentsById[idStr] = documentObj;
					}
				}
				return newDocumentsById;
			}
			else
			{
				return new Formatters.IndexedDictionary<string, object>();
			}
		}

		#endregion
		#region Visitors
		public void ApplyVisitor(Visitor visitor)
		{
			if (visitor == null) throw new ArgumentNullException("visitor");

			foreach (var document in this.EnumerateRoots())
			{
				visitor.Visit(document);
			}
		}

		public void ResolveAllReferences()
		{
			var dereferencingVisitor = new DereferencingVisitor();
			this.ApplyVisitor(dereferencingVisitor);
		}

		private void FindAllDocuments()
		{
			var findingVisitor = new FindingVisitor();
			this.ApplyVisitor(findingVisitor);

			if (findingVisitor.AllProjectSettings?.Count > 0)
			{
				this.allDocuments.ProjectSettings = new DocumentCollection<System.String,ProjectSetting>(findingVisitor.AllProjectSettings, document => document.Id);
			}
			if (findingVisitor.AllArmors?.Count > 0)
			{
				this.allDocuments.Armors = new DocumentCollection<System.String,Armor>(findingVisitor.AllArmors, document => document.Id);
			}
			if (findingVisitor.AllPistols?.Count > 0)
			{
				this.allDocuments.Pistols = new DocumentCollection<System.String,Pistol>(findingVisitor.AllPistols, document => document.Id);
			}
			if (findingVisitor.AllFileSizeTest?.Count > 0)
			{
				this.allDocuments.FileSizeTests = new DocumentCollection<System.String,FileSizeTest>(findingVisitor.AllFileSizeTest, document => document.Id);
			}
		}

		public class Visitor
		{
			#region Visit Methods

			public virtual void Visit(Document document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
				if (document is ProjectSetting __ProjectSetting)
				{
					this.Visit(__ProjectSetting);
				}
				else
				if (document is Armor __Armor)
				{
					this.Visit(__Armor);
				}
				else
				if (document is Pistol __Pistol)
				{
					this.Visit(__Pistol);
				}
				else
				if (document is FileSizeTest __FileSizeTest)
				{
					this.Visit(__FileSizeTest);
				}
				else
				{
					throw new ArgumentException($"Unknown document type '{document.GetType()}'.", nameof(document));
				}
			}
			public virtual void Visit(ProjectSetting document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
			}
			public virtual void Visit(Armor document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
			}
			public virtual void Visit(Pistol document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
			}
			public virtual void Visit(FileSizeTest document)
			{
				if (document == null) throw new ArgumentNullException(nameof(document));
			}
			#endregion
		}

		private class FindingVisitor : Visitor
		{
			public List<ProjectSetting> AllProjectSettings;
			public List<Armor> AllArmors;
			public List<Pistol> AllPistols;
			public List<FileSizeTest> AllFileSizeTest;
			#region Visit Methods

			public override void Visit(ProjectSetting document)
			{
				if (this.AllProjectSettings == null)
				{
					this.AllProjectSettings = new List<ProjectSetting>(6);
				}
				this.AllProjectSettings.Add(document);

				base.Visit(document);
			}
			public override void Visit(Armor document)
			{
				if (this.AllArmors == null)
				{
					this.AllArmors = new List<Armor>(12);
				}
				this.AllArmors.Add(document);

				base.Visit(document);
			}
			public override void Visit(Pistol document)
			{
				if (this.AllPistols == null)
				{
					this.AllPistols = new List<Pistol>(10);
				}
				this.AllPistols.Add(document);

				base.Visit(document);
			}
			public override void Visit(FileSizeTest document)
			{
				if (this.AllFileSizeTest == null)
				{
					this.AllFileSizeTest = new List<FileSizeTest>(6);
				}
				this.AllFileSizeTest.Add(document);

				base.Visit(document);
			}
			#endregion
		}

		private class DereferencingVisitor : Visitor
		{
			#region Visit Methods

			public override void Visit(ProjectSetting document)
			{
				base.Visit(document);
			}
			public override void Visit(Armor document)
			{
				base.Visit(document);
			}
			public override void Visit(Pistol document)
			{
				base.Visit(document);
			}
			public override void Visit(FileSizeTest document)
			{
				base.Visit(document);
			}
			#endregion
		}

		#endregion

	}
}
/* # move to Document.cs */

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Data
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;


#pragma warning disable 0660, 0661
	public abstract partial class Document
	{
		public Document Parent { get; private set; }

		public static bool operator ==(Document value1, Document value2)
		{
			if (ReferenceEquals(value1, value2)) return true;
			if (ReferenceEquals(value1, null) || ReferenceEquals(value2, null)) return false;

			return Equals(value1, value2);
		}
		public static bool operator !=(Document value1, Document value2)
		{
			if (ReferenceEquals(value1, value2)) return false;
			if (ReferenceEquals(value1, null) || ReferenceEquals(value2, null)) return true;

			return Equals(value1, value2) == false;
		}

		protected static void SetParent(Document document, Document parent)
		{
			if (ReferenceEquals(document, null)) return;

			document.Parent = parent;
		}

		protected static bool AreEquals<T>(T value1, T value2)
		{
			return EqualityComparer<T>.Default.Equals(value1, value2);
		}
		protected static int GetHashCodeFor<T>(T value)
		{
			return EqualityComparer<T>.Default.GetHashCode(value);
		}
	}
#pragma warning restore 0660, 0661

}
/* # move to DocumentReference.cs */

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Data
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;


	public sealed partial class DocumentReference<DocumentT> where DocumentT : Document
	{
		private readonly string schemaIdOrName;
		[NonSerialized]
		private DocumentT document;
		[NonSerialized]
		private readonly Func<string, object, Document> findFunc;

		public object Id { get; }

		public DocumentReference(object id, string schemaIdOrName, Func<string, object, Document> findFunc)
		{
			if (id == null) throw new ArgumentNullException(nameof(id));
			if (findFunc == null) throw new ArgumentNullException(nameof(findFunc));

			this.schemaIdOrName = schemaIdOrName;
			this.findFunc = findFunc;
			this.Id = id;
		}

		public DocumentT Dereference()
		{
			if (this.document != null)
			{
				return this.document;
			}

			return this.document = (DocumentT)this.findFunc(this.schemaIdOrName, this.Id);
		}

		public static implicit operator DocumentT(DocumentReference<DocumentT> reference)
		{
			return reference.Dereference();
		}

		public override bool Equals(object value)
		{
			if (!(value is DocumentReference<DocumentT> other))
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}

			return Equals(this.Id, other.Id);
		}

		public override int GetHashCode()
		{
			var hashCode = this.Id != null ? this.Id.GetHashCode() : 0;
			return hashCode;
		}

		public override string ToString()
		{
			return $"Id: {this.Id}, Schema: {this.schemaIdOrName}, Resolved: {this.document != null}";
		}
	}

}
/* # move to DocumentReferenceCollection.cs */

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Data
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;


	[Serializable, DebuggerDisplay("DocumentReferenceCollection, Count: {" + nameof(Count) + "}")]
	public partial class DocumentReferenceCollection<DocumentT>: IReadOnlyList<DocumentReference<DocumentT>>, IEquatable<DocumentReferenceCollection<DocumentT>> where DocumentT : Document
	{
		public static readonly DocumentReferenceCollection<DocumentT> Empty = new DocumentReferenceCollection<DocumentT>(Array.Empty<DocumentReference<DocumentT>>());

		private readonly IReadOnlyList<DocumentReference<DocumentT>> referenceList;
		[NonSerialized]
		private object documentCollectionById;
		[NonSerialized]
		private IReadOnlyList<DocumentT> documentList;

		public DocumentReferenceCollection(IReadOnlyList<DocumentReference<DocumentT>> referenceList)
		{
			if (referenceList == null) throw new ArgumentNullException(nameof(referenceList));

			this.referenceList = referenceList;
		}

		/// <inheritdoc />
		public int Count => this.referenceList.Count;
		/// <inheritdoc />
		public DocumentReference<DocumentT> this[int index] => this.referenceList[index];

		public IReadOnlyList<DocumentT> Dereference()
		{
			if (this.documentList != null)
			{
				return this.documentList;
			}
			var documents = new DocumentT[this.Count];
			for (var i = 0; i < this.referenceList.Count; i++)
			{
				documents[i] = this.referenceList[i].Dereference();
			}
			return this.documentList = documents;
		}
		public DocumentCollection<IdT, DocumentT> Dereference<IdT>(Func<DocumentT, IdT> idSelectFunc)
		{
			if (idSelectFunc == null) throw new ArgumentNullException(nameof(idSelectFunc));

			if (this.documentCollectionById == null && this.Count == 0)
			{
				this.documentCollectionById = DocumentCollection<IdT, DocumentT>.Empty;
			}
			else if((this.documentCollectionById as DocumentCollection<IdT, DocumentT>) == null)
			{
				var documents = this.Dereference();
				this.documentCollectionById = new DocumentCollection<IdT, DocumentT>(documents, idSelectFunc);
			}
			return (DocumentCollection<IdT, DocumentT>)this.documentCollectionById;
		}

		/// <inheritdoc />
		IEnumerator<DocumentReference<DocumentT>> IEnumerable<DocumentReference<DocumentT>>.GetEnumerator()
		{
			return this.referenceList.GetEnumerator();
		}
		/// <inheritdoc />
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable)this.referenceList).GetEnumerator();
		}
		/// <inheritdoc />
		public bool Equals(DocumentReferenceCollection<DocumentT> other)
		{
			if (ReferenceEquals(null, other)) return false;
			if (ReferenceEquals(this, other)) return true;

			return this.referenceList.SequenceEqual(other.referenceList);
		}
		/// <inheritdoc />
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			if (obj.GetType() != this.GetType()) return false;

			return this.Equals((DocumentReferenceCollection<DocumentT>)obj);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.referenceList.Aggregate(0, (acc, next) => unchecked(next.GetHashCode() * 17 + acc));
		}

		/// <inheritdoc />
		public override string ToString()
		{
			return this.referenceList.ToString();
		}
	}

}
/* # move to DocumentCollection.cs */

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Data
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;


	[Serializable, DebuggerDisplay("DocumentCollection, Count: {" + nameof(Count) + "}")]
	public partial class DocumentCollection<KeyT, DocumentT> : IReadOnlyDictionary<KeyT, DocumentT>, IEquatable<DocumentCollection<KeyT, DocumentT>> where DocumentT : Document
	{
		public static readonly DocumentCollection<KeyT, DocumentT> Empty = new DocumentCollection<KeyT, DocumentT>(Array.Empty<DocumentT>(), new Dictionary<KeyT, DocumentT>(), new Dictionary<Delegate, object>());

		private readonly IReadOnlyList<DocumentT> documents;
		private readonly IReadOnlyDictionary<KeyT, DocumentT> documentsByKey;
		private readonly Dictionary<Delegate, object> byPropertyDictionary;

		public IReadOnlyList<DocumentT> AsList => this.documents;
		/// <inheritdoc />
		public DocumentT this[KeyT key] => this.documentsByKey[key];
		/// <inheritdoc />
		public IEnumerable<KeyT> Keys => this.documentsByKey.Keys;
		/// <inheritdoc />
		public IEnumerable<DocumentT> Values => this.documentsByKey.Values;
		/// <inheritdoc />
		public int Count => this.documentsByKey.Count;

		private DocumentCollection(IReadOnlyList<DocumentT> documents, IReadOnlyDictionary<KeyT, DocumentT> documentsByKey, Dictionary<Delegate, object> byPropertyDictionary)
		{
			if (documents == null) throw new ArgumentNullException(nameof(documents));
			if (documentsByKey == null) throw new ArgumentNullException(nameof(documentsByKey));
			if (byPropertyDictionary == null) throw new ArgumentNullException(nameof(byPropertyDictionary));

			this.documents = documents;
			this.documentsByKey = documentsByKey;
			this.byPropertyDictionary = byPropertyDictionary;
		}
		public DocumentCollection(IEnumerable<DocumentT> documents, Func<DocumentT, KeyT> selectKeyFunc, IEqualityComparer<KeyT> idComparer = default)
		{
			if (documents == null) throw new ArgumentNullException(nameof(documents));
			if (selectKeyFunc == null) throw new ArgumentNullException(nameof(selectKeyFunc));

			this.documents = documents as IReadOnlyList<DocumentT> ?? documents.ToList();
			var documentByKey = new Dictionary<KeyT, DocumentT>(this.documents.Count, idComparer ?? EqualityComparer<KeyT>.Default);
			foreach (var document in this.documents)
			{
				if (document == null)
				{
					continue;
				}

				var key = selectKeyFunc(document);
				if (ReferenceEquals(key, null))
				{
					continue;
				}

				documentByKey[key] = document;
			}

			this.documentsByKey = documentByKey;
			this.byPropertyDictionary = new Dictionary<Delegate, object> {
				{ selectKeyFunc, this }
			};
		}

		/// <inheritdoc />
		IEnumerator<KeyValuePair<KeyT, DocumentT>> IEnumerable<KeyValuePair<KeyT, DocumentT>>.GetEnumerator()
		{
			return this.documentsByKey.GetEnumerator();
		}
		/// <inheritdoc />
		IEnumerator IEnumerable.GetEnumerator()
		{
			return ((IEnumerable)this.documentsByKey).GetEnumerator();
		}

		/// <inheritdoc />
		public bool ContainsKey(KeyT key)
		{
			return this.documentsByKey.ContainsKey(key);
		}
		/// <inheritdoc />
		public bool TryGetValue(KeyT key, out DocumentT value)
		{
			return this.documentsByKey.TryGetValue(key, out value);
		}

		public DocumentT Get(KeyT key)
		{
			if (!this.TryGetValue(key, out var document))
			{
				throw new ArgumentException($"Unable find {typeof(DocumentT).Name} with one of unique attributes equals to '{key}'.",nameof(key));
			}
			return document;
		}
		public DocumentT Find(KeyT key)
		{
			this.TryGetValue(key, out var document);
			return document;
		}

		[Obsolete("Use ByKey() method due better semantic. This method will be removed after 01.01.2024")]
		public DocumentCollection<NewKeyT, DocumentT> WithOtherKey<NewKeyT>(Func<DocumentT, NewKeyT> selectKeyFunc, IEqualityComparer<NewKeyT> keyComparer = default)
		{
			return this.ByKey(selectKeyFunc, keyComparer);
		}
		public DocumentCollection<NewKeyT, DocumentT> ByKey<NewKeyT>(Func<DocumentT, NewKeyT> selectKeyFunc, IEqualityComparer<NewKeyT> keyComparer = default)
		{
			if (selectKeyFunc == null) throw new ArgumentNullException(nameof(selectKeyFunc));

			if (this.Count == 0)
			{
				return DocumentCollection<NewKeyT, DocumentT>.Empty;
			}

			lock (this.byPropertyDictionary)
			{
				if (this.byPropertyDictionary.TryGetValue(selectKeyFunc, out var documentCollectionObj) &&
					documentCollectionObj is DocumentCollection<NewKeyT, DocumentT> existingDocumentCollection)
				{
					return existingDocumentCollection;
				}
			}

			var newDocumentByKey = new Dictionary<NewKeyT, DocumentT>(keyComparer ?? EqualityComparer<NewKeyT>.Default);
			foreach (var document in this.documents)
			{
				if (document == null)
				{
					continue;
				}

				var key = selectKeyFunc(document);
				if (ReferenceEquals(key, null))
				{
					continue;
				}

				newDocumentByKey[key] = document;
			}

			lock (this.byPropertyDictionary)
			{
				var newDocumentCollection = new DocumentCollection<NewKeyT, DocumentT>(this.documents, newDocumentByKey, this.byPropertyDictionary);
				this.byPropertyDictionary[selectKeyFunc] = newDocumentCollection;
				return newDocumentCollection;
			}
		}

		public IEnumerator<DocumentT> GetEnumerator()
		{
			return this.documents.GetEnumerator();
		}

		/// <inheritdoc />
		public bool Equals(DocumentCollection<KeyT, DocumentT> other)
		{
			if (ReferenceEquals(null, other)) return false;
			if (ReferenceEquals(this, other)) return true;

			return this.documents.SequenceEqual(other.documents);
		}
		/// <inheritdoc />
		public override bool Equals(object obj)
		{
			if (ReferenceEquals(null, obj)) return false;
			if (ReferenceEquals(this, obj)) return true;
			if (obj.GetType() != this.GetType()) return false;

			return this.Equals((DocumentCollection<KeyT, DocumentT>)obj);
		}
		/// <inheritdoc />
		public override int GetHashCode()
		{
			return this.documents.Aggregate(0, (acc, next) => unchecked(next.GetHashCode() * 17 + acc));
		}

		/// <inheritdoc />
		public override string ToString()
		{
			return this.documentsByKey.ToString();
		}
	}

}
/* # move to DocumentCollectionExtensions.cs */

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Data
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

		public static class DocumentCollectionExtensions
		{
		}
}
/* # move to LocalizedString.cs */

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Data
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;


	[Serializable, DebuggerDisplay("LocalizedString, Count: {" + nameof(Count) + "}")]
	public sealed partial class LocalizedString : IReadOnlyDictionary<string, string>
	{
		public static readonly LocalizedString Empty = new LocalizedString(Array.Empty<KeyValuePair<string, string>>(), new LanguageSwitcher());

		private static readonly StringComparer LanguageIdComparer = StringComparer.OrdinalIgnoreCase;

		public sealed class LanguageSwitcher
		{
			public string CurrentLanguageId = "en-US";
			public string FallbackLanguageId = "en-US";
			public string PrimaryLanguageId = "en-US";
		}

		private readonly LanguageSwitcher languageSwitcher;
		private readonly string[] keys;
		private readonly string[] values;
		private string currentValue;
		private string currentValueLanguageId;

		/// <inheritdoc />
		public int Count => this.keys.Length;
		public string Value => this.GetOrUpdateCurrentValue();

		/// <inheritdoc cref="IReadOnlyDictionary{TKey,TValue}.this" />
		public string this[string key]
		{
			get
			{
				var languageIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, key, LanguageIdComparer);
				return languageIndex < 0 ? null : this.values[languageIndex];
			}
		}

		public LocalizedString(IReadOnlyList<KeyValuePair<string, string>> textByLanguageId, LanguageSwitcher languageSwitcher)
		{
			if (textByLanguageId == null) throw new ArgumentNullException(nameof(textByLanguageId));
			if (languageSwitcher == null) throw new ArgumentNullException(nameof(languageSwitcher));

			this.languageSwitcher = languageSwitcher;

			this.keys = new string[textByLanguageId.Count];
			this.values = new string[textByLanguageId.Count];
			for (var i = 0; i < textByLanguageId.Count; i++)
			{
				this.keys[i] = textByLanguageId[i].Key;
				this.values[i] = textByLanguageId[i].Value;
			}
		}

		private string GetOrUpdateCurrentValue()
		{
			var currentLanguageId = this.languageSwitcher.CurrentLanguageId;
			var fallbackLanguageId = this.languageSwitcher.FallbackLanguageId;
			var primaryLanguageId = this.languageSwitcher.PrimaryLanguageId;
			if (currentLanguageId != this.currentValueLanguageId)
			{
				this.currentValueLanguageId = currentLanguageId;
				this.currentValue = this[currentLanguageId] ?? this[fallbackLanguageId] ?? this[primaryLanguageId] ?? string.Empty;
			}
			return this.currentValue;
		}

		public static implicit operator string(LocalizedString str)
		{
			return str?.Value;
		}

		/// <inheritdoc />
		public override bool Equals(object value)
		{
			var other = value as LocalizedString;
			if (other == null)
			{
				return false;
			}
			else if (ReferenceEquals(this, value))
			{
				return true;
			}
			else if (this.keys.Length != other.keys.Length)
			{
				return false;
			}

			for (var i = 0; i < this.keys.Length; i++)
			{
				if (LanguageIdComparer.Equals(this.keys[i], other.keys[i]) == false)
				{
					return false;
				}

				if (string.Equals(this.values[i], other.values[i], StringComparison.OrdinalIgnoreCase) == false)
				{
					return false;
				}
			}

			return true;
		}

		/// <inheritdoc />
		public override int GetHashCode()
		{
			var hashCode = 0;
			foreach (var value in this.values)
			{
				hashCode += unchecked((value ?? "").GetHashCode());
			}
			return hashCode;
		}

		/// <inheritdoc />
		IEnumerable<string> IReadOnlyDictionary<string, string>.Keys => this.keys;
		/// <inheritdoc />
		IEnumerable<string> IReadOnlyDictionary<string, string>.Values => this.values;

		/// <inheritdoc />
		bool IReadOnlyDictionary<string, string>.TryGetValue(string key, out string value)
		{
			return ((IReadOnlyDictionary<string, string>)this).TryGetValue(key, out value);
		}
		/// <inheritdoc />
		bool IReadOnlyDictionary<string, string>.ContainsKey(string key)
		{
			return ((IReadOnlyDictionary<string, string>)this).ContainsKey(key);
		}

		public bool TryGetValue(string key, out string value)
		{
			var languageIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, key, LanguageIdComparer);
			if (languageIndex >= 0)
			{
				value = this.values[languageIndex];
				return value != null;
			}
			else
			{
				value = null;
				return false;
			}
		}

		/// <inheritdoc />
		IEnumerator<KeyValuePair<string, string>> IEnumerable<KeyValuePair<string, string>>.GetEnumerator()
		{
			for (var i = 0; i < this.keys.Length; i++)
			{
				yield return new KeyValuePair<string, string>(this.keys[i], this.values[i]);
			}
		}
		/// <inheritdoc />
		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
		{
			for (var i = 0; i < this.keys.Length; i++)
			{
				yield return new KeyValuePair<string, string>(this.keys[i], this.values[i]);
			}
		}

		public static bool operator ==(LocalizedString value1, LocalizedString value2)
		{
			return Equals(value1, value2);
		}
		public static bool operator !=(LocalizedString value1, LocalizedString value2)
		{
			return Equals(value1, value2) == false;
		}

		public override string ToString()
		{
			return this.Value;
		}
	}

}
/* # move to Formatters.cs */

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Data
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

	public static class Formatters
	{
 

	#region EndianBitConverter by Jon Skeet and Marc Gravell
	/* "Miscellaneous Utility Library" Software Licence

	Version 1.0

	Copyright (c) 2004-2008 Jon Skeet and Marc Gravell.
	All rights reserved.

	Redistribution and use in source and binary forms, with or without
	modification, are permitted provided that the following conditions
	are met:

	1. Redistributions of source code must retain the above copyright
	notice, this list of conditions and the following disclaimer.

	2. Redistributions in binary form must reproduce the above copyright
	notice, this list of conditions and the following disclaimer in the
	documentation and/or other materials provided with the distribution.

	3. The end-user documentation included with the redistribution, if
	any, must include the following acknowledgment:

	"This product includes software developed by Jon Skeet
	and Marc Gravell. Contact skeet@pobox.com, or see
	http://www.pobox.com/~skeet/)."

	Alternately, this acknowledgment may appear in the software itself,
	if and wherever such third-party acknowledgments normally appear.

	4. The name "Miscellaneous Utility Library" must not be used to endorse
	or promote products derived from this software without prior written
	permission. For written permission, please contact skeet@pobox.com.

	5. Products derived from this software may not be called
	"Miscellaneous Utility Library", nor may "Miscellaneous Utility Library"
	appear in their name, without prior written permission of Jon Skeet.

	THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED
	WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
	MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
	IN NO EVENT SHALL JON SKEET BE LIABLE FOR ANY DIRECT, INDIRECT,
	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
	POSSIBILITY OF SUCH DAMAGE.
	*/
	public enum Endianness
	{
		LittleEndian,
		BigEndian
	}

	public abstract class EndianBitConverter
	{
		#region Endianness of this converter

		public abstract bool IsLittleEndian();

		public abstract Endianness Endianness { get; }

		#endregion

		#region Factory properties

		public static readonly LittleEndianBitConverter Little = new LittleEndianBitConverter();
		public static readonly BigEndianBitConverter Big = new BigEndianBitConverter();

		#endregion

		#region Double/primitive conversions

		public long DoubleToInt64Bits(double value)
		{
			return BitConverter.DoubleToInt64Bits(value);
		}

		public double Int64BitsToDouble(long value)
		{
			return BitConverter.Int64BitsToDouble(value);
		}

		public int SingleToInt32Bits(float value)
		{
			return new Int32SingleUnion(value).AsInt32;
		}

		public float Int32BitsToSingle(int value)
		{
			return new Int32SingleUnion(value).AsSingle;
		}

		#endregion

		#region To(PrimitiveType) conversions

		public bool ToBoolean(byte[] value, int startIndex)
		{
			CheckByteArgument(value, startIndex, 1);
			return BitConverter.ToBoolean(value, startIndex);
		}

		public char ToChar(byte[] value, int startIndex)
		{
			return unchecked((char)(CheckedFromBytes(value, startIndex, 2)));
		}

		public double ToDouble(byte[] value, int startIndex)
		{
			return Int64BitsToDouble(ToInt64(value, startIndex));
		}

		public float ToSingle(byte[] value, int startIndex)
		{
			return Int32BitsToSingle(ToInt32(value, startIndex));
		}

		public short ToInt16(byte[] value, int startIndex)
		{
			return unchecked((short)(CheckedFromBytes(value, startIndex, 2)));
		}

		public int ToInt32(byte[] value, int startIndex)
		{
			return unchecked((int)(CheckedFromBytes(value, startIndex, 4)));
		}

		public long ToInt64(byte[] value, int startIndex)
		{
			return CheckedFromBytes(value, startIndex, 8);
		}

		public ushort ToUInt16(byte[] value, int startIndex)
		{
			return unchecked((ushort)(CheckedFromBytes(value, startIndex, 2)));
		}

		public uint ToUInt32(byte[] value, int startIndex)
		{
			return unchecked((uint)(CheckedFromBytes(value, startIndex, 4)));
		}

		public ulong ToUInt64(byte[] value, int startIndex)
		{
			return unchecked((ulong)(CheckedFromBytes(value, startIndex, 8)));
		}

		private static void CheckByteArgument(byte[] value, int startIndex, int bytesRequired)
		{
			if (value == null)
			{
				throw new ArgumentNullException(nameof(value));
			}
			if (startIndex < 0 || startIndex > value.Length - bytesRequired)
			{
				throw new ArgumentOutOfRangeException(nameof(startIndex));
			}
		}

		private long CheckedFromBytes(byte[] value, int startIndex, int bytesToConvert)
		{
			CheckByteArgument(value, startIndex, bytesToConvert);
			return FromBytes(value, startIndex, bytesToConvert);
		}

		protected abstract long FromBytes(byte[] value, int startIndex, int bytesToConvert);

		#endregion

		#region ToString conversions

		public static string ToString(byte[] value)
		{
			return BitConverter.ToString(value);
		}

		public static string ToString(byte[] value, int startIndex)
		{
			return BitConverter.ToString(value, startIndex);
		}

		public static string ToString(byte[] value, int startIndex, int length)
		{
			return BitConverter.ToString(value, startIndex, length);
		}

		#endregion

		#region	Decimal conversions

		public decimal ToDecimal(byte[] value, int startIndex)
		{
			// HACK: This always assumes four parts, each in their own endianness,
			// starting with the first part at the start of the byte array.
			// On the other hand, there's no real format specified...
			var parts = new int[4];
			for (var i = 0; i < 4; i++)
			{
				parts[i] = ToInt32(value, startIndex + i * 4);
			}
			return new decimal(parts);
		}

		public byte[] GetBytes(decimal value)
		{
			var bytes = new byte[16];
			var parts = decimal.GetBits(value);
			for (var i = 0; i < 4; i++)
			{
				CopyBytesImpl(parts[i], 4, bytes, i * 4);
			}
			return bytes;
		}

		public void CopyBytes(decimal value, byte[] buffer, int index)
		{
			var parts = decimal.GetBits(value);
			for (var i = 0; i < 4; i++)
			{
				CopyBytesImpl(parts[i], 4, buffer, i * 4 + index);
			}
		}

		#endregion

		#region GetBytes conversions

		private byte[] GetBytes(long value, int bytes)
		{
			var buffer = new byte[bytes];
			CopyBytes(value, bytes, buffer, 0);
			return buffer;
		}

		public byte[] GetBytes(bool value)
		{
			return BitConverter.GetBytes(value);
		}

		public byte[] GetBytes(char value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(double value)
		{
			return GetBytes(DoubleToInt64Bits(value), 8);
		}

		public byte[] GetBytes(short value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(int value)
		{
			return GetBytes(value, 4);
		}

		public byte[] GetBytes(long value)
		{
			return GetBytes(value, 8);
		}

		public byte[] GetBytes(float value)
		{
			return GetBytes(SingleToInt32Bits(value), 4);
		}

		public byte[] GetBytes(ushort value)
		{
			return GetBytes(value, 2);
		}

		public byte[] GetBytes(uint value)
		{
			return GetBytes(value, 4);
		}

		public byte[] GetBytes(ulong value)
		{
			return GetBytes(unchecked((long)value), 8);
		}

		#endregion

		#region CopyBytes conversions

		private void CopyBytes(long value, int bytes, byte[] buffer, int index)
		{
			if (buffer == null)
			{
				throw new ArgumentNullException(nameof(buffer), "Byte array must not be null");
			}
			if (buffer.Length < index + bytes)
			{
				throw new ArgumentOutOfRangeException(nameof(buffer), "Buffer not big enough for value");
			}
			CopyBytesImpl(value, bytes, buffer, index);
		}

		protected abstract void CopyBytesImpl(long value, int bytes, byte[] buffer, int index);

		public void CopyBytes(bool value, byte[] buffer, int index)
		{
			CopyBytes(value ? 1 : 0, 1, buffer, index);
		}

		public void CopyBytes(char value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(double value, byte[] buffer, int index)
		{
			CopyBytes(DoubleToInt64Bits(value), 8, buffer, index);
		}

		public void CopyBytes(short value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(int value, byte[] buffer, int index)
		{
			CopyBytes(value, 4, buffer, index);
		}

		public void CopyBytes(long value, byte[] buffer, int index)
		{
			CopyBytes(value, 8, buffer, index);
		}

		public void CopyBytes(float value, byte[] buffer, int index)
		{
			CopyBytes(SingleToInt32Bits(value), 4, buffer, index);
		}

		public void CopyBytes(ushort value, byte[] buffer, int index)
		{
			CopyBytes(value, 2, buffer, index);
		}

		public void CopyBytes(uint value, byte[] buffer, int index)
		{
			CopyBytes(value, 4, buffer, index);
		}

		public void CopyBytes(ulong value, byte[] buffer, int index)
		{
			CopyBytes(unchecked((long)value), 8, buffer, index);
		}

		#endregion

		#region Private struct used for Single/Int32 conversions

		[StructLayout(LayoutKind.Explicit)]
		private readonly struct Int32SingleUnion
		{
			[FieldOffset(0)]
			private readonly int i;

			[FieldOffset(0)]
			private readonly float f;

			internal Int32SingleUnion(int i)
			{
				this.f = 0; // Just to keep the compiler happy
				this.i = i;
			}

			internal Int32SingleUnion(float f)
			{
				this.i = 0; // Just to keep the compiler happy
				this.f = f;
			}

			internal int AsInt32 => i;

			internal float AsSingle => f;
		}

		#endregion
	}

	public sealed class BigEndianBitConverter : EndianBitConverter
	{
		public override bool IsLittleEndian()
		{
			return false;
		}

		public override Endianness Endianness => Endianness.BigEndian;

		protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
		{
			var endOffset = index + bytes - 1;
			for (var i = 0; i < bytes; i++)
			{
				buffer[endOffset - i] = unchecked((byte)(value & 0xff));
				value = value >> 8;
			}
		}

		protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
		{
			long ret = 0;
			for (var i = 0; i < bytesToConvert; i++)
			{
				ret = unchecked((ret << 8) | buffer[startIndex + i]);
			}
			return ret;
		}
	}

	public sealed class LittleEndianBitConverter : EndianBitConverter
	{
		public override bool IsLittleEndian()
		{
			return true;
		}

		public override Endianness Endianness => Endianness.LittleEndian;

		protected override void CopyBytesImpl(long value, int bytes, byte[] buffer, int index)
		{
			for (var i = 0; i < bytes; i++)
			{
				buffer[i + index] = unchecked((byte)(value & 0xff));
				value = value >> 8;
			}
		}

		protected override long FromBytes(byte[] buffer, int startIndex, int bytesToConvert)
		{
			long ret = 0;
			for (var i = 0; i < bytesToConvert; i++)
			{
				ret = unchecked((ret << 8) | buffer[startIndex + bytesToConvert - 1 - i]);
			}
			return ret;
		}
	}

	/* end of Jon Skeet and Marc Gravell code */
	#endregion


	[Obsolete("Left for backward compatibility. Use GameDataFormat instead.")]
	public static class Format
	{
		public static readonly GameDataFormat Json = GameDataFormat.Json;
		public static readonly GameDataFormat MessagePack = GameDataFormat.MessagePack;
	}


	public enum GameDataFormat
	{
		Json,
		MessagePack
	}


	public class GameDataLoadOptions
	{
		public GameDataFormat Format { get; set; }
		public IReadOnlyList<Stream> Patches { get; set; }
		public Encoding Encoding { get; set; }
		public bool LeaveStreamsOpen { get; set; }

		public GameDataLoadOptions()
		{
			this.Format = GameDataFormat.Json;
			this.Patches = Array.Empty<Stream>();
			this.Encoding = Encoding.UTF8;
			this.LeaveStreamsOpen = false;
		}

		/// <inheritdoc />
		public override string ToString()
		{
			return $"Format: {this.Format}, Patches: {string.Join(", ", this.Patches)}, Encoding: {this.Encoding.WebName}, Leave Open: {this.LeaveStreamsOpen}";
		}
	}


	public class GameDataObjectReader : GameDataReader
	{
		private ReaderFrame[] frames;
		private int topFrameIndex;
		private ReaderNode currentNode;

		/// <inheritdoc />
		public override ReaderNode Node => this.currentNode;
		/// <inheritdoc />
		public override int LineNumber => 0;
		/// <inheritdoc />
		public override int ColumnNumber => 0;

		public GameDataObjectReader(IReadOnlyDictionary<string, object> gameDataPatch)
		{
			this.frames = new ReaderFrame[10];
			this.topFrameIndex = -1;
			this.PushFrame(gameDataPatch);
			this.topFrameIndex = int.MinValue;
		}

		/// <inheritdoc />
		public override bool NextToken()
		{
			if (this.topFrameIndex == int.MinValue)
			{
				this.topFrameIndex = 0;
				this.currentNode = new ReaderNode(this.frames[this.topFrameIndex].ContainerType);
				return true;
			}

			while (this.topFrameIndex >= 0)
			{
				var nextToken = ReaderFrame.GetState(ref this.frames[this.topFrameIndex]);
				switch (nextToken)
				{
					case ReaderToken.Member:
						var memberName = this.frames[this.topFrameIndex].MemberName;
						this.currentNode = new ReaderNode(nextToken, memberName);
						return true;
					case ReaderToken.Value:
						this.currentNode = new ReaderNode(nextToken, this.frames[this.topFrameIndex].Current);
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						return true;
					case ReaderToken.EndOfObject:
					case ReaderToken.EndOfArray:
						this.PopFrame();
						this.currentNode = new ReaderNode(nextToken);
						return true;
					case ReaderToken.BeginObject:
						var dictionary = (IReadOnlyDictionary<string, object>)this.frames[this.topFrameIndex].Current;
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						this.PushFrame(dictionary);
						this.currentNode = new ReaderNode(nextToken);
						return true;
					case ReaderToken.BeginArray:
						var list = (IReadOnlyList<object>)this.frames[this.topFrameIndex].Current;
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						this.PushFrame(list);
						this.currentNode = new ReaderNode(nextToken);
						return true;
					case ReaderToken.Null:
						ReaderFrame.Next(ref this.frames[this.topFrameIndex]);
						this.currentNode = new ReaderNode(nextToken);
						return true;
				}
			}

			return false;
		}

		private void PushFrame(IReadOnlyDictionary<string, object> dictionary)
		{
			if (this.topFrameIndex == this.frames.Length)
			{
				Array.Resize(ref this.frames, (int)(this.frames.Length * 1.5));
			}

			this.frames[++this.topFrameIndex] = new ReaderFrame(dictionary);
		}
		private void PushFrame(IReadOnlyList<object> list)
		{
			if (this.topFrameIndex == this.frames.Length)
			{
				Array.Resize(ref this.frames, (int)(this.frames.Length * 1.5));
			}

			this.frames[++this.topFrameIndex] = new ReaderFrame(list);
		}
		private void PopFrame()
		{
			this.frames[this.topFrameIndex] = default;
			this.topFrameIndex--;
		}

		/// <inheritdoc />
		public override void Dispose()
		{
			Array.Clear(this.frames, 0, this.frames.Length);
			this.topFrameIndex = -1;
		}

		private struct ReaderFrame
		{
			private bool memberNameVisited;
			private int currentIndex;
			private readonly IReadOnlyList<object> list;
			private readonly IndexedDictionary<string, object> dictionary;

			public string MemberName => this.dictionary?.Keys[this.currentIndex];
			public object Current => this.list != null ? this.list[this.currentIndex] : this.dictionary?[this.dictionary.Keys[this.currentIndex]];
			public ReaderToken ContainerType => this.list != null ? ReaderToken.BeginArray : this.dictionary != null ? ReaderToken.BeginObject : ReaderToken.EndOfStream;
			private bool IsInBounds => this.currentIndex < (this.list?.Count ?? (this.dictionary?.Count ?? 0));

			public ReaderFrame(IReadOnlyList<object> list)
			{
				if (list == null) throw new ArgumentNullException(nameof(list));

				this.dictionary = default;
				this.list = list;
				this.currentIndex = 0;
				this.memberNameVisited = false;
			}
			public ReaderFrame(IReadOnlyDictionary<string, object> dictionary)
			{
				if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));

				this.dictionary = dictionary as IndexedDictionary<string, object> ?? new IndexedDictionary<string, object>(dictionary);
				this.list = default;
				this.currentIndex = 0;
				this.memberNameVisited = false;
			}

			public static void Next(ref ReaderFrame readerFrame)
			{
				readerFrame.currentIndex++;
				readerFrame.memberNameVisited = false;
			}
			public static ReaderToken GetState(ref ReaderFrame readerFrame)
			{
				var isObjectIteration = readerFrame.dictionary != null;
				if (!readerFrame.IsInBounds)
				{
					return isObjectIteration ? ReaderToken.EndOfObject : ReaderToken.EndOfArray;
				}

				if (isObjectIteration && !readerFrame.memberNameVisited)
				{
					readerFrame.memberNameVisited = true;
					return ReaderToken.Member;
				}

				readerFrame.memberNameVisited = false;
				var currentObject = readerFrame.Current;
				if (currentObject is IReadOnlyDictionary<string, object>)
				{
					return ReaderToken.BeginObject;
				}
				else if (currentObject is IReadOnlyList<object>)
				{
					return ReaderToken.BeginArray;
				}
				else
				{
					return currentObject == null ? ReaderToken.Null : ReaderToken.Value;
				}
			}
		}
	}


	public abstract partial class GameDataReader : IDisposable
	{
		public static readonly string[] DateTimeFormats = new string[] { "yyyy-MM-ddTHH:mm:ss.fffZ", "o" };

		public abstract ReaderNode Node { get; }

		public abstract int LineNumber { get; }
		public abstract int ColumnNumber { get; }

		public abstract bool NextToken();

		public bool IsEndOfStream()
		{
			return this.Node.Token == ReaderToken.EndOfStream;
		}
		public bool IsNull()
		{
			return this.Node.Token == ReaderToken.Null;
		}
		public void ThrowIfNotValue()
		{
			if (this.Node.Token != ReaderToken.Value)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.Value);
			}
		}
		public void ThrowIfNull(string expected, string propertyName, string schemaName)
		{
			if (this.Node.Token == ReaderToken.Null)
			{
				throw ReaderException.UnexpectedNullValue(expected, propertyName, schemaName, this);
			}
		}

		public object ReadAny(bool nextToken = true)
		{
			// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
			switch(this.Node.Token)
			{
				case ReaderToken.BeginArray: return this.ReadArray(nextToken);
				case ReaderToken.BeginObject: return this.ReadObject(nextToken);
				case ReaderToken.Null: if (nextToken) this.NextToken(); return null;
				case ReaderToken.Value: var value = this.Node.AsObject; if (nextToken) this.NextToken(); return value;
				default: throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray, ReaderToken.BeginObject, ReaderToken.Null, ReaderToken.Value);
			}
		}
		public List<object> ReadArray(bool nextToken = true)
		{
			var list = new List<object>();
			this.ReadArrayBegin();
			while(this.Node.Token != ReaderToken.EndOfArray)
			{
				var value = this.ReadAny();
				list.Add(value);
			}
			this.ReadArrayEnd( nextToken);
			return list;
		}
		public IndexedDictionary<string, object> ReadObject(bool nextToken = true)
		{
			var dictionary = new IndexedDictionary<string, object>();
			this.ReadObjectBegin();
			while(this.Node.Token != ReaderToken.EndOfObject)
			{
				var key = this.ReadMember();
				var value = this.ReadAny();
				dictionary[key] = value;
			}
			this.ReadObjectEnd(nextToken);
			return dictionary;
		}
		public void SkipAny(bool nextToken = true)
		{
			// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
			switch(this.Node.Token)
			{
				case ReaderToken.BeginArray: this.SkipArray(nextToken); break;
				case ReaderToken.BeginObject: this.SkipObject(nextToken); break;
				case ReaderToken.Member: if (nextToken) this.NextToken(); break;
				case ReaderToken.Null: if (nextToken) this.NextToken(); break;
				case ReaderToken.Value: if (nextToken) this.NextToken(); break;
				default: throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray, ReaderToken.BeginObject, ReaderToken.Null, ReaderToken.Value);
			}
		}
		public void SkipArray(bool nextToken = true)
		{
			this.ReadArrayBegin();
			while(this.Node.Token != ReaderToken.EndOfArray)
			{
				this.SkipAny();
			}
			this.ReadArrayEnd( nextToken);
		}
		public void SkipObject(bool nextToken = true)
		{
			this.ReadObjectBegin();
			while(this.Node.Token != ReaderToken.EndOfObject)
			{
				this.SkipAny();
				this.SkipAny();
			}
			this.ReadObjectEnd(nextToken);
		}

		public void ReadArrayBegin(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.BeginArray)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.BeginArray);
			}
			if (this.IsEndOfStream())
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfArray);
			}

			if (nextToken)
				this.NextToken();
		}
		public void ReadArrayEnd(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.EndOfArray)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfArray);
			}

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}
		}
		public void ReadObjectBegin(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.BeginObject)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.BeginObject);
			}

			if (this.IsEndOfStream())
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfObject);
			}

			if (nextToken)
			{
				this.NextToken();
			}
		}
		public void ReadObjectEnd(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.EndOfObject)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.EndOfObject);
			}

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}
		}
		public string ReadMember(bool nextToken = true)
		{
			if (this.Node.Token != ReaderToken.Member && this.Node.Token != ReaderToken.Value)
			{
				throw ReaderException.UnexpectedToken(this, ReaderToken.Member, ReaderToken.Value);
			}

			var memberName = this.Node.AsString;

			if (!this.IsEndOfStream() && nextToken)
			{
				this.NextToken();
			}

			return memberName;
		}

		public string DebugPrintTokens()
		{
			var output = new StringBuilder();
			var stack = new Stack<ReaderToken>();
			stack.Push(ReaderToken.None);
			while (this.NextToken())
			{
				var strValue = Convert.ToString(this.Node.Token, CultureInfo.InvariantCulture) +
					(this.Node.HasValue ? "[" + this.Node.AsString + "]" : "");

				if (stack.Peek() != ReaderToken.Member)
				{
					var endingTokenIndent = this.Node.Token == ReaderToken.EndOfObject || this.Node.Token == ReaderToken.EndOfArray ? -1 : 0;
					output.Append(Environment.NewLine);
					for (var i = 0; i < System.Linq.Enumerable.Count(stack, t => t != ReaderToken.Member && t != ReaderToken.None) + endingTokenIndent; i++)
					{
						output.Append("\t");
					}
				}
				else output.Append(" ");

				output.Append(strValue);

				if (this.Node.Token == ReaderToken.EndOfObject || this.Node.Token == ReaderToken.EndOfArray || stack.Peek() == ReaderToken.Member)
				{
					stack.Pop();
				}
				if (this.Node.Token == ReaderToken.BeginObject || this.Node.Token == ReaderToken.BeginArray || this.Node.Token == ReaderToken.Member)
				{
					stack.Push(this.Node.Token);
				}

			}

			return output.ToString();
		}

		/// <inheritdoc />
		public abstract void Dispose();

		public override string ToString()
		{
			return this.Node.ToString();
		}

	}


	[Serializable, DebuggerDisplay("IndexedDictionary, Count: {" + nameof(Count) + "}")]
	public sealed class IndexedDictionary<KeyT, ValueT> : IDictionary<KeyT, ValueT>, IReadOnlyDictionary<KeyT, ValueT>, IDictionary
	{
		public struct Enumerator : IEnumerator<KeyValuePair<KeyT, ValueT>>, IDictionaryEnumerator
		{
			private List<KeyT>.Enumerator innerEnumerator;
			private readonly IndexedDictionary<KeyT, ValueT> dictionary;

			public Enumerator(IndexedDictionary<KeyT, ValueT> dictionary)
			{
				this.dictionary = dictionary;
				this.innerEnumerator = dictionary.keys.GetEnumerator();
				this.Current = new KeyValuePair<KeyT, ValueT>();
			}

			public KeyValuePair<KeyT, ValueT> Current { get; private set; }
			object IEnumerator.Current => this.Current;
			public object Key => this.Current.Key;
			public object Value => this.Current.Value;
			public DictionaryEntry Entry => ToEntry(this.Current);

			public bool MoveNext()
			{
				if (!this.innerEnumerator.MoveNext()) return false;

				var key = this.innerEnumerator.Current;

				Debug.Assert(!ReferenceEquals(key, null), "key is null");

				this.Current = new KeyValuePair<KeyT, ValueT>(key, this.dictionary.dictionary[key]);
				return true;
			}
			public void Reset()
			{
				this.innerEnumerator = this.dictionary.keys.GetEnumerator();
			}
			public void Dispose()
			{
				this.innerEnumerator.Dispose();
			}
		}

		[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] private readonly Dictionary<KeyT, ValueT> dictionary;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] private readonly List<KeyT> keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never), NonSerialized] private ReadOnlyCollection<KeyT> keysReadOnly;

		[DebuggerBrowsable(DebuggerBrowsableState.Never)] public ReadOnlyCollection<KeyT> Keys => this.keysReadOnly ?? (this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys));
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] public Dictionary<KeyT, ValueT>.ValueCollection Values => this.dictionary.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool ICollection<KeyValuePair<KeyT, ValueT>>.IsReadOnly => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection<KeyT> IDictionary<KeyT, ValueT>.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] IEnumerable<ValueT> IReadOnlyDictionary<KeyT, ValueT>.Values => this.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] IEnumerable<KeyT> IReadOnlyDictionary<KeyT, ValueT>.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection<ValueT> IDictionary<KeyT, ValueT>.Values => this.dictionary.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection IDictionary.Values => this.Values;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] ICollection IDictionary.Keys => this.Keys;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool IDictionary.IsReadOnly => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool IDictionary.IsFixedSize => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] object ICollection.SyncRoot => this.dictionary;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)] bool ICollection.IsSynchronized => false;
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		object IDictionary.this[object key]
		{
			get => this[CastKey(key)];
			set => this[CastKey(key)] = CastValue(value);
		}

		public int Count => this.dictionary.Count;

		public ValueT this[KeyT key]
		{
			get => this.dictionary[key];
			set
			{
				if (this.dictionary.ContainsKey(key) == false) this.keys.Add(key);
				this.dictionary[key] = value;
			}
		}

		public IndexedDictionary()
		{
			this.dictionary = new Dictionary<KeyT, ValueT>();
			this.keys = new List<KeyT>();
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(int count)
		{
			if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));

			if (count == 0) count = 30;

			this.dictionary = new Dictionary<KeyT, ValueT>(count);
			this.keys = new List<KeyT>(count);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(IDictionary<KeyT, ValueT> dictionary)
		{
			if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));

			this.dictionary = new Dictionary<KeyT, ValueT>(dictionary);
			this.keys = new List<KeyT>(dictionary.Keys);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}
		public IndexedDictionary(IEnumerable<KeyValuePair<KeyT, ValueT>> pairs)
		{
			if (pairs == null) throw new ArgumentNullException(nameof(pairs));

			this.dictionary = new Dictionary<KeyT, ValueT>();
			this.keys = new List<KeyT>();
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);

			foreach (var pair in pairs)
			{
				this.Add(pair.Key, pair.Value);
			}
		}
		public IndexedDictionary(IDictionary<KeyT, ValueT> dictionary, ICollection<KeyT> keys)
		{
			if (dictionary == null) throw new ArgumentNullException(nameof(dictionary));
			if (keys == null) throw new ArgumentNullException(nameof(keys));

			this.dictionary = new Dictionary<KeyT, ValueT>(dictionary);
			this.keys = new List<KeyT>(keys);
			this.keysReadOnly = new ReadOnlyCollection<KeyT>(this.keys);
		}

		public void Add(KeyT key, ValueT value)
		{
			this.dictionary.Add(key, value);
			this.keys.Add(key);
		}
		public void Add(IndexedDictionary<KeyT, ValueT> other)
		{
			if (other == null) throw new ArgumentNullException(nameof(other));

			if (this.Count == 0)
			{
				this.keys.AddRange(other.keys);
				foreach (var kv in other.dictionary)
				{
					this.dictionary.Add(kv.Key, kv.Value);
				}
			}
			else
			{
				foreach (var kv in other.dictionary)
				{
					this.dictionary.Add(kv.Key, kv.Value);
					this.keys.Add(kv.Key);
				}
			}
		}

		public void Insert(int index, KeyT key, ValueT value)
		{
			// Dictionary operation first, so exception thrown if key already exists.
			this.dictionary.Add(key, value);
			this.keys.Insert(index, key);
		}
		public bool ContainsKey(KeyT key)
		{
			return this.dictionary.ContainsKey(key);
		}
		public bool ContainsKey(KeyT key, IEqualityComparer<KeyT> keyComparer)
		{
			if (keyComparer == null) throw new ArgumentNullException(nameof(keyComparer));

			foreach (var k in this.keys)
			{
				if (keyComparer.Equals(k, key))
				{
					return true;
				}
			}

			return false;
		}
		public bool ContainsValue(ValueT value)
		{
			foreach (var kv in this.dictionary)
			{
				if (Equals(value, kv.Value))
				{
					return true;
				}
			}

			return false;
		}
		public bool ContainsValue(ValueT value, IEqualityComparer comparer)
		{
			if (comparer == null) throw new ArgumentNullException(nameof(comparer));

			foreach (var kv in this.dictionary)
			{
				if (comparer.Equals(value, kv.Value))
				{
					return true;
				}
			}

			return false;
		}
		public bool Remove(KeyT key)
		{
			var wasInDictionary = this.dictionary.Remove(key);
			this.keys.Remove(key);

			return wasInDictionary;
		}

		public bool TryGetValue(KeyT key, out ValueT value)
		{
			return this.dictionary.TryGetValue(key, out value);
		}

		public int IndexOf(KeyT key)
		{
			return this.keys.IndexOf(key);
		}
		public void RemoveAt(int index)
		{
			if (index >= this.Count || index < 0) throw new ArgumentOutOfRangeException(nameof(index));

			var key = this.keys[index];
			this.dictionary.Remove(key);
			this.keys.RemoveAt(index);
		}
		public void SortKeys(IComparer<KeyT> comparer)
		{
			if (comparer == null) throw new ArgumentNullException(nameof(comparer));

			this.keys.Sort(comparer);
		}

		public void Clear()
		{
			this.dictionary.Clear();
			this.keys.Clear();
		}

		bool IDictionary.Contains(object key)
		{
			return this.ContainsKey(CastKey(key));
		}
		void IDictionary.Add(object key, object value)
		{
			this.Add(CastKey(key), CastValue(value));
		}
		void IDictionary.Remove(object key)
		{
			this.Remove(CastKey(key));
		}
		void ICollection.CopyTo(Array array, int index)
		{
			foreach (var pair in this)
			{
				array.SetValue(ToEntry(pair), index++);
			}
		}

		void ICollection<KeyValuePair<KeyT, ValueT>>.Add(KeyValuePair<KeyT, ValueT> item)
		{
			this.Add(item.Key, item.Value);
		}
		bool ICollection<KeyValuePair<KeyT, ValueT>>.Contains(KeyValuePair<KeyT, ValueT> item)
		{
			return this.dictionary.TryGetValue(item.Key, out var value) && Equals(value, item.Value);
		}
		void ICollection<KeyValuePair<KeyT, ValueT>>.CopyTo(KeyValuePair<KeyT, ValueT>[] array, int arrayIndex)
		{
			foreach (var pair in this)
			{
				array[arrayIndex++] = pair;
			}
		}
		bool ICollection<KeyValuePair<KeyT, ValueT>>.Remove(KeyValuePair<KeyT, ValueT> item)
		{
			if (((ICollection<KeyValuePair<KeyT, ValueT>>)this).Contains(item) == false)
			{
				return false;
			}

			return this.Remove(item.Key);
		}
		IEnumerator<KeyValuePair<KeyT, ValueT>> IEnumerable<KeyValuePair<KeyT, ValueT>>.GetEnumerator()
		{
			return this.GetEnumerator();
		}

		IDictionaryEnumerator IDictionary.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		IEnumerator IEnumerable.GetEnumerator()
		{
			return this.GetEnumerator();
		}
		public Enumerator GetEnumerator()
		{
			return new Enumerator(this);
		}

		private static ValueT CastValue(object value)
		{
			if (value == null) return default;

			return (ValueT)value;
		}
		private static KeyT CastKey(object key)
		{
			if (key == null) throw new ArgumentNullException(nameof(key));

			return (KeyT)key;
		}
		private static DictionaryEntry ToEntry(KeyValuePair<KeyT, ValueT> value)
		{
			return new DictionaryEntry(value.Key, value.Value);
		}

		public override string ToString()
		{
			return "Count: " + Convert.ToString(this.Count, CultureInfo.InvariantCulture);
		}
	}


	public class IndexedString : IComparable<IndexedString>
	{
		public readonly string Value;
		public readonly ulong[] Octets;

		public IndexedString(string value)
		{
			this.Value = value;
			this.Octets = new ulong[8];
			for (var i = 0; i < 8; i++)
			{
				this.Octets[i] = GetUInt64(value, 8 * i);
			}
		}

		public int CompareTo(IndexedString otherString)
		{
			if (this.Value.Length != otherString.Value.Length)
			{
				return this.Value.Length.CompareTo(otherString.Value.Length);
			}

			for (var i = 0; i < this.Octets.Length; i++)
			{
				var comp = this.Octets[i].CompareTo(otherString.Octets[i]);
				if (comp != 0)
				{
					return comp;
				}
			}

			return 0;
		}

		private static ulong GetUInt64(string chars, int offset)
		{
			if (offset >= chars.Length)
			{
				return 0;
			}

			var result = 0L;
			var bytesToConvert = Math.Min(chars.Length - offset, 8);
			for (var i = 0; i < bytesToConvert; i++)
			{
				result = unchecked((result << 8) | chars[offset + bytesToConvert - 1 - i]);
			}

			return unchecked((ulong)result);
		}
	}


	public interface IStrongBox
	{
		bool AsBoolean { get; }
		byte AsByte { get; }
		short AsInt16 { get; }
		int AsInt32 { get; }
		long AsInt64 { get; }
		sbyte AsSByte { get; }
		ushort AsUInt16 { get; }
		uint AsUInt32 { get; }
		ulong AsUInt64 { get; }
		float AsSingle { get; }
		double AsDouble { get; }
		decimal AsDecimal { get; }
		DateTimeOffset AsDateTimeOffset { get; }
		DateTime AsDateTime { get; }
		TimeSpan AsTimeSpan { get; }
		Type ValueType { get; }
		object AsObject { get; }

		void Store<T>(T value);
	}


	public sealed class JsonGameDataReader : GameDataReader
	{
		private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue / 2;
		private const int CHAR_SIZE = 2;

		const int LEXER_STATE_COMPLETE = -1;
		const int LEXER_STATE_START = 0;
		const int LEXER_STATE_LEXEME = 1;
		const int LEXER_STATE_QUOTED = 2;
		const int LEXER_STATE_QUOTED_ESCAPE = 3;
		const int LEXER_STATE_COMMENT_BEGINNING = 4;
		const int LEXER_STATE_COMMENT_SINGLE_LINE = 5;
		const int LEXER_STATE_COMMENT_MULTILINE = 6;
		const int LEXER_STATE_COMMENT_MULTILINE_ENDING = 7;

		private const int NUMBER_FLOAT = 2;
		private const int NUMBER_FLOAT_WITH_EXP = 3;
		private const int NUMBER_INTEGER = 0;
		private const int NUMBER_NEGATIVE_INTEGER = 1;
		private const int NUMBER_NOT = -1;

		private static readonly int Int32MaxLength = int.MaxValue.ToString().Length;
		private static readonly int Int64MaxLength = long.MaxValue.ToString().Length;

		private readonly ArraySegment<char> lexemeTrue = new ArraySegment<char>(JsonNotation.True.ToCharArray(), 0, 4);
		private readonly ArraySegment<char> lexemeFalse = new ArraySegment<char>(JsonNotation.False.ToCharArray(), 0, 5);
		private readonly ArraySegment<char> lexemeNull = new ArraySegment<char>(JsonNotation.Null.ToCharArray(), 0, 4);

		private readonly bool leaveOpen;
		private readonly TextReader textReader;
		private readonly Stack<ReaderToken> structure;

		// tokenizing
		private readonly char[] buffer;
		private int bufferOffset;
		private int bufferAvailable;
		private int lineNum = 1;
		private int colNum = 1;

		// parsing
		private ReaderNode node;
		private ArraySegment<char> rawJson;

		private StrongBox<bool> trueBox;
		private StrongBox<bool> falseBox;
		private StrongBox<int> intBox;
		private StrongBox<DateTime> dateBox;
		private JsonValueBox jsonValueBox;

		public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }

		// statistics
		public override int LineNumber => this.lineNum;
		public override int ColumnNumber => this.colNum;

		public JsonGameDataReader(Stream stream, Encoding encoding, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
			: this(new StreamReader(stream, encoding, detectEncodingFromByteOrderMarks: true, leaveOpen: leaveOpen, bufferSize: bufferSize), leaveOpen, bufferSize)
		{

		}
		public JsonGameDataReader(TextReader textReader, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
		{
			if (textReader == null) throw new ArgumentNullException(nameof(textReader));
			if (bufferSize <= 0) throw new ArgumentOutOfRangeException(nameof(bufferSize));

			this.structure = new Stack<ReaderToken>();
			this.buffer = new char[bufferSize];
			this.textReader = textReader;
			this.leaveOpen = leaveOpen;
		}

		public override bool NextToken()
		{
			this.rawJson = default;
			this.node = default;

			var fragments = default(ArraySegment<char>[]);
			var state = LEXER_STATE_COMPLETE;
			var lexemeSize = 0;
			var memberOrValueToken = ReaderToken.Value;

			if (this.structure.Count > 0)
			{
				// ReSharper disable once SwitchStatementMissingSomeCases
				switch (this.structure.Peek())
				{
					case ReaderToken.Member:
						this.structure.Pop();
						break;
					case ReaderToken.BeginObject:
						this.structure.Push(memberOrValueToken = ReaderToken.Member);
						break;
				}
			}

			var lexeme = this.NextLexeme(ref state);
			if (lexeme.Count == 0)
			{
				this.node = new ReaderNode(ReaderToken.EndOfStream);
				return false;
			}
			if (state != LEXER_STATE_COMPLETE)
			{
				var firstFragment = Copy(ref lexeme);
				var secondFragment = this.NextLexeme(ref state);

				if (state == LEXER_STATE_COMPLETE)
				{
					if (secondFragment.Count == 0)
					{
						lexeme = firstFragment;
						lexemeSize = lexeme.Count;
					}
					else
					{
						fragments = new[] { firstFragment, secondFragment };
						lexemeSize = firstFragment.Count + secondFragment.Count;
					}
				}
				else
				{
					var fragmentIndex = 0;
					fragments = new ArraySegment<char>[8];
					fragments[fragmentIndex++] = firstFragment;
					fragments[fragmentIndex++] = Copy(ref secondFragment);
					lexemeSize = firstFragment.Count + secondFragment.Count;

					do
					{
						lexeme = this.NextLexeme(ref state);

						if (lexeme.Count == 0)
						{
							break;
						}
						if (fragmentIndex == fragments.Length)
						{
							Array.Resize(ref fragments, (int)(fragments.Length * 1.5));
						}

						fragments[fragmentIndex++] = Copy(ref lexeme);
						lexemeSize += lexeme.Count;

					} while (state != LEXER_STATE_COMPLETE);
				}
			}
			else
			{
				lexemeSize = lexeme.Count;
			}

			if (lexemeSize == 1)
			{
				this.rawJson = fragments != null ? fragments[0] : lexeme;
				System.Diagnostics.Debug.Assert(this.rawJson.Array != null, "this.rawJson.Array");
				switch (this.rawJson.Array[this.rawJson.Offset])
				{
					case JsonNotation.Const0: this.node = new ReaderNode(memberOrValueToken, this.Box(0)); return true;
					case JsonNotation.Const1: this.node = new ReaderNode(memberOrValueToken, this.Box(1)); return true;
					case JsonNotation.Const2: this.node = new ReaderNode(memberOrValueToken, this.Box(2)); return true;
					case JsonNotation.Const3: this.node = new ReaderNode(memberOrValueToken, this.Box(3)); return true;
					case JsonNotation.Const4: this.node = new ReaderNode(memberOrValueToken, this.Box(4)); return true;
					case JsonNotation.Const5: this.node = new ReaderNode(memberOrValueToken, this.Box(5)); return true;
					case JsonNotation.Const6: this.node = new ReaderNode(memberOrValueToken, this.Box(6)); return true;
					case JsonNotation.Const7: this.node = new ReaderNode(memberOrValueToken, this.Box(7)); return true;
					case JsonNotation.Const8: this.node = new ReaderNode(memberOrValueToken, this.Box(8)); return true;
					case JsonNotation.Const9: this.node = new ReaderNode(memberOrValueToken, this.Box(9)); return true;
					case JsonNotation.BeginArray:
						this.structure.Push(ReaderToken.BeginArray);
						this.node = new ReaderNode(ReaderToken.BeginArray);
						return true;
					case JsonNotation.BeginObject:
						this.structure.Push(ReaderToken.BeginObject);
						this.node = new ReaderNode(ReaderToken.BeginObject);
						return true;
					case JsonNotation.EndArray:
						this.structure.Pop();
						this.node = new ReaderNode(ReaderToken.EndOfArray);
						return true;
					case JsonNotation.EndObject:
						this.structure.Pop();
						this.structure.Pop();
						this.node = new ReaderNode(ReaderToken.EndOfObject);
						return true;
					default: throw ReaderException.UnknownNotation(this, new string(this.rawJson.Array, this.rawJson.Offset, this.rawJson.Count));
				}
			}
			if (lexemeSize == 4)
			{
				if (Match(ref lexeme, fragments, 0, this.lexemeTrue))
				{
					this.rawJson = this.lexemeTrue;
					this.node = new ReaderNode(memberOrValueToken, this.Box(true));
					return true;
				}
				if (Match(ref lexeme, fragments, 0, this.lexemeNull))
				{
					this.rawJson = this.lexemeNull;
					this.node = new ReaderNode(ReaderToken.Null);
					return true;
				}
			}
			if (lexemeSize == 5 && Match(ref lexeme, fragments, 0, this.lexemeFalse))
			{
				this.rawJson = this.lexemeFalse;
				this.node = new ReaderNode(memberOrValueToken, this.Box(false));
				return true;
			}

			// combine fragments into one lexeme
			if (fragments != null)
			{
				var combined = new char[lexemeSize];
				var offset = 0;
				foreach (var fragment in fragments)
				{
					if (fragment.Array == null) break;
					Buffer.BlockCopy(fragment.Array, fragment.Offset * CHAR_SIZE, combined, offset * CHAR_SIZE, fragment.Count * CHAR_SIZE);
					offset += fragment.Count;
				}
				lexeme = new ArraySegment<char>(combined, 0, offset);
				//fragments = null;
			}

			this.rawJson = lexeme;
			System.Diagnostics.Debug.Assert(lexeme.Array != null, "lexeme.Array");
			if (lexeme.Array[lexeme.Offset] == JsonNotation.Quote) // start with quote
			{
				if (lexeme.Array[lexeme.Offset + lexeme.Count - 1] != JsonNotation.Quote) // not ending with quote
					throw ReaderException.UnterminatedStringLiteral(this);

				if (lexemeSize == 2)
				{
					this.node = new ReaderNode(memberOrValueToken, string.Empty);
					return true;
				}

				this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme));
				return true;
			}

			switch (GetNumberType(ref lexeme))
			{
				case NUMBER_INTEGER:
					var integerType = lexeme.Count < Int32MaxLength
						? typeof(int)
						: lexeme.Count < Int64MaxLength ? typeof(long) : typeof(ulong);
					this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme, integerType));
					return true;
				case NUMBER_NEGATIVE_INTEGER:
					var signedIntegerType = lexeme.Count < Int32MaxLength + 1 ? typeof(int) : typeof(long);
					this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme, signedIntegerType));
					return true;
				case NUMBER_FLOAT:
				case NUMBER_FLOAT_WITH_EXP:
					this.node = new ReaderNode(memberOrValueToken, this.Box(ref lexeme, typeof(double)));
					return true;
				default:
					System.Diagnostics.Debug.Assert(this.rawJson.Array != null, "rawJsonArray");
					throw ReaderException.UnknownNotation(this, new string(this.rawJson.Array, this.rawJson.Offset, this.rawJson.Count));
			}
		}

		private object Box(ref ArraySegment<char> lexeme, Type type = default)
		{
			var jsonValueBox = this.jsonValueBox ?? (this.jsonValueBox = new JsonValueBox());
			jsonValueBox.Store(lexeme, type ?? typeof(string));
			return jsonValueBox;
		}
		private object Box(int value)
		{
			var intBox = this.intBox ?? (this.intBox = new StrongBox<int>(CultureInfo.InvariantCulture));
			intBox.Store(value);
			return intBox;
		}
		private object Box(DateTime value)
		{
			var dateBox = this.dateBox ?? (this.dateBox = new StrongBox<DateTime>(CultureInfo.InvariantCulture));
			dateBox.Store(value);
			return dateBox;
		}
		private object Box(bool value)
		{
			if (value)
			{
				return this.trueBox ?? (this.trueBox = new StrongBox<bool>(true, CultureInfo.InvariantCulture));
			}
			return this.falseBox ?? (this.falseBox = new StrongBox<bool>(false, CultureInfo.InvariantCulture));
		}

		private static bool Match(ref ArraySegment<char> lexeme, ArraySegment<char>[] fragments, int offset, ArraySegment<char> matchTo)
		{
			var lexemeArray = lexeme.Array;
			System.Diagnostics.Debug.Assert(lexemeArray != null, "lexemeArray != null");

			var matchToArray = matchTo.Array;
			System.Diagnostics.Debug.Assert(matchToArray != null, "matchToArray != null");

			var count = matchTo.Count;
			if (fragments == null)
			{
				for (var i = 0; i < count; i++)
				{
					if (lexemeArray[lexeme.Offset + i] != matchToArray[matchTo.Offset + i])
						return false;
				}

				return true;
			}
			var mo = 0;
			foreach (var fg in fragments)
			{
				if (fg.Array == null) break;

				for (var i = 0; i < fg.Count; i++)
				{
					if (fg.Array[fg.Offset + i] != matchToArray[mo])
						return false;

					mo++;
				}
			}

			return true;
		}
		private static int GetNumberType(ref ArraySegment<char> lexeme)
		{
			const int INT_PART = 0;
			const int FRAC_PART = 1;
			const int EXP_PART = 2;
			const char POINT = '.';
			const char EXPONENT = 'E';
			const char EXPONENT_ALT = 'e';
			const char PLUS = '+';
			const char MINUS = '-';
			const char DIGIT_START = '0';
			const char DIGIT_END = '9';

			var isNegative = false;
			var buffer = lexeme.Array;
			var offset = lexeme.Offset;
			var count = lexeme.Offset + lexeme.Count;

			System.Diagnostics.Debug.Assert(buffer != null, "buffer != null");

			var part = INT_PART;

			for (var i = offset; i < count; i++)
			{
				var character = buffer[i];

				switch (part)
				{
					case INT_PART:
						switch (character)
						{
							case MINUS:
								if (i != offset)
								{
									return NUMBER_NOT;
								}
								isNegative = true;
								break;
							case PLUS:
								if (i != offset)
								{
									return NUMBER_NOT;
								}
								break;
							case POINT:
								if (i == offset)
								{
									return NUMBER_NOT; // decimal point as first character
								}
								part = FRAC_PART;
								break;
							default:
								if (character == EXPONENT || character == EXPONENT_ALT)
								{
									if (i == offset)
									{
										return NUMBER_NOT; // exponent at first character
									}
									part = EXP_PART;
								}
								else if (character < DIGIT_START && character > DIGIT_END)
								{
									return NUMBER_NOT; // non digit character in integer part
								}
								break;
						}
						break;
					case FRAC_PART:
						if (character == EXPONENT || character == EXPONENT_ALT)
						{
							if (i == offset)
							{
								return NUMBER_NOT; // exponent at first character
							}
							part = EXP_PART;
						}
						else if (character < DIGIT_START && character > DIGIT_END)
						{
							return NUMBER_NOT; // non digit character in fraction part
						}
						break;
					case EXP_PART:
						if (character == PLUS || character == MINUS)
						{
							if (buffer[i - 1] != EXPONENT && buffer[i - 1] != EXPONENT_ALT)
							{
								return NUMBER_NOT; // sign not at start of exponent part
							}
						}
						else if (character < DIGIT_START && character > DIGIT_END)
						{
							return NUMBER_NOT; // non digit character in integer part
						}
						break;
				}
			}

			switch (part)
			{
				case INT_PART: return isNegative ? NUMBER_NEGATIVE_INTEGER : NUMBER_INTEGER;
				case FRAC_PART: return NUMBER_FLOAT;
				case EXP_PART: return NUMBER_FLOAT_WITH_EXP;
				default: return NUMBER_NOT;
			}
		}
		private static ArraySegment<char> Copy(ref ArraySegment<char> lexeme)
		{
			var lexemeArray = lexeme.Array;

			var newLexemeArray = new char[lexeme.Count];
			var newLexeme = new ArraySegment<char>(newLexemeArray, 0, lexeme.Count);

			System.Diagnostics.Debug.Assert(lexemeArray != null, "lexemeArray != null");

			Buffer.BlockCopy(lexemeArray, lexeme.Offset * CHAR_SIZE, newLexemeArray, 0, lexeme.Count * CHAR_SIZE);
			return newLexeme;
		}
		private static bool IsWhiteSpaceLatin(char character)
		{
			return character == ' ' || character >= '\t' && character <= '\r' || (character == ' ' || character == '\x0085');
		}
		private ArraySegment<char> NextLexeme(ref int state)
		{
			this.ResetBufferIfNeeded();

			var buffer = this.buffer;
			var lexemeStartIndex = this.bufferOffset;
			var lexemeLength = 0;

			start:
			if (this.bufferAvailable == 0 && this.ReadToBuffer() == 0)
			{
				state = LEXER_STATE_COMPLETE;
				return new ArraySegment<char>(this.buffer, lexemeStartIndex, lexemeLength);
			}

			if (state == LEXER_STATE_COMPLETE)
				state = LEXER_STATE_START;

			var bufferEnd = this.bufferOffset + this.bufferAvailable;
			for (var i = this.bufferOffset; i < bufferEnd; i++)
			{
				this.colNum++;
				switch (state)
				{
					case LEXER_STATE_START:
						switch (buffer[i])
						{
							case JsonNotation.Newline: this.lineNum++; this.colNum = 1; goto case JsonNotation.Space;
							case JsonNotation.Space:
							case JsonNotation.Return:
							case JsonNotation.Tab:
							case JsonNotation.IdentifierSeparator:
								continue; // insignificant whitespaces
							case JsonNotation.ValueSeparator:
								if (this.structure.Peek() == ReaderToken.BeginObject) throw ReaderException.ReadingBrokenDocument(this, "A value is expected");

								continue;
							case JsonNotation.Comment:
								state = LEXER_STATE_COMMENT_BEGINNING;
								continue;
							case JsonNotation.EndArray:
							case JsonNotation.EndObject:
							case JsonNotation.BeginObject:
							case JsonNotation.BeginArray:
								state = LEXER_STATE_COMPLETE;
								this.bufferOffset = i + 1;
								this.bufferAvailable = bufferEnd - i - 1;
								return new ArraySegment<char>(buffer, i, 1);
							case JsonNotation.Quote:
								lexemeStartIndex = i;
								state = LEXER_STATE_QUOTED;
								continue;
							default:
								if (IsWhiteSpaceLatin(buffer[i]))
								{
									goto case JsonNotation.Space;
								}
								lexemeStartIndex = i;
								state = LEXER_STATE_LEXEME;
								continue;
						}
					case LEXER_STATE_LEXEME:
						switch (buffer[i])
						{
							// lexeme terminators
							case JsonNotation.Space:
							case JsonNotation.Newline:
							case JsonNotation.Return:
							case JsonNotation.Tab:
							case JsonNotation.IdentifierSeparator:
							case JsonNotation.ValueSeparator:
							case JsonNotation.EndArray:
							case JsonNotation.EndObject:
							case JsonNotation.BeginObject:
							case JsonNotation.BeginArray:
								state = LEXER_STATE_COMPLETE;
								this.bufferOffset = i;
								this.bufferAvailable = bufferEnd - i;
								return new ArraySegment<char>(buffer, lexemeStartIndex, i - lexemeStartIndex);
							default:
								if (IsWhiteSpaceLatin(buffer[i]))
								{
									goto case JsonNotation.Space;
								}
								continue;
						}
					case LEXER_STATE_QUOTED:
					case LEXER_STATE_QUOTED_ESCAPE:
						switch (buffer[i])
						{
							case JsonNotation.Newline:
							case JsonNotation.Return:
								throw ReaderException.UnterminatedStringLiteral(this);
							case JsonNotation.Quote:
								if (state == LEXER_STATE_QUOTED_ESCAPE)
								{
									state = LEXER_STATE_QUOTED;
									continue;
								}

								state = LEXER_STATE_COMPLETE;
								this.bufferOffset = i + 1;
								this.bufferAvailable = bufferEnd - i - 1;
								return new ArraySegment<char>(buffer, lexemeStartIndex, i - lexemeStartIndex + 1);
							case JsonNotation.Escape:
								state = LEXER_STATE_QUOTED_ESCAPE; // skips escaped quotes - \"
								continue;
							default:
								if (state == LEXER_STATE_QUOTED_ESCAPE)
								{
									state = LEXER_STATE_QUOTED;
								}
								continue;
						}
					case LEXER_STATE_COMMENT_BEGINNING:
						switch (buffer[i])
						{
							case JsonNotation.Comment:
								state = LEXER_STATE_COMMENT_SINGLE_LINE;
								continue;
							case JsonNotation.CommentMultiline:
								state = LEXER_STATE_COMMENT_MULTILINE;
								continue;
							default:
								throw ReaderException.UnknownNotation(this, JsonNotation.Comment + buffer[i].ToString());
						}
					case LEXER_STATE_COMMENT_SINGLE_LINE:
						switch (buffer[i])
						{
							case JsonNotation.Newline:
							case JsonNotation.Return:
								state = LEXER_STATE_START;
								continue;
							default: continue;
						}
					case LEXER_STATE_COMMENT_MULTILINE_ENDING:
					case LEXER_STATE_COMMENT_MULTILINE:
						switch (buffer[i])
						{
							case JsonNotation.CommentMultiline:
								state = LEXER_STATE_COMMENT_MULTILINE_ENDING;
								continue;
							case JsonNotation.Comment:
								if (state == LEXER_STATE_COMMENT_MULTILINE_ENDING)
									state = LEXER_STATE_START;
								continue;
							default: continue;
						}

				}
			}

			if (state == LEXER_STATE_START || state == LEXER_STATE_COMMENT_BEGINNING || state == LEXER_STATE_COMMENT_MULTILINE ||
				state == LEXER_STATE_COMMENT_MULTILINE_ENDING || state == LEXER_STATE_COMMENT_SINGLE_LINE)
			{
				// no lexemes found in current buffer
				this.bufferOffset = this.bufferAvailable = lexemeStartIndex = lexemeLength = 0;
				goto start; // restart
			}

			lexemeLength = bufferEnd - lexemeStartIndex;

			// buffer contains only fragment of lexeme
			// lexeme parsing is not complete so there is 2 options:
			// 1) try to fill buffer and retry parsing
			// 2) return fragment to caller

			if (lexemeLength < this.buffer.Length / 2)
			{
				// if fragment is small then move fragment to the start of the buffer and re-start parsing
				if (lexemeStartIndex != 0)
				{
					Buffer.BlockCopy(this.buffer, lexemeStartIndex * CHAR_SIZE, this.buffer, 0, lexemeLength * CHAR_SIZE);
					lexemeStartIndex = 0;
				}

				this.bufferOffset = lexemeLength;
				this.bufferAvailable = 0;

				goto start; // restart
			}
			else
			{
				// if fragment is huge then return it to caller

				// set buffer is consumed
				this.bufferOffset = this.bufferAvailable = 0;

				return new ArraySegment<char>(this.buffer, lexemeStartIndex, lexemeLength);
			}
		}
		private void ResetBufferIfNeeded()
		{
			if (this.bufferAvailable == 0)
			{
				this.bufferOffset = 0;
			}
		}
		private int ReadToBuffer()
		{
			if (this.bufferOffset + this.bufferAvailable >= this.buffer.Length)
			{
				throw new InvalidOperationException("Unable to read to buffer because there is not space available. This will cause zero read and erroneous 'End Of Stream' message.");
			}

			var offset = this.bufferOffset + this.bufferAvailable;
			var count = this.buffer.Length - offset;
			var read = this.textReader.Read(this.buffer, offset, count);
			this.bufferAvailable += read;
			return read;
		}

		public override void Dispose()
		{
			if (!this.leaveOpen)
			{
				this.textReader.Dispose();
			}
		}

		private sealed class JsonValueBox : IStrongBox
		{
			private ArraySegment<char> value;
			private Type valueType;

			public Type ValueType => this.valueType;

			public bool AsBoolean => Convert.ToBoolean(this.LoadString(), CultureInfo.InvariantCulture);
			public byte AsByte => checked((byte)this.LoadUInt32());
			public short AsInt16 => checked((short)this.LoadInt32());
			public int AsInt32 => this.LoadInt32();
			public long AsInt64 => this.LoadInt64();
			public sbyte AsSByte => checked((sbyte)this.LoadInt32());
			public ushort AsUInt16 => checked((ushort)this.LoadUInt32());
			public uint AsUInt32 => this.LoadUInt32();
			public ulong AsUInt64 => this.LoadUInt64();
			public float AsSingle => Convert.ToSingle(this.LoadString(), CultureInfo.InvariantCulture);
			public double AsDouble => Convert.ToDouble(this.LoadString(), CultureInfo.InvariantCulture);
			public decimal AsDecimal => Convert.ToDecimal(this.LoadString(), CultureInfo.InvariantCulture);
			public DateTimeOffset AsDateTimeOffset => DateTimeOffset.ParseExact(this.LoadString(), GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
			public DateTime AsDateTime => DateTime.ParseExact(this.LoadString(), GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
			public TimeSpan AsTimeSpan => TimeSpan.Parse(this.LoadString(), CultureInfo.InvariantCulture);
			public object AsObject => this.LoadString();

			private uint LoadUInt32()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToUInt32(array, offset, count);
			}
			private ulong LoadUInt64()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToUInt64(array, offset, count);
			}
			private int LoadInt32()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToInt32(array, offset, count);
			}
			private long LoadInt64()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.StringToInt64(array, offset, count);
			}
			private string LoadString()
			{
				var array = this.value.Array;
				var offset = this.value.Offset;
				var count = this.value.Count;

				System.Diagnostics.Debug.Assert(array != null, "array != null");

				if (array[offset] == JsonNotation.Quote && array[offset + count - 1] == JsonNotation.Quote) // quoted
				{
					offset++;
					count -= 2;
				}

				return JsonUtils.UnEscapeBuffer(array, offset, count, false);
			}

			public void Store<T>(T value)
			{
				this.value = (ArraySegment<char>)(object)value;
				this.valueType = typeof(string);
			}

			public void Store(ArraySegment<char> value, Type valueType)
			{
				if (valueType == null) throw new ArgumentNullException(nameof(valueType));

				this.value = value;
				this.valueType = valueType;
			}

			public override string ToString()
			{
				return this.LoadString();
			}
		}

		private static class JsonUtils
		{
			public static string UnEscapeBuffer(char[] charsToUnEscape, int offset, int count, bool strict)
			{
				if (charsToUnEscape == null) throw new ArgumentNullException(nameof(charsToUnEscape));
				if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
				if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
				if (offset + count > charsToUnEscape.Length) throw new ArgumentOutOfRangeException(nameof(offset));

				var unEscapedCount = GetUnEscapedCount(charsToUnEscape, offset, count);
				if (unEscapedCount == count)
				{
					return new string(charsToUnEscape, offset, count);
				}

				var resultBuilder = new StringBuilder(unEscapedCount);
				var plainStart = offset;
				var plainLen = 0;
				var end = offset + count;
				for (var i = offset; i < end; i++)
				{
					var ch = charsToUnEscape[i];
					if (ch != '\\')
					{
						plainLen++;
						continue;
					}

					if (i + 1 >= end)
					{
						if (strict)
						{
							throw ReaderException.UnknownEscapeSequence("\\\0", null);
						}
						else
						{
							plainLen++;
							break; // u
						}
					}

					var sequenceLength = 1;
					// append unencoded chunk
					if (plainLen != 0)
					{
						resultBuilder.Append(charsToUnEscape, plainStart, plainLen);
						plainLen = 0;
					}

					var sequenceKind = charsToUnEscape[i + 1];
					switch (sequenceKind)
					{
						case 'n':
							resultBuilder.Append('\n');
							break;
						case 'r':
							resultBuilder.Append('\r');
							break;
						case 'b':
							resultBuilder.Append('\b');
							break;
						case 'f':
							resultBuilder.Append('\f');
							break;
						case 't':
							resultBuilder.Append('\t');
							break;
						case '\\':
							resultBuilder.Append('\\');
							break;
						case '/':
							resultBuilder.Append('/');
							break;
						case '\'':
							resultBuilder.Append('\'');
							break;
						case '\"':
							resultBuilder.Append('\"');
							break;

						// unicode symbol
						case 'u':
							resultBuilder.Append((char)HexStringToUInt32(charsToUnEscape, i + 2, 4));
							sequenceLength = 5;
							break;

						// latin hex encoded symbol
						case 'x':
							resultBuilder.Append((char)HexStringToUInt32(charsToUnEscape, i + 2, 2));
							sequenceLength = 3;
							break;

						// latin dec encoded symbol
						case '1':
						case '2':
						case '3':
						case '4':
						case '5':
						case '6':
						case '7':
						case '8':
						case '9':
						case '0':
							resultBuilder.Append((char)StringToInt32(charsToUnEscape, i + 1, 3));
							sequenceLength = 3;
							break;
						default:
							if (!strict)
							{
								resultBuilder.Append(sequenceKind);
								break;
							}
							else
							{
								throw ReaderException.UnknownEscapeSequence("\\" + sequenceKind, null);
							}
					}

					// set next chunk start right after this escape
					plainStart = i + sequenceLength + 1;
					i += sequenceLength;
				}

				// append last unencoded chunk
				if (plainLen != 0)
				{
					resultBuilder.Append(charsToUnEscape, plainStart, plainLen);
				}

				return resultBuilder.ToString();
			}
			private static int GetUnEscapedCount(char[] charsToUnEscape, int offset, int count)
			{
				if (charsToUnEscape == null) throw new ArgumentNullException(nameof(charsToUnEscape));
				if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
				if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
				if (offset + count > charsToUnEscape.Length) throw new ArgumentOutOfRangeException(nameof(offset));

				var newCount = 0;
				var end = offset + count;
				for (var i = offset; i < end; i++)
				{
					var ch = charsToUnEscape[i];
					newCount++;
					if (ch != '\\')
					{
						continue;
					}

					var toSkip = 1;
					var sequenceKind = charsToUnEscape[i + 1];
					switch (sequenceKind)
					{
						// unicode symbol
						case 'u':
							toSkip = 5;
							break;

						// latin hex encoded symbol
						case 'x':
							toSkip = 3;
							break;
						// latin dec encoded symbol
						case '1':
						case '2':
						case '3':
						case '4':
						case '5':
						case '6':
						case '7':
						case '8':
						case '9':
						case '0':
							toSkip = 3;
							break;
						default:
							toSkip = 1;
							break;
					}
					i += toSkip;
				}
				return newCount;
			}

			public static uint HexStringToUInt32(char[] buffer, int offset, int count)
			{
				const uint ZERO = '0';
				const uint a = 'a';
				const uint A = 'A';

				var result = 0u;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					var d = 0u;
					if (c >= '0' && c <= '9')
						d = (c - ZERO);
					else if (c >= 'a' && c <= 'f')
						d = 10u + (c - a);
					else if (c >= 'A' && c <= 'F')
						d = 10u + (c - A);
					else
						throw new FormatException();

					result = 16u * result + d;
				}

				return result;
			}

			public static long StringToInt64(char[] buffer, int offset, int count)
			{
				const ulong ZERO = '0';

				var result = 0UL;
				var neg = false;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (i == 0 && c == '-')
					{
						neg = true;
						continue;
					}
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10UL * result + (c - ZERO));
				}

				if (neg)
					return -(long)(result);
				return (long)result;
			}
			public static int StringToInt32(char[] buffer, int offset, int count)
			{
				const uint ZERO = '0';

				var result = 0u;
				var neg = false;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (i == 0 && c == '-')
					{
						neg = true;
						continue;
					}
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10u * result + (c - ZERO));
				}

				if (neg)
					return -(int)(result);
				return (int)result;
			}
			public static ulong StringToUInt64(char[] buffer, int offset, int count)
			{
				const ulong ZERO = '0';

				var result = 0UL;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10UL * result + (c - ZERO));
				}

				return result;
			}
			public static uint StringToUInt32(char[] buffer, int offset, int count)
			{
				const uint ZERO = '0';

				var result = 0U;
				for (var i = 0; i < count; i++)
				{
					var c = buffer[offset + i];
					if (c < '0' || c > '9')
						throw new FormatException();

					result = checked(10 * result + (c - ZERO));
				}

				return result;
			}
		}

		private static class JsonNotation
		{
			public const char Tab = '\t';
			public const char Space = ' ';
			public const char Newline = '\n';
			public const char Return = '\r';
			public const char IdentifierSeparator = ':';
			public const char ValueSeparator = ',';
			public const char BeginArray = '[';
			public const char EndArray = ']';
			public const char BeginObject = '{';
			public const char EndObject = '}';
			public const char Escape = '\\';
			public const char Comment = '/';
			public const char CommentMultiline = '*';
			public const char Quote = '\"';
			public const char Const0 = '0';
			public const char Const1 = '1';
			public const char Const2 = '2';
			public const char Const3 = '3';
			public const char Const4 = '4';
			public const char Const5 = '5';
			public const char Const6 = '6';
			public const char Const7 = '7';
			public const char Const8 = '8';
			public const char Const9 = '9';
			public const string True = "true";
			public const string False = "false";
			public const string Null = "null";
		}
	}


	public sealed class MessagePackGameDataReader : GameDataReader
	{
		private const int DEFAULT_BUFFER_SIZE = ushort.MaxValue;
		private const int MAX_BINARY_LENGTH = 16 * 1024 * 1024;
		private const int MAX_STRING_LENGTH = 16 * 1024 * 1024;

		private struct Map
		{
			public ReaderToken Token;
			public long Counter;
		}

		private readonly Stream inputStream;
		private readonly bool leaveOpen;
		private readonly byte[] buffer;
		private readonly EndianBitConverter bitConverter;
		private readonly Stack<Map> maps;
		private ReaderNode node;
		private int bufferOffset;
		private int bufferRead;
		private int bufferAvailable;
		private int totalBytesRead;

		private StrongBox<int> int32Box;
		private StrongBox<uint> uInt32Box;
		private StrongBox<long> int64Box;
		private StrongBox<ulong> uInt64Box;
		private StrongBox<float> singleBox;
		private StrongBox<double> doubleBox;
		private StrongBox<decimal> decimalBox;
		private StrongBox<DateTime> dateBox;
		private StrongBox<DateTimeOffset> dateOffsetBox;
		private StrongBox<TimeSpan> timeSpanBox;
		private StrongBox<Guid> guidBox;
		private StrongBox<bool> trueBox;
		private StrongBox<bool> falseBox;

		public override int LineNumber => 0;
		public override int ColumnNumber => this.totalBytesRead;
		public override ReaderNode Node { get { if (this.node.Token == ReaderToken.None) this.NextToken(); return this.node; } }

		public MessagePackGameDataReader(Stream stream, bool leaveOpen = false, int bufferSize = DEFAULT_BUFFER_SIZE)
		{
			if (stream == null) throw new ArgumentNullException(nameof(stream));

			if (bufferSize < DEFAULT_BUFFER_SIZE)
				bufferSize = DEFAULT_BUFFER_SIZE;

			this.inputStream = stream;
			this.leaveOpen = leaveOpen;
			this.buffer = new byte[bufferSize];
			this.bufferOffset = 0;
			this.bufferRead = 0;
			this.bufferAvailable = 0;
			this.bitConverter = EndianBitConverter.Big;
			this.maps = new Stack<Map>();
		}

		public override bool NextToken()
		{
			if (this.maps.Count > 0 && this.maps.Peek().Counter == 0)
			{
				var closingToken = this.maps.Pop();
				this.node = new ReaderNode(closingToken.Token);

				this.DecrementClosingTokenCounter();
				return true;
			}

			if (!this.ReadToBuffer(1, throwOnEos: false))
			{
				this.node = new ReaderNode(ReaderToken.EndOfStream);
				return false;
			}

			var formatValue = this.buffer[this.bufferOffset];
			if (formatValue >= (byte)MessagePackType.FixArrayStart && formatValue <= (byte)MessagePackType.FixArrayEnd)
			{
				var arrayCount = formatValue - (byte)MessagePackType.FixArrayStart;

				this.maps.Push(new Map { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
				this.node = new ReaderNode(ReaderToken.BeginArray);
			}
			else if (formatValue >= (byte)MessagePackType.FixStrStart && formatValue <= (byte)MessagePackType.FixStrEnd)
			{
				var strCount = formatValue - (byte)MessagePackType.FixStrStart;
				var strBytes = this.ReadBytes(strCount);

				var token = ReaderToken.Value;
				if (this.maps.Count > 0)
				{
					var closingToken = this.maps.Peek();
					if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
						token = ReaderToken.Member;
				}

				var strValue = default(string);

				System.Diagnostics.Debug.Assert(strBytes.Array != null, "strBytes.Array != null");

				strValue = Encoding.UTF8.GetString(strBytes.Array, strBytes.Offset, strBytes.Count);

				this.node = new ReaderNode(token, strValue);
			}
			else if (formatValue >= (byte)MessagePackType.FixMapStart && formatValue <= (byte)MessagePackType.FixMapEnd)
			{
				var mapCount = formatValue - (byte)MessagePackType.FixMapStart;
				this.maps.Push(new Map { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
				this.node = new ReaderNode(ReaderToken.BeginObject);
			}
			else if (formatValue >= (byte)MessagePackType.NegativeFixIntStart)
			{
				this.node = new ReaderNode(ReaderToken.Value, this.Box(unchecked((sbyte)formatValue)));
			}
			else if (formatValue <= (byte)MessagePackType.PositiveFixIntEnd)
			{
				this.node = new ReaderNode(ReaderToken.Value, this.Box(formatValue));
			}
			else
			{
				switch ((MessagePackType)formatValue)
				{
					case MessagePackType.Nil:
						this.node = new ReaderNode(ReaderToken.Null);
						break;
					case MessagePackType.Array16:
					case MessagePackType.Array32:
						var arrayCount = 0L;
						if (formatValue == (int)MessagePackType.Array16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							arrayCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Array32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							arrayCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						if (arrayCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of array");

						this.maps.Push(new Map { Token = ReaderToken.EndOfArray, Counter = arrayCount + 1 });
						this.node = new ReaderNode(ReaderToken.BeginArray);
						break;
					case MessagePackType.Map16:
					case MessagePackType.Map32:
						var mapCount = 0L;
						if (formatValue == (int)MessagePackType.Map16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							mapCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Map32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							mapCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						if (mapCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of map");

						this.maps.Push(new Map { Token = ReaderToken.EndOfObject, Counter = mapCount * 2 + 1 });
						this.node = new ReaderNode(ReaderToken.BeginObject);
						break;
					case MessagePackType.Str16:
					case MessagePackType.Str32:
					case MessagePackType.Str8:
						var strBytesCount = 0L;
						if (formatValue == (int)MessagePackType.Str8)
						{
							this.ReadToBuffer(1, throwOnEos: true);
							strBytesCount = this.buffer[this.bufferOffset];
						}
						else if (formatValue == (int)MessagePackType.Str16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							strBytesCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Str32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							strBytesCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						var token = ReaderToken.Value;
						if (this.maps.Count > 0)
						{
							var closingToken = this.maps.Peek();
							if (closingToken.Token == ReaderToken.EndOfObject && closingToken.Counter > 0 && closingToken.Counter % 2 == 0)
								token = ReaderToken.Member;
						}

						if (strBytesCount > MAX_STRING_LENGTH) throw ReaderException.StringLiteralIsTooLong(this, (int)strBytesCount, MAX_STRING_LENGTH);

						var strBytes = this.ReadBytes(strBytesCount);
						System.Diagnostics.Debug.Assert(strBytes.Array != null, "strBytes.Array != null");
						var stringValue = Encoding.UTF8.GetString(strBytes.Array, strBytes.Offset, strBytes.Count);
						this.node = new ReaderNode(token, stringValue);
						break;
					case MessagePackType.Bin32:
					case MessagePackType.Bin16:
					case MessagePackType.Bin8:
						var bytesCount = 0L;
						if (formatValue == (int)MessagePackType.Bin8)
						{
							this.ReadToBuffer(1, throwOnEos: true);
							bytesCount = this.buffer[this.bufferOffset];
						}
						else if (formatValue == (int)MessagePackType.Bin16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							bytesCount = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Bin32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							bytesCount = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						if (bytesCount > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, (int)bytesCount, MAX_BINARY_LENGTH);
						if (bytesCount < 0) throw ReaderException.ReadingBrokenDocument(this, "negative size of binary data");

						var bytes = this.ReadBytes(bytesCount, forceNewBuffer: true);
						System.Diagnostics.Debug.Assert(bytes.Array != null, "bytes.Array != null");
						this.node = new ReaderNode(ReaderToken.Value, bytes.Array);
						break;
					case MessagePackType.FixExt1:
					case MessagePackType.FixExt16:
					case MessagePackType.FixExt2:
					case MessagePackType.FixExt4:
					case MessagePackType.FixExt8:
					case MessagePackType.Ext32:
					case MessagePackType.Ext16:
					case MessagePackType.Ext8:
						var extLength = 0L;
						if (formatValue == (int)MessagePackType.FixExt1)
							extLength = 1;
						else if (formatValue == (int)MessagePackType.FixExt2)
							extLength = 2;
						else if (formatValue == (int)MessagePackType.FixExt4)
							extLength = 4;
						else if (formatValue == (int)MessagePackType.FixExt8)
							extLength = 8;
						else if (formatValue == (int)MessagePackType.FixExt16)
							extLength = 16;
						if (formatValue == (int)MessagePackType.Ext8)
						{
							this.ReadToBuffer(1, throwOnEos: true);
							extLength = this.buffer[this.bufferOffset];
						}
						else if (formatValue == (int)MessagePackType.Ext16)
						{
							this.ReadToBuffer(2, throwOnEos: true);
							extLength = this.bitConverter.ToUInt16(this.buffer, this.bufferOffset);
						}
						else if (formatValue == (int)MessagePackType.Ext32)
						{
							this.ReadToBuffer(4, throwOnEos: true);
							extLength = this.bitConverter.ToUInt32(this.buffer, this.bufferOffset);
						}

						this.ReadToBuffer(1, throwOnEos: true);
						var extType = this.buffer[this.bufferOffset];

						if (extLength > MAX_BINARY_LENGTH) throw ReaderException.BinaryDataIsTooLong(this, (int)extLength, MAX_BINARY_LENGTH);

						var data = this.ReadBytes(extLength, forceNewBuffer: true);
						System.Diagnostics.Debug.Assert(data.Array != null, "data.Array != null");
						if (!this.TryReadExtType(extType, data, out this.node))
							this.node = new ReaderNode(ReaderToken.Value, data.Array);
						break;
					case MessagePackType.False:
						this.node = new ReaderNode(ReaderToken.Value, this.Box(false));
						break;
					case MessagePackType.True:
						this.node = new ReaderNode(ReaderToken.Value, this.Box(true));
						break;
					case MessagePackType.Float32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToSingle(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Float64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToDouble(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int16:
						this.ReadToBuffer(2, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToInt16(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToInt32(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToInt64(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.Int8:
						this.ReadToBuffer(1, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(unchecked((sbyte)this.buffer[this.bufferOffset])));
						break;
					case MessagePackType.UInt16:
						this.ReadToBuffer(2, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box((uint)this.bitConverter.ToUInt16(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.UInt32:
						this.ReadToBuffer(4, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToUInt32(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.UInt64:
						this.ReadToBuffer(8, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box(this.bitConverter.ToUInt64(this.buffer, this.bufferOffset)));
						break;
					case MessagePackType.UInt8:
						this.ReadToBuffer(1, throwOnEos: true);
						this.node = new ReaderNode(ReaderToken.Value, this.Box((uint)this.buffer[this.bufferOffset]));
						break;
					case MessagePackType.PositiveFixIntStart:
					case MessagePackType.PositiveFixIntEnd:
					case MessagePackType.FixMapStart:
					case MessagePackType.FixMapEnd:
					case MessagePackType.FixArrayStart:
					case MessagePackType.FixArrayEnd:
					case MessagePackType.FixStrStart:
					case MessagePackType.FixStrEnd:
					case MessagePackType.Unused:
					case MessagePackType.NegativeFixIntStart:
					case MessagePackType.NegativeFixIntEnd:
					default: throw ReaderException.UnknownMessagePackType(((MessagePackType)formatValue).ToString(), this);
				}
			}

			this.DecrementClosingTokenCounter();

			return true;
		}

		private bool ReadToBuffer(int bytesRequired, bool throwOnEos)
		{
			this.bufferAvailable -= this.bufferRead;
			this.bufferOffset += this.bufferRead;
			this.bufferRead = 0;

			if (this.bufferAvailable < bytesRequired)
			{
				if (this.bufferAvailable > 0)
					Buffer.BlockCopy(this.buffer, this.bufferOffset, this.buffer, 0, this.bufferAvailable);

				this.bufferOffset = 0;
				while (this.bufferAvailable < bytesRequired)
				{
					var read = this.inputStream.Read(this.buffer, this.bufferAvailable, this.buffer.Length - this.bufferAvailable);
					this.bufferAvailable += read;

					if (read != 0 || this.bufferAvailable >= bytesRequired)
						continue;

					if (throwOnEos)
						throw ReaderException.UnexpectedEndOfStream(this);

					return false;
				}
			}

			this.bufferRead = bytesRequired;
			this.totalBytesRead += bytesRequired;
			return true;
		}
		private ArraySegment<byte> ReadBytes(long bytesRequired, bool forceNewBuffer = false)
		{
			if (bytesRequired > int.MaxValue) throw new ArgumentOutOfRangeException(nameof(bytesRequired));

			this.bufferAvailable -= this.bufferRead;
			this.bufferOffset += this.bufferRead;
			this.bufferRead = 0;

			if (this.bufferAvailable >= bytesRequired && !forceNewBuffer)
			{
				var bytes = new ArraySegment<byte>(this.buffer, this.bufferOffset, (int)bytesRequired);

				this.bufferAvailable -= (int)bytesRequired;
				this.bufferOffset += (int)bytesRequired;
				this.totalBytesRead += (int)bytesRequired;

				return bytes;
			}
			else
			{
				var bytes = new byte[bytesRequired];
				var bytesOffset = 0;
				if (this.bufferAvailable > 0 && bytesOffset < bytes.Length)
				{
					var bytesToCopy = Math.Min(bytes.Length, this.bufferAvailable);
					Buffer.BlockCopy(this.buffer, this.bufferOffset, bytes, bytesOffset, bytesToCopy);

					bytesOffset += bytesToCopy;
					this.bufferOffset += bytesToCopy;

					this.bufferAvailable -= bytesToCopy;
					this.totalBytesRead += bytesToCopy;
				}

				if (this.bufferAvailable == 0)
					this.bufferOffset = 0;

				while (bytesOffset < bytes.Length)
				{
					var read = this.inputStream.Read(bytes, bytesOffset, bytes.Length - bytesOffset);

					bytesOffset += read;
					this.totalBytesRead += read;

					if (read == 0 && bytesOffset < bytes.Length)
						throw ReaderException.UnexpectedEndOfStream(this);
				}

				return new ArraySegment<byte>(bytes, 0, bytes.Length);
			}
		}
		private bool TryReadExtType(byte extType, ArraySegment<byte> data, out ReaderNode node)
		{
			const byte EXTENSION_TYPE_TIMESTAMP = 255;
			const byte EXTENSION_TYPE_DATE_TIME = 40;
			const byte EXTENSION_TYPE_DATE_TIME_OFFSET = 41;
			const byte EXTENSION_TYPE_DECIMAL = 42;
			const byte EXTENSION_TYPE_GUID = 43;
			const byte GUID_SIZE = 16;
			const byte DECIMAL_SIZE = 16;
			const byte DATE_TIME_SIZE = 16;
			const byte DATE_TIME_OFFSET_SIZE = 16;

			node = default;
			switch (extType)
			{
				case EXTENSION_TYPE_TIMESTAMP:
					unchecked
					{
						var seconds = 0L;
						var nanoSeconds = 0u;
						switch (data.Count)
						{
							case 4:
								seconds = this.bitConverter.ToInt32(data.Array, data.Offset);
								break;
							case 8:
								var data64 = this.bitConverter.ToUInt64(data.Array, data.Offset);
								seconds = (int)(data64 & 0x00000003ffffffffL);
								nanoSeconds = (uint)(data64 >> 34 & uint.MaxValue);
								break;
							case 12:
								nanoSeconds = this.bitConverter.ToUInt32(data.Array, data.Offset);
								seconds = this.bitConverter.ToInt64(data.Array, data.Offset + 4);
								break;
							default:
								return false;
						}
						node = new ReaderNode(ReaderToken.Value, this.Box(TimeSpan.FromSeconds(seconds).Add(TimeSpan.FromTicks(nanoSeconds / 100))));
						return true;
					}
				case EXTENSION_TYPE_DATE_TIME:
					if (data.Count != DATE_TIME_SIZE)
						return false;
					System.Diagnostics.Debug.Assert(data.Array != null, "data.Array != null");
					var dateTime = new DateTime(this.bitConverter.ToInt64(data.Array, data.Offset + 1), (DateTimeKind)data.Array[data.Offset]);
					node = new ReaderNode(ReaderToken.Value, this.Box(dateTime));
					return true;
				case EXTENSION_TYPE_DATE_TIME_OFFSET:
					if (data.Count != DATE_TIME_OFFSET_SIZE)
						return false;
					var offset = new TimeSpan(this.bitConverter.ToInt64(data.Array, data.Offset + 8));
					var ticks = this.bitConverter.ToInt64(data.Array, data.Offset);
					var dateTimeOffset = new DateTimeOffset(ticks, offset);
					node = new ReaderNode(ReaderToken.Value, this.Box(dateTimeOffset));
					return true;
				case EXTENSION_TYPE_DECIMAL:
					if (data.Count != DECIMAL_SIZE)
						return false;
					var decimalValue = this.bitConverter.ToDecimal(data.Array, data.Offset);
					node = new ReaderNode(ReaderToken.Value, this.Box(decimalValue));
					return true;
				case EXTENSION_TYPE_GUID:
					if (data.Count != GUID_SIZE)
						return false;

					var buffer = data.Array;
					System.Diagnostics.Debug.Assert(buffer != null, "buffer != null");
					unchecked
					{
						var guidValue = new Guid
						(
								(uint)(buffer[data.Offset + 3] << 24 | buffer[data.Offset + 2] << 16 | buffer[data.Offset + 1] << 8 | buffer[data.Offset + 0]),
								(ushort)(buffer[data.Offset + 5] << 8 | buffer[data.Offset + 4]),
								(ushort)(buffer[data.Offset + 7] << 8 | buffer[data.Offset + 6]),
								buffer[data.Offset + 8],
								buffer[data.Offset + 9],
								buffer[data.Offset + 10],
								buffer[data.Offset + 11],
								buffer[data.Offset + 12],
								buffer[data.Offset + 13],
								buffer[data.Offset + 14],
								buffer[data.Offset + 15]
						);

						node = new ReaderNode(ReaderToken.Value, this.Box(guidValue));
						return true;
					}
				default:
					return false;
			}
		}

		private object Box(int value)
		{
			var int32Box = this.int32Box ?? (this.int32Box = new StrongBox<int>(CultureInfo.InvariantCulture));
			int32Box.Store(value);
			return int32Box;
		}
		private object Box(uint value)
		{
			var uInt32Box = this.uInt32Box ?? (this.uInt32Box = new StrongBox<uint>(CultureInfo.InvariantCulture));
			uInt32Box.Store(value);
			return uInt32Box;
		}
		private object Box(long value)
		{
			var int64Box = this.int64Box ?? (this.int64Box = new StrongBox<Int64>(CultureInfo.InvariantCulture));
			int64Box.Store(value);
			return int64Box;
		}
		private object Box(ulong value)
		{
			var uInt64Box = this.uInt64Box ?? (this.uInt64Box = new StrongBox<UInt64>(CultureInfo.InvariantCulture));
			uInt64Box.Store(value);
			return uInt64Box;
		}
		private object Box(float value)
		{
			var singleBox = this.singleBox ?? (this.singleBox = new StrongBox<float>(CultureInfo.InvariantCulture));
			singleBox.Store(value);
			return singleBox;
		}
		private object Box(double value)
		{
			var doubleBox = this.doubleBox ?? (this.doubleBox = new StrongBox<double>(CultureInfo.InvariantCulture));
			doubleBox.Store(value);
			return doubleBox;
		}
		private object Box(decimal value)
		{
			var decimalBox = this.decimalBox ?? (this.decimalBox = new StrongBox<decimal>(CultureInfo.InvariantCulture));
			decimalBox.Store(value);
			return decimalBox;
		}
		private object Box(DateTime value)
		{
			var dateBox = this.dateBox ?? (this.dateBox = new StrongBox<DateTime>(CultureInfo.InvariantCulture));
			dateBox.Store(value);
			return dateBox;
		}
		private object Box(DateTimeOffset value)
		{
			var dateOffsetBox = this.dateOffsetBox ?? (this.dateOffsetBox = new StrongBox<DateTimeOffset>(CultureInfo.InvariantCulture));
			dateOffsetBox.Store(value);
			return dateOffsetBox;
		}
		private object Box(TimeSpan value)
		{
			var timeSpanBox = this.timeSpanBox ?? (this.timeSpanBox = new StrongBox<TimeSpan>(CultureInfo.InvariantCulture));
			timeSpanBox.Store(value);
			return timeSpanBox;
		}
		private object Box(Guid value)
		{
			var guidBox = this.guidBox ?? (this.guidBox = new StrongBox<Guid>(CultureInfo.InvariantCulture));
			guidBox.Store(value);
			return guidBox;
		}
		private object Box(bool value)
		{
			if (value)
			{
				return this.trueBox ?? (this.trueBox = new StrongBox<bool>(true, CultureInfo.InvariantCulture));
			}
			return this.falseBox ?? (this.falseBox = new StrongBox<bool>(false, CultureInfo.InvariantCulture));
		}

		private void DecrementClosingTokenCounter()
		{
			if (this.maps.Count > 0)
			{
				var closingToken = this.maps.Pop();
				closingToken.Counter--;
				this.maps.Push(closingToken);
			}
		}

		public override void Dispose()
		{
			if (!this.leaveOpen)
			{
				this.inputStream.Dispose();
			}
		}


		private enum MessagePackType : byte
		{
			PositiveFixIntStart = 0x00,
			PositiveFixIntEnd = 0x7f,
			FixMapStart = 0x80,
			FixMapEnd = 0x8f,
			FixArrayStart = 0x90,
			FixArrayEnd = 0x9f,
			FixStrStart = 0xa0,
			FixStrEnd = 0xbf,
			Nil = 0xc0,
			Unused = 0xc1,
			False = 0xc2,
			True = 0xc3,
			Bin8 = 0xc4,
			Bin16 = 0xc5,
			Bin32 = 0xc6,
			Ext8 = 0xc7,
			Ext16 = 0xc8,
			Ext32 = 0xc9,
			Float32 = 0xca,
			Float64 = 0xcb,
			UInt8 = 0xcc,
			UInt16 = 0xcd,
			UInt32 = 0xce,
			UInt64 = 0xcf,
			Int8 = 0xd0,
			Int16 = 0xd1,
			Int32 = 0xd2,
			Int64 = 0xd3,
			FixExt1 = 0xd4,
			FixExt2 = 0xd5,
			FixExt4 = 0xd6,
			FixExt8 = 0xd7,
			FixExt16 = 0xd8,
			Str8 = 0xd9,
			Str16 = 0xda,
			Str32 = 0xdb,
			Array16 = 0xdc,
			Array32 = 0xdd,
			Map16 = 0xde,
			Map32 = 0xdf,
			NegativeFixIntStart = 0xe0,
			NegativeFixIntEnd = 0xff
		}

		private enum MessagePackExtentionType : byte
		{
			None = 0,
			DateTime = 40,
			DateTimeOffset = 41,
			Decimal = 42
		}
	}


	[Serializable]
	public class ReaderException : SerializationException
	{
		public int Code { get; set; }
		public int LineNumber { get; set; }
		public int ColumnNumber { get; set; }

		private ReaderException(string message, GameDataReader gameDataReader)
			: base(message)
		{
			if (message == null) throw new ArgumentNullException(nameof(message));

			if (gameDataReader != null)
				this.Update(gameDataReader);
		}

		protected ReaderException(SerializationInfo info, StreamingContext context)
			: base(info, context)
		{
			if (info == null) throw new ArgumentNullException(nameof(info));

			this.LineNumber = info.GetInt32("LineNumber");
			this.ColumnNumber = info.GetInt32("ColumnNumber");
		}

		private void Update(GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			this.LineNumber = gameDataReader.LineNumber;
			this.ColumnNumber = gameDataReader.ColumnNumber;
		}

		public override void GetObjectData(SerializationInfo info, StreamingContext context)
		{
			if (info == null) throw new ArgumentNullException(nameof(info));

			info.AddValue("Code", this.Code);
			info.AddValue("LineNumber", this.LineNumber);
			info.AddValue("ColumnNumber", this.ColumnNumber);

			base.GetObjectData(info, context);
		}

		public static Exception UnexpectedEndOfStream(GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException("Unexpected end of stream.", gameDataReader);
		}
		public static Exception UnexpectedToken(GameDataReader gameDataReader, params ReaderToken[] expectedTokens)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));
			if (expectedTokens == null) throw new ArgumentNullException(nameof(expectedTokens));

			var tokensStr = default(string);
			if (expectedTokens.Length == 0)
			{
				tokensStr = "<no tokens>";
			}
			else
			{
				var tokens = Array.ConvertAll(expectedTokens, c => c.ToString());
				tokensStr = String.Join(", ", tokens);
			}

			return new ReaderException($"Expected one of there '{tokensStr}' but found '{gameDataReader.Node.Token}'({gameDataReader.Node.ValueType?.Name ?? "<null>"}).",
				gameDataReader);
		}
		public static Exception UnknownEscapeSequence(string escape, GameDataReader gameDataReader)
		{
			if (escape == null) throw new ArgumentNullException(nameof(escape));
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"An unknown escape sequence '{escape}'.", gameDataReader);
		}
		public static Exception UnterminatedStringLiteral(GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException("An unterminated string literal.", gameDataReader);
		}
		public static Exception UnknownNotation(GameDataReader gameDataReader, string notation)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"An unknown notation '{notation}'.", gameDataReader);
		}
		public static Exception StringLiteralIsTooLong(GameDataReader gameDataReader, int size, int maxSize)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"String literal is too long '{size}'. Maximum size is {maxSize}.", gameDataReader);
		}
		public static Exception BinaryDataIsTooLong(GameDataReader gameDataReader, int size, int maxSize)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"Binary data is too long '{size}'. Maximum size is {maxSize}.", gameDataReader);
		}
		public static Exception ReadingBrokenDocument(GameDataReader gameDataReader, string additionalInformation)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"Failed to continue deserialize because document's structure is invalid. Additional information: {additionalInformation}", gameDataReader);
		}
		public static Exception UnknownMessagePackType(string type, GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"An unknown Message Pack type '{type}'.", gameDataReader);
		}
		public static Exception UnexpectedNullValue(string expected, string propertyName, string schemaName, GameDataReader gameDataReader)
		{
			if (gameDataReader == null) throw new ArgumentNullException(nameof(gameDataReader));

			return new ReaderException($"A null value is deserialized instead of {expected} for required property '{propertyName}' in schema '{schemaName}'.",
				gameDataReader);
		}
	}


	public readonly struct ReaderNode
	{
		private readonly object value;

		public readonly ReaderToken Token;
		public readonly Type ValueType;

		public bool HasValue => this.ValueType != typeof(void);

		public ReaderNode(ReaderToken token)
		{
			this.Token = token;
			this.value = null;
			this.ValueType = typeof(void);
		}
		public ReaderNode(ReaderToken token, object value)
		{
			if (value == null) throw new ArgumentNullException(nameof(value));

			this.Token = token;
			this.value = value;
			this.ValueType = value is IStrongBox box ? box.ValueType : value.GetType();
		}

		public bool AsBoolean
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsBoolean;

				return Convert.ToBoolean(this.value, CultureInfo.InvariantCulture);
			}
		}
		public byte AsByte
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsByte;

				return Convert.ToByte(this.value, CultureInfo.InvariantCulture);
			}
		}
		public short AsInt16
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsInt16;

				return Convert.ToInt16(this.value, CultureInfo.InvariantCulture);
			}
		}
		public int AsInt32
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsInt32;

				return Convert.ToInt32(this.value, CultureInfo.InvariantCulture);
			}
		}
		public long AsInt64
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsInt64;

				return Convert.ToInt64(this.value, CultureInfo.InvariantCulture);
			}
		}
		public sbyte AsSByte
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsSByte;

				return Convert.ToSByte(this.value, CultureInfo.InvariantCulture);
			}
		}
		public ushort AsUInt16
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsUInt16;

				return Convert.ToUInt16(this.value, CultureInfo.InvariantCulture);
			}
		}
		public uint AsUInt32
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsUInt32;

				return Convert.ToUInt32(this.value, CultureInfo.InvariantCulture);
			}
		}
		public ulong AsUInt64
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsUInt64;

				return Convert.ToUInt64(this.value, CultureInfo.InvariantCulture);
			}
		}
		public float AsSingle
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsSingle;

				return Convert.ToSingle(this.value, CultureInfo.InvariantCulture);
			}
		}
		public double AsDouble
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDouble;

				return Convert.ToDouble(this.value, CultureInfo.InvariantCulture);
			}
		}
		public decimal AsDecimal
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDecimal;

				return Convert.ToDecimal(this.value, CultureInfo.InvariantCulture);
			}
		}
		public string AsString
		{
			get
			{
				var value = this.value;
				if (this.value is IStrongBox box) value = box.AsObject;
				return Convert.ToString(value, CultureInfo.InvariantCulture);
			}
		}
		public DateTime AsDateTime
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDateTime;

				var dateTimeStr = this.AsString;
				var date = DateTime.ParseExact(dateTimeStr, GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
				return date;
			}
		}
		public DateTimeOffset AsDateTimeOffset
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsDateTime;

				var dateTimeStr = this.AsString;
				var date = DateTimeOffset.ParseExact(dateTimeStr, GameDataReader.DateTimeFormats, CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind | DateTimeStyles.AssumeUniversal);
				return date;
			}
		}
		public TimeSpan AsTimeSpan
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsTimeSpan;

				var timeSpanStr = this.AsString;
				var timeSpan = TimeSpan.Parse(timeSpanStr);
				return timeSpan;
			}
		}
		public object AsObject
		{
			get
			{
				if (this.value is IStrongBox box) return box.AsObject;

				return this.value;
			}
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "{0}:{1}", this.Token, this.value);
		}
	}


	public enum ReaderToken
	{
		None = 0,
		BeginArray,
		EndOfArray,
		BeginObject,
		EndOfObject,
		Member,
		Null,
		Value,
		Comment,
		EndOfStream
	}


	public sealed class StringLookupTable
	{
		public const int MAX_STRING_SIZE = 8 * 8;

		private readonly StringSet[] table;

		public StringLookupTable(StringSet[] table)
		{
			if (table == null) throw new ArgumentNullException(nameof(table));

			this.table = table;
			Array.Resize(ref this.table, MAX_STRING_SIZE + 1);
		}

		public bool TryGetString(byte[] bytes, int offset, int count, out string value)
		{
			const int LAST_ASCII_CHARACTER = 0x7f;

			if (bytes == null)
			{
				throw new ArgumentNullException(nameof(bytes));
			}

			if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
			if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
			if (offset + count > bytes.Length) throw new ArgumentOutOfRangeException(nameof(offset));

			if (count == 0)
			{
				value = string.Empty;
				return true;
			}

			value = null;
			if (count > MAX_STRING_SIZE || this.table[count] == null)
			{
				return false;
			}

			var end = offset + count;
			var octet = 0UL;
			for (var i = 0; offset + i < end; i++)
			{
				var character = bytes[offset + i];
				if (character > LAST_ASCII_CHARACTER)
				{
					return false;
				}

				if (i < 8)
				{
					octet = unchecked(octet | ((ulong)character << 8 * i));
				}
			}

			var set = this.table[count];
			var narrowOffset = 1;
			for (var i = 0; i < (count - 1) / 8; i++, narrowOffset++)
			{
				if (set == null || !set.TryNarrow(octet, out set))
				{
					return false;
				}

				octet = GetUInt64(bytes, offset + narrowOffset * 8, end);
			}

			return set != null && set.TryGetValue(octet, out value);
		}
		public bool TryGetString(char[] chars, int offset, int count, out string value)
		{
			const int LAST_ASCII_CHARACTER = 0x7f;

			if (chars == null)
			{
				throw new ArgumentNullException(nameof(chars));
			}

			if (count < 0) throw new ArgumentOutOfRangeException(nameof(count));
			if (offset < 0) throw new ArgumentOutOfRangeException(nameof(offset));
			if (offset + count > chars.Length) throw new ArgumentOutOfRangeException(nameof(offset));

			if (count == 0)
			{
				value = string.Empty;
				return true;
			}

			value = null;
			if (count > MAX_STRING_SIZE || this.table[count] == null)
			{
				return false;
			}

			var end = offset + count;
			var octet = 0UL;
			for (var i = 0; offset + i < end; i++)
			{
				var character = chars[offset + i];
				if (character > LAST_ASCII_CHARACTER)
				{
					return false;
				}

				if (i < 8)
				{
					octet = unchecked(octet | ((ulong)character << 8 * i));
				}
			}

			var set = this.table[count];
			var narrowOffset = 1;
			for (var i = 0; i < (count - 1) / 8; i++, narrowOffset++)
			{
				if (set == null || !set.TryNarrow(octet, out set))
				{
					return false;
				}

				octet = GetUInt64(chars, offset + narrowOffset * 8, end);
			}

			return set != null && set.TryGetValue(octet, out value);
		}

		private static ulong GetUInt64(byte[] bytes, int offset, int end)
		{
			if (offset >= end)
			{
				return 0;
			}

			switch (end - offset)
			{
				case 1: return (ulong)bytes[offset];
				case 2:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1;
				case 3:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2;
				case 4:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3;
				case 5:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4;
				case 6:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4 |
						(ulong)bytes[offset + 5] << 8 * 5;
				case 7:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4 |
						(ulong)bytes[offset + 5] << 8 * 5 |
						(ulong)bytes[offset + 6] << 8 * 6;
				default:
					return (ulong)bytes[offset] |
						(ulong)bytes[offset + 1] << 8 * 1 |
						(ulong)bytes[offset + 2] << 8 * 2 |
						(ulong)bytes[offset + 3] << 8 * 3 |
						(ulong)bytes[offset + 4] << 8 * 4 |
						(ulong)bytes[offset + 5] << 8 * 5 |
						(ulong)bytes[offset + 6] << 8 * 6 |
						(ulong)bytes[offset + 7] << 8 * 7;
			}
		}
		private static ulong GetUInt64(char[] chars, int offset, int end)
		{
			if (offset >= end)
			{
				return 0;
			}

			switch (end - offset)
			{
				case 1: return (ulong)chars[offset];
				case 2:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1;
				case 3:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2;
				case 4:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3;
				case 5:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4;
				case 6:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4 |
						(ulong)chars[offset + 5] << 8 * 5;
				case 7:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4 |
						(ulong)chars[offset + 5] << 8 * 5 |
						(ulong)chars[offset + 6] << 8 * 6;
				default:
					return (ulong)chars[offset] |
						(ulong)chars[offset + 1] << 8 * 1 |
						(ulong)chars[offset + 2] << 8 * 2 |
						(ulong)chars[offset + 3] << 8 * 3 |
						(ulong)chars[offset + 4] << 8 * 4 |
						(ulong)chars[offset + 5] << 8 * 5 |
						(ulong)chars[offset + 6] << 8 * 6 |
						(ulong)chars[offset + 7] << 8 * 7;
			}
		}
	}


	public sealed class StringSet
	{
		public static readonly Comparer<ulong> KeyComparer = Comparer<ulong>.Default;

		private readonly ulong[] keys;
		private readonly StringSet[] subSets;
		private readonly string[] values;

		public StringSet(ulong[] keys, StringSet[] subSets)
		{
			if (keys == null) throw new ArgumentNullException(nameof(keys));
			if (subSets == null) throw new ArgumentNullException(nameof(subSets));
			if (subSets.Length != keys.Length) throw new ArgumentException("invalid sets", nameof(keys));

			this.keys = keys;
			this.subSets = subSets;
		}
		public StringSet(ulong[] keys, string[] values)
		{
			if (keys == null) throw new ArgumentNullException(nameof(keys));
			if (values == null) throw new ArgumentNullException(nameof(values));
			if (values.Length != keys.Length) throw new ArgumentException("invalid sets", nameof(keys));

			this.keys = keys;
			this.values = values;
		}

		public bool TryNarrow(ulong octet, out StringSet value)
		{
			var subSetIndex = 0;
			switch (this.keys.Length)
			{
				case 1:
					subSetIndex = this.keys[0] == octet ? 0 : -1;
					break;
				case 2:
					subSetIndex = this.keys[0] == octet ? 0 : this.keys[1] == octet ? 1 : -1;
					break;
				case 3:
				case 4:
				case 5:
					subSetIndex = Array.IndexOf(this.keys, octet, 0, this.keys.Length);
					break;
				default:
					subSetIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, octet, KeyComparer);
					break;
			}

			if (subSetIndex < 0)
			{
				value = null;
				return false;
			}

			value = this.subSets[subSetIndex];
			return true;
		}
		public bool TryGetValue(ulong octet, out string value)
		{
			var valueIndex = 0;
			switch (this.keys.Length)
			{
				case 1:
					valueIndex = this.keys[0] == octet ? 0 : -1;
					break;
				case 2:
					valueIndex = this.keys[0] == octet ? 0 : this.keys[1] == octet ? 1 : -1;
					break;
				case 3:
				case 4:
				case 5:
					valueIndex = Array.IndexOf(this.keys, octet, 0, this.keys.Length);
					break;
				default:
					valueIndex = Array.BinarySearch(this.keys, 0, this.keys.Length, octet, KeyComparer);
					break;
			}

			if (valueIndex < 0)
			{
				value = null;
				return false;
			}

			value = this.values[valueIndex];
			return value != null;
		}
	}


	public sealed class StrongBox<ValueT> : IStrongBox
	{
		private static readonly Type ValueType = typeof(ValueT);

		private readonly IFormatProvider formatProvider;

		public ValueT Value;

		public StrongBox(ValueT value, IFormatProvider formatProvider)
			: this(formatProvider)
		{
			this.Value = value;
		}
		public StrongBox(IFormatProvider formatProvider)
		{
			if (formatProvider == null) throw new ArgumentNullException(nameof(formatProvider));

			this.formatProvider = formatProvider;
		}

		Type IStrongBox.ValueType => ValueType;
		public bool AsBoolean => this.Value is bool asBoolean ? asBoolean : Convert.ToBoolean(this.Value, this.formatProvider);
		public byte AsByte => this.Value is byte asByte ? asByte :  Convert.ToByte(this.Value, this.formatProvider);
		public short AsInt16 => this.Value is short asInt16 ? asInt16 : Convert.ToInt16(this.Value, this.formatProvider);
		public int AsInt32 => this.Value is int asInt32 ? asInt32 : Convert.ToInt32(this.Value, this.formatProvider);
		public long AsInt64 => this.Value is long asInt64 ? asInt64 : Convert.ToInt64(this.Value, this.formatProvider);
		public sbyte AsSByte => this.Value is sbyte asSByte ? asSByte : Convert.ToSByte(this.Value, this.formatProvider);
		public ushort AsUInt16 => this.Value is ushort asUInt16 ? asUInt16 : Convert.ToUInt16(this.Value, this.formatProvider);
		public uint AsUInt32 => this.Value is uint asUInt32 ? asUInt32 : Convert.ToUInt32(this.Value, this.formatProvider);
		public ulong AsUInt64 => this.Value is ulong asUInt64 ? asUInt64 : Convert.ToUInt64(this.Value, this.formatProvider);
		public float AsSingle => this.Value is float asSingle ? asSingle : Convert.ToSingle(this.Value, this.formatProvider);
		public double AsDouble => this.Value is double asDouble ? asDouble : Convert.ToDouble(this.Value, this.formatProvider);
		public decimal AsDecimal => this.Value is decimal asDecimal ? asDecimal : Convert.ToDecimal(this.Value, this.formatProvider);
		public DateTime AsDateTime => this.Value is DateTime asDateTime ? asDateTime : Convert.ToDateTime(this.Value, this.formatProvider);
		public DateTimeOffset AsDateTimeOffset => this.Value is DateTimeOffset asDateTimeOffset ? asDateTimeOffset : new DateTimeOffset(Convert.ToDateTime(this.Value, this.formatProvider));
		public TimeSpan AsTimeSpan => this.Value is TimeSpan asTimeSpan ? asTimeSpan : TimeSpan.Parse(this.AsString ?? string.Empty, this.formatProvider);
		public string AsString => this.Value?.ToString();
		public object AsObject => this.Value;

		public void Store<T>(T value)
		{
			var type = typeof(T);
			if (type != ValueType)
			{
				throw new ArgumentException($"Unable to store value of type '{typeof(ValueT)}' in container of type '{type}'");
			}

			this.Value = (ValueT)(object)value;
		}

		public override string ToString()
		{
			return Convert.ToString(this.Value, this.formatProvider);
		}
	}

	}
}
/* # move to Formulas.cs */

//------------------------------------------------------------------------------
// <auto-generated>
//	 This code was generated by a tool.
//	 Changes to this file may cause incorrect behavior and will be lost if
//	 the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// ReSharper disable All


namespace Assets.Data
{
	using System;
	using System.Linq;
	using System.IO;
	using System.Text;
	using System.Globalization;
	using System.Collections;
	using System.Collections.Generic;
	using System.Collections.ObjectModel;
	using System.CodeDom.Compiler;
	using System.Runtime.InteropServices;
	using System.Runtime.Serialization;
	using System.Linq.Expressions;
	using System.Threading;
	using System.Reflection;
	using System.Diagnostics;

#if !SUPPRESS_BUILD_IN_FORMULAS
	public static class Formulas
	{
	 

		private class ArrayTypeDescription : ReflectionTypeDescription, ITypeDescription
		{
			private readonly MemberGroup indexers;
			private readonly MemberGroup constructors;
	
			public ArrayTypeDescription(Type arrayType, FormulaOptions options) : base(arrayType, options)
			{
				if (arrayType == null) throw new ArgumentNullException(nameof(arrayType));
				if (!arrayType.IsArray) throw new ArgumentException("Array type is expected.", nameof(arrayType));
	
				this.constructors = CreateConstructors(arrayType);
				this.indexers = CreateIndexers(arrayType);
			}
	
			/// <inheritdoc />
			public override bool TryGetConstructors(out MemberGroup constructors)
			{
				constructors = this.constructors;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				if (rank == this.Type.GetArrayRank())
				{
					indexAccessor = this.indexers;
					return true;
				}
				else
				{
					indexAccessor = default;
					return false;
				}
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = default;
				return false;
			}
	
			private static MemberGroup CreateConstructors(Type arrayType)
			{
				if (arrayType == null) throw new ArgumentNullException(nameof(arrayType));
	
				var elementType = arrayType.GetElementType() ?? typeof(object);
				var rank = arrayType.GetArrayRank();
				var parameterDescriptors = new ParameterDescription[rank];
				for (var index = 0; index < rank; index++)
				{
					parameterDescriptors[index] = new ParameterDescription("rank" + rank, typeof(int), isRequired: true);
				}
	
				var rankConstructor = new MemberDescription((_, indexes) =>
				{
					switch (indexes.Length)
					{
						case 1: return new VariableValue(Array.CreateInstance(elementType, indexes[0].ToInt32()));
						case 2: return new VariableValue(Array.CreateInstance(elementType, indexes[0].ToInt32(), indexes[1].ToInt32()));
						case 3: return new VariableValue(Array.CreateInstance(elementType, indexes[0].ToInt32(), indexes[1].ToInt32(), indexes[2].ToInt32()));
						default: return new VariableValue(Array.CreateInstance(elementType, Array.ConvertAll(indexes, value => value.ToInt32())));
					}
				}, arrayType, parameterDescriptors);
	
				return new MemberGroup(MemberGroupType.Constructor, new[] { rankConstructor });
			}
			private static MemberGroup CreateIndexers(Type arrayType)
			{
				if (arrayType == null) throw new ArgumentNullException(nameof(arrayType));
	
				var rank = arrayType.GetArrayRank();
				var elementType = arrayType.GetElementType() ?? typeof(object);
				var parameterDescriptors = new ParameterDescription[rank];
				for (var index = 0; index < rank; index++)
				{
					parameterDescriptors[index] = new ParameterDescription("rank" + rank, typeof(int), isRequired: true);
				}
	
				var indexMethod = new MemberDescription((target, indexes) =>
				{
					
					var array = (Array)target.ToObject();
					switch (indexes.Length)
					{
						case 1: return new VariableValue(array.GetValue(indexes[0].ToInt32()));
						case 2: return new VariableValue(array.GetValue(indexes[0].ToInt32(), indexes[1].ToInt32()));
						case 3: return new VariableValue(array.GetValue(indexes[0].ToInt32(), indexes[1].ToInt32(), indexes[2].ToInt32()));
						default: return new VariableValue(array.GetValue(Array.ConvertAll(indexes, value => value.ToInt32())));
					}
				}, elementType, parameterDescriptors);
				return new MemberGroup(MemberGroupType.Method, new[] { indexMethod });
			}
		}
	

		private sealed class BinaryExpression : FormulaExpression
		{
			private readonly FormulaExpression left;
			private readonly FormulaExpression right;
			private readonly BinaryOperationType binaryOperationType;
			private readonly BinaryOperationType fallbackBinaryOperationType;
	
			public BinaryExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.left = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.LEFT_ATTRIBUTE);
				this.right = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.RIGHT_ATTRIBUTE);
	
				var expressionType = ExpressionBuildHelper.GetString(expressionObj, FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE);
				this.binaryOperationType = MapToBinaryOperationType(expressionType);
	
				// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
				switch (this.binaryOperationType)
				{
					case BinaryOperationType.AddChecked: this.fallbackBinaryOperationType = BinaryOperationType.Add; break;
					case BinaryOperationType.SubtractChecked: this.fallbackBinaryOperationType = BinaryOperationType.Subtract; break;
					case BinaryOperationType.DivideChecked: this.fallbackBinaryOperationType = BinaryOperationType.Divide; break;
					case BinaryOperationType.MultiplyChecked: this.fallbackBinaryOperationType = BinaryOperationType.Multiply; break;
					default: this.fallbackBinaryOperationType = this.binaryOperationType; break;
				}
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				if (this.binaryOperationType == BinaryOperationType.Coalesce)
				{
					return this.ExecuteCoalesce(context);
				}
				else if (this.binaryOperationType == BinaryOperationType.AndAlso ||
						this.binaryOperationType == BinaryOperationType.OrElse)
				{
					return this.ExecuteJunction(context);
				}
				else if (this.binaryOperationType == BinaryOperationType.Power)
				{
					return this.ExecutePower(context);
				}
	
				var leftValue = this.left.Execute(context);
				var rightValue = this.right.Execute(context);
				if (leftValue.IsNull || rightValue.IsNull)
				{
					if (leftValue.TypeCode == TypeCode.Boolean || rightValue.TypeCode == TypeCode.Boolean)
					{
						return this.ExecuteNullLiftedBoolean(leftValue, rightValue);
					}
					else
					{
						return this.ExecuteNullLifted(leftValue, rightValue);
					}
				}
	
				if (!TryPromoteOperands(ref leftValue, ref rightValue, this.binaryOperationType))
				{
					throw FormulaException.MissingBinaryOperation(this.binaryOperationType, leftValue, rightValue);
				}
	
				var arguments = new Dictionary<string, VariableValue> {
					{ "0", leftValue },
					{ "1", rightValue },
				};
				var leftValueType = context.TypeResolver.GetTypeDescription(leftValue.Type);
				if (leftValueType.TryGetBinaryOperation(this.binaryOperationType, out var binaryOperation) &&
					binaryOperation.TryInvoke(VariableValue.Null, arguments, expectedType: null, typeArguments: null, out var result))
				{
					return result;
				}
				else if (this.fallbackBinaryOperationType != this.binaryOperationType &&  // try to perform fallback binary operation
							leftValueType.TryGetBinaryOperation(this.fallbackBinaryOperationType, out binaryOperation) &&
							binaryOperation.TryInvoke(VariableValue.Null, arguments, expectedType: null, typeArguments: null, out result))
				{
					return result;
				}
				throw FormulaException.MissingBinaryOperation(this.binaryOperationType, leftValue, rightValue);
			}
	
			private VariableValue ExecuteNullLiftedBoolean(VariableValue leftValue, VariableValue rightValue)
			{
				// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
				switch (this.binaryOperationType)
				{
					case BinaryOperationType.And:
						if (rightValue.IsNull && leftValue.IsNull)
						{
							return VariableValue.Null;
						}
						else if (rightValue.IsNull)
						{
							return leftValue.ToBoolean() ? VariableValue.Null : false;
						}
						else
						{
							return rightValue.ToBoolean() ? VariableValue.Null : false;
	
						}
					case BinaryOperationType.Or:
						if (rightValue.IsNull && leftValue.IsNull)
						{
							return VariableValue.Null;
						}
						else if (rightValue.IsNull)
						{
							return leftValue.ToBoolean() ? true : VariableValue.Null;
						}
						else
						{
							return rightValue.ToBoolean() ? true : VariableValue.Null;
	
						}
					default: return this.ExecuteNullLifted(leftValue, rightValue);
				}
			}
			private VariableValue ExecuteNullLifted(VariableValue leftValue, VariableValue rightValue)
			{
				switch (this.binaryOperationType)
				{
					case BinaryOperationType.And:
					case BinaryOperationType.Or:
					case BinaryOperationType.ExclusiveOr:
					case BinaryOperationType.Multiply:
					case BinaryOperationType.MultiplyChecked:
					case BinaryOperationType.Divide:
					case BinaryOperationType.DivideChecked:
					case BinaryOperationType.Power:
					case BinaryOperationType.Modulo:
					case BinaryOperationType.Add:
					case BinaryOperationType.AddChecked:
					case BinaryOperationType.Subtract:
					case BinaryOperationType.SubtractChecked:
					case BinaryOperationType.LeftShift:
					case BinaryOperationType.RightShift:
						return VariableValue.Null;
					case BinaryOperationType.GreaterThan:
					case BinaryOperationType.GreaterThanOrEqual:
					case BinaryOperationType.LessThan:
					case BinaryOperationType.LessThanOrEqual:
						return false;
					case BinaryOperationType.Equal:
						return leftValue.IsNull == rightValue.IsNull;
					case BinaryOperationType.NotEqual:
						return leftValue.IsNull != rightValue.IsNull;
					case BinaryOperationType.AndAlso:
					case BinaryOperationType.OrElse:
					case BinaryOperationType.Coalesce:
					default: throw FormulaException.UnknownBinaryExpression(this.binaryOperationType.ToString());
				}
			}
			private VariableValue ExecutePower(FormulaExecutionContext context)
			{
				var leftValue = this.left.Execute(context);
				var rightValue = this.right.Execute(context);
				if (leftValue.IsNull || rightValue.IsNull)
				{
					return VariableValue.Null;
				}
				return Math.Pow(leftValue.ToDouble(), rightValue.ToDouble());
			}
			private VariableValue ExecuteJunction(FormulaExecutionContext context)
			{
				var junctionOperator = this.binaryOperationType == BinaryOperationType.AndAlso ? "&&" : "||";
				var leftValue = this.left.Execute(context);
				if (leftValue.Type != typeof(bool))
				{
					return FormulaException.WrongJunctionOperands(junctionOperator, leftValue, new VariableValue(false));
				}
	
				if (this.binaryOperationType == BinaryOperationType.AndAlso && !leftValue.ToBoolean())
				{
					return new VariableValue(false); // shortcut
				}
				else if (this.binaryOperationType == BinaryOperationType.OrElse && leftValue.ToBoolean())
				{
					return new VariableValue(true); // shortcut
				}
	
				var rightValue = this.right.Execute(context);
				if (rightValue.Type != typeof(bool))
				{
					return FormulaException.WrongJunctionOperands(junctionOperator, leftValue, rightValue);
				}
	
				return this.binaryOperationType == BinaryOperationType.AndAlso ? leftValue.ToBoolean() && rightValue.ToBoolean() : leftValue.ToBoolean() || rightValue.ToBoolean();
			}
			private VariableValue ExecuteCoalesce(FormulaExecutionContext context)
			{
				var leftValue = this.left.Execute(context);
				if (!leftValue.IsNull)
				{
					return leftValue;
				}
				var rightValue = this.right.Execute(context);
				return leftValue.IsNull ? rightValue : leftValue;
			}
	
			private static bool TryPromoteOperands(ref VariableValue leftValue, ref VariableValue rightValue, BinaryOperationType operationType)
			{
				var leftIsEnum = leftValue.Type.IsEnum;
				var leftTypeCode = leftValue.TypeCode;
				var leftIsInteger = leftTypeCode >= TypeCode.SByte && leftTypeCode <= TypeCode.UInt64;
				var leftIsNumber = TypeCodes.IsNumberLike(leftTypeCode);
				var leftIsString = leftTypeCode == TypeCode.String;
				var rightIsEnum = rightValue.Type.IsEnum;
				var rightTypeCode = rightValue.TypeCode;
				var rightIsInteger = rightTypeCode >= TypeCode.SByte && rightTypeCode <= TypeCode.UInt64;
				var rightIString = rightTypeCode == TypeCode.String;
				var rightIsNumber = TypeCodes.IsNumberLike(rightTypeCode);
				var isNumberPromotableOperation = operationType != BinaryOperationType.RightShift && operationType != BinaryOperationType.LeftShift;
	
				if (leftIsEnum && rightIsEnum)
				{
					return leftTypeCode == rightTypeCode;
				}
				else if (leftIsEnum && rightIsInteger)
				{
					if (!rightValue.CanFitInto(leftTypeCode))
					{
						return false;
					}
					rightValue = VariableValue.FromEnum(leftValue.Type, rightValue.ToInt64(uncheckedConversion: true));
				}
				else if (leftIsInteger && rightIsEnum)
				{
					if (!leftValue.CanFitInto(rightTypeCode))
					{
						return false;
					}
					leftValue = VariableValue.FromEnum(rightValue.Type, leftValue.ToInt64(uncheckedConversion: true));
				}
				else if (leftIsNumber && rightIsNumber && isNumberPromotableOperation)
				{
					if (leftTypeCode == TypeCode.Decimal || rightTypeCode == TypeCode.Decimal)
					{
						if (leftTypeCode == TypeCode.Double || leftTypeCode == TypeCode.Single || rightTypeCode == TypeCode.Double || rightTypeCode == TypeCode.Single)
						{
							return false; // will throw exception
						}
	
						if (leftTypeCode == TypeCode.Decimal)
							rightValue = rightValue.ToDecimal();
						else
							leftValue = leftValue.ToDecimal();
					}
					else if (leftTypeCode == TypeCode.Double || rightTypeCode == TypeCode.Double)
					{
						if (leftTypeCode == TypeCode.Double)
							rightValue = rightValue.ToDouble();
						else
							leftValue = leftValue.ToDouble();
					}
					else if (leftTypeCode == TypeCode.Single || rightTypeCode == TypeCode.Single)
					{
						if (leftTypeCode == TypeCode.Single)
							rightValue = rightValue.ToSingle();
						else
							leftValue = leftValue.ToSingle();
					}
					else if (leftTypeCode == TypeCode.UInt64)
					{
						if (TypeCodes.IsSignedInteger(rightTypeCode) &&
							!rightValue.CanFitInto(leftTypeCode))
						{
							return false; // will throw exception
						}
						rightValue = rightValue.ToUInt64();
					}
					else if (rightTypeCode == TypeCode.UInt64)
					{
						if (TypeCodes.IsSignedInteger(leftTypeCode) &&
							!rightValue.CanFitInto(leftTypeCode))
						{
							return false; // will throw exception
						}
						leftValue = leftValue.ToUInt64();
					}
					else if (leftTypeCode == TypeCode.Int64 || rightTypeCode == TypeCode.Int64)
					{
						if (leftTypeCode == TypeCode.Int64)
							rightValue = rightValue.ToInt64();
						else
							leftValue = leftValue.ToInt64();
					}
					else if ((leftTypeCode == TypeCode.UInt32 && TypeCodes.IsSignedInteger(rightTypeCode)) ||
						(rightTypeCode == TypeCode.UInt32 && TypeCodes.IsSignedInteger(leftTypeCode)))
					{
						rightValue = rightValue.ToInt64();
						leftValue = leftValue.ToInt64();
					}
					else if (leftTypeCode == TypeCode.UInt32 || rightTypeCode == TypeCode.UInt32)
					{
						if (leftTypeCode == TypeCode.UInt32)
							rightValue = rightValue.ToUInt32();
						else
							leftValue = leftValue.ToUInt32();
					}
					else
					{
						rightValue = rightValue.ToInt32();
						leftValue = leftValue.ToInt32();
					}
				}
				else if ((leftIsString || rightIString) && (operationType == BinaryOperationType.Add || operationType == BinaryOperationType.AddChecked))
				{
					if (!leftIsString)
					{
						leftValue = leftValue.ToString();
					}
					if (!rightIString)
					{
						rightValue = rightValue.ToString();
					}
				}
	
				return true;
			}
	
			private static BinaryOperationType MapToBinaryOperationType(string expressionType)
			{
				BinaryOperationType binaryOperationType;
				switch (expressionType)
				{
					case FormulaConstants.EXPRESSION_TYPE_DIVIDE_CHECKED: binaryOperationType = BinaryOperationType.DivideChecked; break;
					case FormulaConstants.EXPRESSION_TYPE_DIVIDE: binaryOperationType = BinaryOperationType.Divide; break;
					case FormulaConstants.EXPRESSION_TYPE_MULTIPLY_CHECKED: binaryOperationType = BinaryOperationType.MultiplyChecked; break;
					case FormulaConstants.EXPRESSION_TYPE_MULTIPLY: binaryOperationType = BinaryOperationType.Multiply; break;
					case FormulaConstants.EXPRESSION_TYPE_MODULO: binaryOperationType = BinaryOperationType.Modulo; break;
					case FormulaConstants.EXPRESSION_TYPE_ADD_CHECKED: binaryOperationType = BinaryOperationType.AddChecked; break;
					case FormulaConstants.EXPRESSION_TYPE_ADD: binaryOperationType = BinaryOperationType.Add; break;
					case FormulaConstants.EXPRESSION_TYPE_POWER: binaryOperationType = BinaryOperationType.Power; break;
					case FormulaConstants.EXPRESSION_TYPE_SUBTRACT_CHECKED: binaryOperationType = BinaryOperationType.SubtractChecked; break;
					case FormulaConstants.EXPRESSION_TYPE_SUBTRACT: binaryOperationType = BinaryOperationType.Subtract; break;
					case FormulaConstants.EXPRESSION_TYPE_LEFT_SHIFT: binaryOperationType = BinaryOperationType.LeftShift; break;
					case FormulaConstants.EXPRESSION_TYPE_RIGHT_SHIFT: binaryOperationType = BinaryOperationType.RightShift; break;
					case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN: binaryOperationType = BinaryOperationType.GreaterThan; break;
					case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL: binaryOperationType = BinaryOperationType.GreaterThanOrEqual; break;
					case FormulaConstants.EXPRESSION_TYPE_LESS_THAN: binaryOperationType = BinaryOperationType.LessThan; break;
					case FormulaConstants.EXPRESSION_TYPE_LESS_THAN_OR_EQUAL: binaryOperationType = BinaryOperationType.LessThanOrEqual; break;
					case FormulaConstants.EXPRESSION_TYPE_EQUAL: binaryOperationType = BinaryOperationType.Equal; break;
					case FormulaConstants.EXPRESSION_TYPE_NOT_EQUAL: binaryOperationType = BinaryOperationType.NotEqual; break;
					case FormulaConstants.EXPRESSION_TYPE_AND: binaryOperationType = BinaryOperationType.And; break;
					case FormulaConstants.EXPRESSION_TYPE_OR: binaryOperationType = BinaryOperationType.Or; break;
					case FormulaConstants.EXPRESSION_TYPE_EXCLUSIVE_OR: binaryOperationType = BinaryOperationType.ExclusiveOr; break;
					case FormulaConstants.EXPRESSION_TYPE_AND_ALSO: binaryOperationType = BinaryOperationType.AndAlso; break;
					case FormulaConstants.EXPRESSION_TYPE_OR_ELSE: binaryOperationType = BinaryOperationType.OrElse; break;
					case FormulaConstants.EXPRESSION_TYPE_COALESCE: binaryOperationType = BinaryOperationType.Coalesce; break;
					default: throw FormulaException.UnknownBinaryExpression(expressionType);
				}
				return binaryOperationType;
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				if (!(this.left is ConstantExpression))
				{
					stringBuilder.Append("(");
				}
				this.left.BuildDebugView(stringBuilder);
				if (!(this.left is ConstantExpression))
				{
					stringBuilder.Append(")");
				}
	
				stringBuilder.Append(" ");
				switch (this.binaryOperationType)
				{
					case BinaryOperationType.And: stringBuilder.Append("&"); break;
					case BinaryOperationType.Or: stringBuilder.Append("|"); break;
					case BinaryOperationType.ExclusiveOr: stringBuilder.Append("^"); break;
					case BinaryOperationType.Multiply: stringBuilder.Append("*"); break;
					case BinaryOperationType.MultiplyChecked: stringBuilder.Append("*"); break;
					case BinaryOperationType.Divide: stringBuilder.Append("/"); break;
					case BinaryOperationType.DivideChecked: stringBuilder.Append("/"); break;
					case BinaryOperationType.Power: stringBuilder.Append("**"); break;
					case BinaryOperationType.Modulo: stringBuilder.Append("%"); break;
					case BinaryOperationType.Add: stringBuilder.Append("+"); break;
					case BinaryOperationType.AddChecked: stringBuilder.Append("+"); break;
					case BinaryOperationType.Subtract: stringBuilder.Append("-"); break;
					case BinaryOperationType.SubtractChecked: stringBuilder.Append("-"); break;
					case BinaryOperationType.LeftShift: stringBuilder.Append("<<"); break;
					case BinaryOperationType.RightShift: stringBuilder.Append(">>"); break;
					case BinaryOperationType.GreaterThan: stringBuilder.Append(">"); break;
					case BinaryOperationType.GreaterThanOrEqual: stringBuilder.Append(">="); break;
					case BinaryOperationType.LessThan: stringBuilder.Append("<"); break;
					case BinaryOperationType.LessThanOrEqual: stringBuilder.Append("<="); break;
					case BinaryOperationType.Equal: stringBuilder.Append("=="); break;
					case BinaryOperationType.NotEqual: stringBuilder.Append("!="); break;
					case BinaryOperationType.AndAlso: stringBuilder.Append("&&"); break;
					case BinaryOperationType.OrElse: stringBuilder.Append("||"); break;
					case BinaryOperationType.Coalesce: stringBuilder.Append("??"); break;
					default: stringBuilder.Append(this.binaryOperationType); break;
				}
				stringBuilder.Append(" ");
	
				if (!(this.right is ConstantExpression))
				{
					stringBuilder.Append("(");
				}
				this.right.BuildDebugView(stringBuilder);
				if (!(this.right is ConstantExpression))
				{
					stringBuilder.Append(")");
				}
			}
		}
	

		public enum BinaryOperationType
		{
			And,
			Or,
			ExclusiveOr,
			Multiply,
			MultiplyChecked,
			Divide,
			DivideChecked,
			Power,
			Modulo,
			Add,
			AddChecked,
			Subtract,
			SubtractChecked,
			LeftShift,
			RightShift,
			GreaterThan,
			GreaterThanOrEqual,
			LessThan,
			LessThanOrEqual,
			Equal,
			NotEqual,
			AndAlso,
			OrElse,
			Coalesce
		}
	

		private sealed class BooleanTypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
	
			static BooleanTypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<bool>((_, arguments) => (arguments[0].ToBoolean() & arguments[1].ToBoolean()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<bool>((_, arguments) => (arguments[0].ToBoolean() | arguments[1].ToBoolean()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<bool>((_, arguments) => (arguments[0].ToBoolean() ^ arguments[1].ToBoolean()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToBoolean() == arguments[1].ToBoolean()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToBoolean() != arguments[1].ToBoolean()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.Not] = CreateUnaryOperation<bool>((_, arguments) => (bool)unchecked(!arguments[0].ToBoolean()));
			}
			/// <inheritdoc />
			public BooleanTypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Boolean), isRequired: true),
								new ParameterDescription("value2", typeof(Boolean), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Boolean), isRequired: true)
							})
					});
			}
	
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class CharTypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static CharTypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToChar() & arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToChar() | arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToChar() ^ arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToChar() * arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() * arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToChar() / arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() / arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToChar(), arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToChar() % arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToChar() + arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() + arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToChar() - arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() - arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToChar() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() > arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() >= arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() < arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() <= arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() == arguments[1].ToChar()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToChar() != arguments[1].ToChar()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToChar()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToChar()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToChar()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToChar()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToChar())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToChar())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToChar())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToChar())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToChar())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToChar())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToChar())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToChar())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToChar())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToChar())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToChar())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToChar())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToChar(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToChar(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public CharTypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Char), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(Char), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Char), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(Char), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class ConditionExpression : FormulaExpression
		{
			private readonly FormulaExpression test;
			private readonly FormulaExpression ifTrue;
			private readonly FormulaExpression ifFalse;
	
			public ConditionExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.test = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.TEST_ATTRIBUTE);
				this.ifTrue = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.IF_TRUE_ATTRIBUTE);
				this.ifFalse = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.IF_FALSE_ATTRIBUTE);
			}
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var testValue = this.test.Execute(context);
				if (testValue.Type != typeof(bool))
				{
					throw FormulaException.InvalidConditionResultType(testValue);
				}
	
				return testValue.ToBoolean() ? this.ifTrue.Execute(context) : this.ifFalse.Execute(context);
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append("(");
				this.test.BuildDebugView(stringBuilder);
				stringBuilder.Append(")");
				stringBuilder.Append(" ? ");
				if (!(this.ifTrue is ConstantExpression))
				{
					stringBuilder.Append("(");
				}
				this.ifTrue.BuildDebugView(stringBuilder);
				if (!(this.ifTrue is ConstantExpression))
				{
					stringBuilder.Append(")");
				}
				stringBuilder.Append(" : ");
				if (!(this.ifFalse is ConstantExpression))
				{
					stringBuilder.Append("(");
				}
				this.ifFalse.BuildDebugView(stringBuilder);
				if (!(this.ifFalse is ConstantExpression))
				{
					stringBuilder.Append(")");
				}
			}
		}
	

		private sealed class ConstantExpression : FormulaExpression
		{
			private readonly object value;
			private readonly FormulaTypeReference type;
	
			public ConstantExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.value = ExpressionBuildHelper.GetAnyValue(expressionObj, FormulaConstants.VALUE_ATTRIBUTE, optional: true);
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.TYPE_ATTRIBUTE);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				if (this.value == null)
				{
					return VariableValue.Null;
				}
	
				switch (this.type.ToString())
				{
					case FormulaConstants.KNOWN_TYPE_SYSTEM_CHAR: return (Convert.ToString(this.value, CultureInfo.InvariantCulture) ?? string.Empty).FirstOrDefault();
					case FormulaConstants.KNOWN_TYPE_SYSTEM_BOOL: return Convert.ToBoolean(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_BYTE: return Convert.ToByte(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_SBYTE: return Convert.ToSByte(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_INT16: return Convert.ToInt16(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT16: return Convert.ToUInt16(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_INT32: return Convert.ToInt32(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT32: return Convert.ToUInt32(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_INT64: return Convert.ToInt64(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT64: return Convert.ToUInt64(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_DOUBLE: return Convert.ToDouble(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_SINGLE: return Convert.ToSingle(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_DECIMAL: return Convert.ToDecimal(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_DATE_TIME: return Convert.ToDateTime(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_TIME_SPAN: return VariableValue.ToTimeSpan(this.value, CultureInfo.InvariantCulture);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_TYPE:
						var typeReference = default(FormulaTypeReference);
						if (this.value is IReadOnlyDictionary<string, object> expression)
						{
							typeReference = new FormulaTypeReference(expression);
						}
						else
						{
							var typeName = new VariableValue(this.value).ToString();
							typeReference = new FormulaTypeReference(typeName, Array.Empty<FormulaTypeReference>(), null);
						}
						var type = context.TypeResolver.GetTypeDescription(typeReference).Type;
						return new VariableValue(type);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_STRING: return new VariableValue(new VariableValue(this.value).ToString());
					case FormulaConstants.KNOWN_TYPE_SYSTEM_OBJECT:
					default: return new VariableValue(this.value);
				}
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				if (this.value == null)
				{
					stringBuilder.Append("null");
				}
				else if (this.value is string || this.value is DateTime || this.value is TimeSpan)
				{
					stringBuilder.Append("\"").Append(this.value).Append("\"");
				}
				else
				{
					stringBuilder.Append(this.value);
				}
			}
		}
	

		private sealed class ConvertExpression : FormulaExpression
		{
			private readonly FormulaTypeReference type;
			private readonly FormulaExpression expression;
			private readonly string expressionType;
	
			public ConvertExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.expressionType = ExpressionBuildHelper.GetString(expressionObj, FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE, optional: false);
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.TYPE_ATTRIBUTE, optional: false);
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE, optional: false);
			}
			public ConvertExpression(FormulaExpression expression, Type type, bool checkedScope = true)
			{
				this.expressionType = checkedScope ? FormulaConstants.EXPRESSION_TYPE_CONVERT_CHECKED : FormulaConstants.EXPRESSION_TYPE_CONVERT;
				this.expression = expression;
				this.type = new FormulaTypeReference(type);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var value = this.expression.Execute(context);
				var targetTypeDescriptor = context.TypeResolver.GetTypeDescription(this.type);
	
				if (value.IsNull)
				{
					if (targetTypeDescriptor.CanBeNull)
					{
						return VariableValue.Null;
					}
					else
					{
						throw FormulaException.CanConvertNullToType(value, targetTypeDescriptor);
					}
				}
	
				if (value.Type == typeof(UnboundLambda) &&
					typeof(Delegate).IsAssignableFrom(targetTypeDescriptor.Type))
				{
					return this.ExecuteLambdaBinding(targetTypeDescriptor, (UnboundLambda)value.ToObject());
				}
				if (this.expressionType == FormulaConstants.EXPRESSION_TYPE_TYPE_AS)
				{
					return ExecuteTypeAs(targetTypeDescriptor, value);
				}
				else
				{
					return this.ExecuteConvert(context, value, targetTypeDescriptor);
				}
	
			}
			private VariableValue ExecuteConvert(FormulaExecutionContext context, VariableValue value, ITypeDescription targetTypeDescription)
			{
				var valueTypeDescriptor = context.TypeResolver.GetTypeDescription(value.Type);
				var targetValueType = targetTypeDescription.Type;
	
				if (targetValueType.IsAssignableFrom(value.Type))
				{
					return value;
				}
	
				var arguments = new Dictionary<string, VariableValue> {
					{ "0", value }
				};
	
				// try checked conversion
				if (this.expressionType == FormulaConstants.EXPRESSION_TYPE_CONVERT_CHECKED &&
					(valueTypeDescriptor.TryGetCheckedConversionOperation(out var conversionOperation) ||
					targetTypeDescription.TryGetCheckedConversionOperation(out conversionOperation)) &&
					conversionOperation.TryInvoke(VariableValue.Null, arguments, targetValueType, typeArguments: null, out var result))
				{
	
					return result;
				}
	
				// try fallback/checked conversion
				if ((valueTypeDescriptor.TryGetConversionOperation(out conversionOperation) ||
					targetTypeDescription.TryGetConversionOperation(out conversionOperation)) &&
					conversionOperation.TryInvoke(VariableValue.Null, arguments, targetValueType, typeArguments: null, out result))
				{
					return result;
				}
	
				throw FormulaException.CanConvertToType(value, targetTypeDescription);
			}
			private VariableValue ExecuteLambdaBinding(ITypeDescription delegateTypeDescription, UnboundLambda unboundLambda)
			{
				if (delegateTypeDescription == null) throw new ArgumentNullException(nameof(delegateTypeDescription));
				if (unboundLambda == null) throw new ArgumentNullException(nameof(unboundLambda));
	
				if (!unboundLambda.IsSignatureMatching(delegateTypeDescription.Type))
				{
					throw FormulaException.CanConvertToType(new VariableValue(unboundLambda), delegateTypeDescription);
				}
	
				var boundLambda = unboundLambda.BindTo(delegateTypeDescription.Type);
				return new VariableValue(boundLambda);
			}
			private static VariableValue ExecuteTypeAs(ITypeDescription targetTypeDescription, VariableValue value)
			{
				if (targetTypeDescription.Type.IsAssignableFrom(value.Type))
				{
					return value;
				}
				else
				{
					return VariableValue.Null;
				}
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				if (this.expressionType == FormulaConstants.EXPRESSION_TYPE_TYPE_AS)
				{
					this.expression.BuildDebugView(stringBuilder);
					stringBuilder.Append(" as ");
					stringBuilder.Append(this.type);
				}
				else
				{
					stringBuilder.Append("(");
					stringBuilder.Append(this.type);
					stringBuilder.Append(") ");
					this.expression.BuildDebugView(stringBuilder);
				}
			}
		}
	

		private sealed class CSharpNameUtils
		{
			private static readonly Dictionary<Type, string> AliasByTypeName;
	
			static CSharpNameUtils()
			{
				var typeNameByAlias = new Dictionary<string, Type>
				{
					// ReSharper disable StringLiteralTypo
					{ "void", typeof(void) },
					{ "char", typeof(char) },
					{ "bool", typeof(bool) },
					{ "byte", typeof(byte) },
					{ "sbyte", typeof(sbyte) },
					{ "decimal", typeof(decimal) },
					{ "double", typeof(double) },
					{ "float", typeof(float) },
					{ "int", typeof(int) },
					{ "uint", typeof(uint) },
					{ "long", typeof(long) },
					{ "ulong", typeof(ulong) },
					{ "object", typeof(object) },
					{ "short", typeof(short) },
					{ "ushort", typeof(ushort) },
					{ "string", typeof(string) }
	
					// ReSharper restore StringLiteralTypo
				};
				AliasByTypeName = typeNameByAlias.ToDictionary(kv => kv.Value, kv => kv.Key);
			}
	
			[Flags]
			private enum TypeNameFormatOptions
			{
				None,
				// ReSharper disable once ShiftExpressionRealShiftCountIsZero
				IncludeDeclaringType = 0x1 << 0,
				IncludeNamespace = 0x1 << 1 | IncludeDeclaringType,
				IncludeGenericArguments = 0x1 << 2,
				IncludeGenericSuffix = 0x1 << 3,
			}
	
			public static KeyValuePair<string, string> GetTypeNames(Type type)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				var name = type.Name;
				if (string.IsNullOrEmpty(name))
				{
					return new KeyValuePair<string, string>(null, null);
				}
	
				if (type == typeof(Array))
				{
					return new KeyValuePair<string, string>(name, name + "`1");
				}
				else if (type.IsGenericType)
				{
					return new KeyValuePair<string, string>(
						GetCSharpName(type, options: TypeNameFormatOptions.None).ToString(),
						GetCSharpName(type, options: TypeNameFormatOptions.IncludeGenericSuffix).ToString());
				}
				else if (AliasByTypeName.TryGetValue(type, out var alias))
				{
					return new KeyValuePair<string, string>(alias, GetCSharpName(type).ToString());
				}
				else
				{
					return new KeyValuePair<string, string>(GetCSharpName(type).ToString(), null);
				}
			}
			public static KeyValuePair<string, string> GetTypeFullNames(Type type)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				var fullName = type.FullName;
				if (string.IsNullOrEmpty(fullName))
				{
					return new KeyValuePair<string, string>(null, null);
				}
	
				if (type == typeof(Array))
				{
					return new KeyValuePair<string, string>(fullName, fullName + "`1");
				}
				else if (type.IsGenericType)
				{
					return new KeyValuePair<string, string>(GetCSharpFullName(type, options: TypeNameFormatOptions.None).ToString(),
						GetCSharpFullName(type, options: TypeNameFormatOptions.IncludeGenericSuffix).ToString());
				}
				else
				{
					return new KeyValuePair<string, string>(GetCSharpFullName(type).ToString(), null);
				}
			}
	
			public static string GetCSharpFullNameWithGenerics(Type type)
			{
				return GetCSharpFullName(type, new StringBuilder(), TypeNameFormatOptions.IncludeGenericArguments).ToString();
			}
	
			private static StringBuilder GetCSharpFullName(Type type, StringBuilder builder = null, TypeNameFormatOptions options = TypeNameFormatOptions.IncludeGenericSuffix)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				if (builder == null)
				{
					builder = new StringBuilder();
				}
	
				var nameStartIndex = builder.Length;
				WriteName(type, builder, options | TypeNameFormatOptions.IncludeNamespace);
	
				if ((options & TypeNameFormatOptions.IncludeGenericSuffix) == 0)
				{
					RemoveGenericSuffix(builder, nameStartIndex, builder.Length - nameStartIndex);
				}
	
				return builder;
			}
			private static StringBuilder GetCSharpName(Type type, StringBuilder builder = null, TypeNameFormatOptions options = TypeNameFormatOptions.IncludeGenericSuffix)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				if (builder == null)
				{
					builder = new StringBuilder();
				}
	
				var nameStartIndex = builder.Length;
				WriteName(type, builder, options & ~TypeNameFormatOptions.IncludeNamespace | TypeNameFormatOptions.IncludeDeclaringType);
	
				if ((options & TypeNameFormatOptions.IncludeGenericSuffix) == 0)
				{
					return RemoveGenericSuffix(builder, nameStartIndex, builder.Length - nameStartIndex);
				}
	
				return builder;
			}
	
			private static StringBuilder RemoveGenericSuffix(StringBuilder builder, int startIndex, int count)
			{
				if (builder == null) throw new ArgumentNullException(nameof(builder));
				if (startIndex < 0 || startIndex > builder.Length) throw new ArgumentOutOfRangeException(nameof(startIndex));
				if (count < 0 || startIndex + count > builder.Length) throw new ArgumentOutOfRangeException(nameof(count));
	
				if (count == 0 || startIndex == builder.Length) return builder;
	
				var endIndex = startIndex + count;
				var markerIndex = IndexOf(builder, '`', startIndex, count);
				var cutStartIndex = markerIndex;
				while (markerIndex >= 0)
				{
					markerIndex++;
					while (markerIndex < endIndex && char.IsDigit(builder[markerIndex]))
						markerIndex++;
	
					var cutLength = markerIndex - cutStartIndex;
					builder.Remove(cutStartIndex, cutLength);
	
					endIndex -= cutLength;
					markerIndex = IndexOf(builder, '`', cutStartIndex, endIndex - cutStartIndex);
					cutStartIndex = markerIndex;
				}
	
				return builder;
			}
	
			private static void WriteName(Type type, StringBuilder builder, TypeNameFormatOptions options)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
				if (builder == null) throw new ArgumentNullException(nameof(builder));
	
				var arrayDepth = 0;
				while (type.IsArray)
				{
					type = type.GetElementType();
					arrayDepth++;
				}
	
				var writeGenericArguments = (options & TypeNameFormatOptions.IncludeGenericArguments) == TypeNameFormatOptions.IncludeGenericArguments;
				var namespaceWritten = (options & TypeNameFormatOptions.IncludeNamespace) != TypeNameFormatOptions.IncludeNamespace;
				var writeDeclaringType = (options & TypeNameFormatOptions.IncludeDeclaringType) == TypeNameFormatOptions.IncludeDeclaringType;
	
				var genericArguments = type.IsGenericType && writeGenericArguments ? type.GetGenericArguments() : Type.EmptyTypes;
				var genericArgumentOffset = 0;
				foreach (var declaringTypeInfo in new TypeNestingEnumerator(type))
				{
					if (!namespaceWritten)
					{
						var typeNamespace = declaringTypeInfo.Namespace;
						builder.Append(typeNamespace);
						if (!string.IsNullOrEmpty(typeNamespace))
							builder.Append('.');
						namespaceWritten = true;
					}
	
					var genericArgumentsCount = (declaringTypeInfo.IsGenericType && writeGenericArguments ? declaringTypeInfo.GetGenericArguments().Length : 0) - genericArgumentOffset;
					var partialGenerics = new ArraySegment<Type>(genericArguments, genericArgumentOffset, genericArgumentsCount);
	
					if (writeDeclaringType || declaringTypeInfo == type)
					{
						WriteNamePart(declaringTypeInfo, builder, partialGenerics, options);
	
						if (declaringTypeInfo == type == false)
							builder.Append('.');
					}
	
					genericArgumentOffset += genericArgumentsCount;
				}
	
				for (var d = 0; d < arrayDepth; d++)
				{
					builder.Append("[]");
				}
			}
			private static void WriteNamePart(Type type, StringBuilder builder, ArraySegment<Type> genericArguments, TypeNameFormatOptions options)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
				if (builder == null) throw new ArgumentNullException(nameof(builder));
	
				builder.Append(type.Name);
	
				if (genericArguments.Count > 0)
				{
					builder.Append("<");
					for (var i = genericArguments.Offset; i < genericArguments.Offset + genericArguments.Count; i++)
					{
						// ReSharper disable once PossibleNullReferenceException
						if (genericArguments.Array[i].IsGenericParameter == false)
						{
							WriteName(genericArguments.Array[i], builder, options);
						}
						builder.Append(',');
					}
					builder.Length--;
					builder.Append(">");
				}
			}
			private static int IndexOf(StringBuilder builder, char character, int startIndex, int count)
			{
				if (builder == null) throw new ArgumentNullException(nameof(builder));
				if (startIndex < 0 || startIndex > builder.Length) throw new ArgumentOutOfRangeException(nameof(startIndex));
				if (count < 0 || startIndex + count > builder.Length) throw new ArgumentOutOfRangeException(nameof(count));
	
				if (count == 0 || startIndex == builder.Length) return -1;
	
				for (int i = startIndex, len = startIndex + count; i < len; i++)
				{
					if (builder[i] == character)
						return i;
				}
				return -1;
			}
	
			public struct TypeNestingEnumerator : IEnumerator<Type>, IEnumerable<Type>
			{
				private readonly Type typeInfo;
	
				public TypeNestingEnumerator(Type typeInfo)
				{
					this.typeInfo = typeInfo;
					this.Current = null;
				}
	
				public bool MoveNext()
				{
					if (this.Current == null)
					{
						this.Reset();
						return true;
					}
					else if (this.Current == this.typeInfo)
					{
						return false;
					}
	
					var typeAboveCurrent = this.typeInfo;
					while (typeAboveCurrent != null && this.Current == GetDeclaringType(typeAboveCurrent) == false)
						typeAboveCurrent = GetDeclaringType(typeAboveCurrent);
	
					this.Current = typeAboveCurrent;
					return typeAboveCurrent != null;
				}
				public void Reset()
				{
					this.Current = this.typeInfo;
					while (GetDeclaringType(this.Current) != null) this.Current = GetDeclaringType(this.Current);
				}
	
				private static Type GetDeclaringType(Type type)
				{
					if (type == null) throw new ArgumentNullException(nameof(type));
	
					var declaringType = type.DeclaringType;
					// ReSharper disable once ConditionIsAlwaysTrueOrFalse
					if (declaringType == null)
					{
						return null;
					}
					return declaringType;
				}
	
				public Type Current { get; private set; }
				object IEnumerator.Current => this.Current;
	
				public TypeNestingEnumerator GetEnumerator()
				{
					return this;
				}
				IEnumerator<Type> IEnumerable<Type>.GetEnumerator()
				{
					return this;
				}
				IEnumerator IEnumerable.GetEnumerator()
				{
					return this;
				}
	
				public void Dispose()
				{
	
				}
			}
		}
	

		private class DefaultExpression : FormulaExpression
		{
			private readonly FormulaTypeReference type;
	
			public DefaultExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.TYPE_ATTRIBUTE);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				switch (this.type.ToString())
				{
					case FormulaConstants.KNOWN_TYPE_SYSTEM_CHAR: return default(char);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_BOOL: return default(bool);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_BYTE: return default(byte);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_SBYTE: return default(sbyte);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_INT16: return default(short);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT16: return default(ushort);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_INT32: return default(int);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT32: return default(uint);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_INT64: return default(long);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_UINT64: return default(ulong);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_DOUBLE: return default(double);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_SINGLE: return default(float);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_DECIMAL: return default(decimal);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_DATE_TIME: return default(DateTime);
					case FormulaConstants.KNOWN_TYPE_SYSTEM_TIME_SPAN: return default(TimeSpan);
					default:
						var typeDescription = context.TypeResolver.GetTypeDescription(this.type);
						return typeDescription.DefaultValue;
	
				}
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append("default(").Append(this.type).Append(")");
			}
		}
	

		private sealed class EnumTypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private readonly Lazy<MemberGroup> lazyCheckedConversions;
			private readonly Lazy<MemberGroup> lazyUncheckedConversions;
			private readonly Lazy<MemberGroup[]> lazyBinaryOperations;
			private readonly Lazy<MemberGroup[]> lazyUnaryOperations;
	
			/// <inheritdoc />
			public EnumTypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
				if (!type.IsEnum) throw new ArgumentException($"Type '{type}' should be enum type.");
	
				this.lazyCheckedConversions = new Lazy<MemberGroup>(() => CreateCheckedConversions(type), LazyThreadSafetyMode.ExecutionAndPublication);
				this.lazyUncheckedConversions = new Lazy<MemberGroup>(() => CreateUncheckedConversions(type), LazyThreadSafetyMode.ExecutionAndPublication);
				this.lazyBinaryOperations = new Lazy<MemberGroup[]>(() => CreateBinaryOperations(type), LazyThreadSafetyMode.ExecutionAndPublication);
				this.lazyUnaryOperations = new Lazy<MemberGroup[]>(() => CreateUnaryOperations(type), LazyThreadSafetyMode.ExecutionAndPublication);
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				var binaryOperations = this.lazyBinaryOperations.Value;
				if (operationIndex >= 0 && operationIndex < binaryOperations.Length)
				{
					binaryOperation = binaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				var unaryOperations = this.lazyUnaryOperations.Value;
				if (operationIndex >= 0 && operationIndex < unaryOperations.Length)
				{
					unaryOperation = unaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = this.lazyCheckedConversions.Value;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = this.lazyUncheckedConversions.Value;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation(Type resultType, Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: resultType,
							parameters: new [] {
								new ParameterDescription("value1", typeof(Int64), isRequired: true),
								new ParameterDescription("value2", typeof(Int64), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation(Type resultType, Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: resultType,
							parameters: new [] {
								new ParameterDescription("value", typeof(Int64), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Type enumType, Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", enumType, isRequired: true)
					});
			}
			private static MemberDescription CreateConvertFrom<T>(Type enumType, Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: enumType,
					parameters: new[] {
						new ParameterDescription("value", typeof(T), isRequired: true)
					});
			}
			private static MemberGroup CreateCheckedConversions(Type enumType)
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				if (IsSigned(enumType))
				{
					return new MemberGroup(MemberGroupType.Method, new[] {
						CreateConvertTo<char>(enumType, (_, arguments) => checked((char)arguments[0].ToInt64())),
						CreateConvertTo<sbyte>(enumType,(_, arguments) => checked((sbyte)arguments[0].ToInt64())),
						CreateConvertTo<byte>(enumType,(_, arguments) => checked((byte)arguments[0].ToInt64())),
						CreateConvertTo<short>(enumType,(_, arguments) => checked((short)arguments[0].ToInt64())),
						CreateConvertTo<ushort>(enumType,(_, arguments) => checked((ushort)arguments[0].ToInt64())),
						CreateConvertTo<int>(enumType,(_, arguments) => checked((int)arguments[0].ToInt64())),
						CreateConvertTo<uint>(enumType,(_, arguments) => checked((uint)arguments[0].ToInt64())),
						CreateConvertTo<long>(enumType,(_, arguments) => checked((long)arguments[0].ToInt64())),
						CreateConvertTo<ulong>(enumType,(_, arguments) => checked((ulong)arguments[0].ToInt64())),
						CreateConvertTo<float>(enumType,(_, arguments) => checked((float)arguments[0].ToInt64())),
						CreateConvertTo<double>(enumType,(_, arguments) => checked((double)arguments[0].ToInt64())),
						CreateConvertTo<decimal>(enumType,(_, arguments) => checked((decimal)arguments[0].ToInt64())),
	
						CreateConvertFrom<sbyte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToSByte()))),
						CreateConvertFrom<byte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToByte()))),
						CreateConvertFrom<short>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt16()))),
						CreateConvertFrom<ushort>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt16()))),
						CreateConvertFrom<int>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt32()))),
						CreateConvertFrom<uint>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt32()))),
						CreateConvertFrom<long>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt64()))),
						CreateConvertFrom<ulong>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt64()))),
					});
				}
				else
				{
					return new MemberGroup(MemberGroupType.Method, new[] {
						CreateConvertTo<char>(enumType, (_, arguments) => checked((char)arguments[0].ToUInt64())),
						CreateConvertTo<sbyte>(enumType,(_, arguments) => checked((sbyte)arguments[0].ToUInt64())),
						CreateConvertTo<byte>(enumType,(_, arguments) => checked((byte)arguments[0].ToUInt64())),
						CreateConvertTo<short>(enumType,(_, arguments) => checked((short)arguments[0].ToUInt64())),
						CreateConvertTo<ushort>(enumType,(_, arguments) => checked((ushort)arguments[0].ToUInt64())),
						CreateConvertTo<int>(enumType,(_, arguments) => checked((int)arguments[0].ToUInt64())),
						CreateConvertTo<uint>(enumType,(_, arguments) => checked((uint)arguments[0].ToUInt64())),
						CreateConvertTo<long>(enumType,(_, arguments) => checked((long)arguments[0].ToUInt64())),
						CreateConvertTo<ulong>(enumType,(_, arguments) => checked((ulong)arguments[0].ToUInt64())),
						CreateConvertTo<float>(enumType,(_, arguments) => checked((float)arguments[0].ToUInt64())),
						CreateConvertTo<double>(enumType,(_, arguments) => checked((double)arguments[0].ToUInt64())),
						CreateConvertTo<decimal>(enumType,(_, arguments) => checked((decimal)arguments[0].ToUInt64())),
	
						CreateConvertFrom<sbyte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToSByte()))),
						CreateConvertFrom<byte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToByte()))),
						CreateConvertFrom<short>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt16()))),
						CreateConvertFrom<ushort>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt16()))),
						CreateConvertFrom<int>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt32()))),
						CreateConvertFrom<uint>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt32()))),
						CreateConvertFrom<long>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToInt64()))),
						CreateConvertFrom<ulong>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, checked((long)arguments[0].ToUInt64()))),
					});
				}
			}
			private static MemberGroup CreateUncheckedConversions(Type enumType)
			{
				if (IsSigned(enumType))
				{
					return new MemberGroup(MemberGroupType.Method, new[] {
						CreateConvertTo<char>(enumType, (_, arguments) => unchecked((char)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<sbyte>(enumType,(_, arguments) => unchecked((sbyte)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<byte>(enumType,(_, arguments) => unchecked((byte)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<short>(enumType,(_, arguments) => unchecked((short)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<ushort>(enumType,(_, arguments) => unchecked((ushort)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<int>(enumType,(_, arguments) => unchecked((int)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<uint>(enumType,(_, arguments) => unchecked((uint)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<long>(enumType,(_, arguments) => unchecked((long)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<ulong>(enumType,(_, arguments) => unchecked((ulong)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<float>(enumType,(_, arguments) => unchecked((float)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<double>(enumType,(_, arguments) => unchecked((double)arguments[0].ToInt64(uncheckedConversion: true))),
						CreateConvertTo<decimal>(enumType,(_, arguments) => unchecked((decimal)arguments[0].ToInt64(uncheckedConversion: true))),
	
						CreateConvertFrom<sbyte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToSByte(uncheckedConversion: true)))),
						CreateConvertFrom<byte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToByte(uncheckedConversion: true)))),
						CreateConvertFrom<short>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt16(uncheckedConversion: true)))),
						CreateConvertFrom<ushort>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt16(uncheckedConversion: true)))),
						CreateConvertFrom<int>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt32(uncheckedConversion: true)))),
						CreateConvertFrom<uint>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt32(uncheckedConversion: true)))),
						CreateConvertFrom<long>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt64(uncheckedConversion: true)))),
						CreateConvertFrom<ulong>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt64(uncheckedConversion: true)))),
					});
				}
				else
				{
					return new MemberGroup(MemberGroupType.Method, new[] {
						CreateConvertTo<char>(enumType, (_, arguments) => unchecked((char)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<sbyte>(enumType,(_, arguments) => unchecked((sbyte)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<byte>(enumType,(_, arguments) => unchecked((byte)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<short>(enumType,(_, arguments) => unchecked((short)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<ushort>(enumType,(_, arguments) => unchecked((ushort)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<int>(enumType,(_, arguments) => unchecked((int)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<uint>(enumType,(_, arguments) => unchecked((uint)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<long>(enumType,(_, arguments) => unchecked((long)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<ulong>(enumType,(_, arguments) => unchecked((ulong)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<float>(enumType,(_, arguments) => unchecked((float)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<double>(enumType,(_, arguments) => unchecked((double)arguments[0].ToUInt64(uncheckedConversion: true))),
						CreateConvertTo<decimal>(enumType,(_, arguments) => unchecked((decimal)arguments[0].ToUInt64(uncheckedConversion: true))),
	
						CreateConvertFrom<sbyte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToSByte(uncheckedConversion: true)))),
						CreateConvertFrom<byte>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToByte(uncheckedConversion: true)))),
						CreateConvertFrom<short>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt16(uncheckedConversion: true)))),
						CreateConvertFrom<ushort>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt16(uncheckedConversion: true)))),
						CreateConvertFrom<int>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt32(uncheckedConversion: true)))),
						CreateConvertFrom<uint>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt32(uncheckedConversion: true)))),
						CreateConvertFrom<long>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToInt64(uncheckedConversion: true)))),
						CreateConvertFrom<ulong>(enumType,(_, arguments) => VariableValue.FromEnum(enumType, unchecked((long)arguments[0].ToUInt64(uncheckedConversion: true)))),
					});
				}
			}
			private static MemberGroup[] CreateBinaryOperations(Type enumType)
			{
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				var binaryOperations = new MemberGroup[lastBinaryOperation + 1];
				binaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() & arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() | arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() ^ arguments[1].ToInt64()));
	
				binaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() * arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() * arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() / arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() / arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() % arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() + arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() + arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() - arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() - arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() << arguments[1].ToInt32()));
				binaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, arguments[0].ToInt64() >> arguments[1].ToInt32()));
	
				binaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() > arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() >= arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() < arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() <= arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() == arguments[1].ToInt64()));
				binaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation(typeof(bool), (_, arguments) => (bool)(arguments[0].ToInt64() != arguments[1].ToInt64()));
				return binaryOperations;
			}
			private static MemberGroup[] CreateUnaryOperations(Type enumType)
			{
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				var unaryOperations = new MemberGroup[lastUnaryOperation + 1];
				unaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, unchecked(+arguments[0].ToInt64())));
				unaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, unchecked(-arguments[0].ToInt64())));
				unaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, checked(-arguments[0].ToInt64())));
				unaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation(enumType, (_, arguments) => VariableValue.FromEnum(enumType, unchecked((Int64)~arguments[0].ToUInt64())));
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
				return unaryOperations;
			}
	
			private static bool IsSigned(Type enumType)
			{
				var underlyingType = Enum.GetUnderlyingType(enumType);
				return underlyingType == typeof(sbyte) || underlyingType == typeof(short) || underlyingType == typeof(int) || underlyingType == typeof(long);
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class ExpressionBuildHelper
		{
			private static readonly string[] PositionNumbers = Enumerable.Range(0, 64).Select(p => p.ToString()).ToArray();
			private static readonly IReadOnlyDictionary<string, FormulaExpression> EmptyArguments = new Dictionary<string, FormulaExpression>();
	
			public static FormulaExpression GetExpression(IReadOnlyDictionary<string, object> expressionObj, string propertyName, bool optional = false)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue) &&
					TryGetExpressionDictionary(propertyValue, out var propertyValueExpressionObj))
				{
					return FormulaExpression.Create(propertyValueExpressionObj);
				}
	
				if (optional)
				{
					return null;
				}
				else
				{
					throw FormulaException.MissingRequiredAttributeInExpression(propertyName);
				}
			}
			public static string GetString(IReadOnlyDictionary<string, object> expressionObj, string propertyName, bool optional = false)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue) &&
					propertyValue is string propertyValueString)
				{
					return propertyValueString;
				}
	
				if (optional)
				{
					return null;
				}
				else
				{
					throw FormulaException.MissingRequiredAttributeInExpression(propertyName);
				}
			}
			public static object GetAnyValue(IReadOnlyDictionary<string, object> expressionObj, string propertyName, bool optional = false)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue))
				{
					return propertyValue;
				}
	
				if (optional)
				{
					return null;
				}
				else
				{
					throw FormulaException.MissingRequiredAttributeInExpression(propertyName);
				}
			}
			public static bool? GetBoolean(IReadOnlyDictionary<string, object> expressionObj, string propertyName, bool optional = false)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue) &&
					propertyValue is bool propertyValueBool)
				{
					return propertyValueBool;
				}
	
				if (optional)
				{
					return null;
				}
				else
				{
					throw FormulaException.MissingRequiredAttributeInExpression(propertyName);
				}
			}
			public static FormulaTypeReference GetTypeRef(IReadOnlyDictionary<string, object> expressionObj, string propertyName, bool optional = false)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue))
				{
					if (propertyValue is string plainName)
					{
						return new FormulaTypeReference(plainName);
					}
					else if (TryGetExpressionDictionary(propertyValue, out var propertyValueExpressionObj))
					{
						return new FormulaTypeReference(propertyValueExpressionObj);
					}
				}
	
				if (optional)
				{
					return null;
				}
				else
				{
					throw FormulaException.MissingRequiredAttributeInExpression(propertyName);
				}
			}
			public static IReadOnlyList<FormulaTypeReference> GetTypeRefArguments(IReadOnlyDictionary<string, object> expressionObj, string propertyName)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue) &&
					TryGetExpressionDictionary(propertyValue, out var propertyValueExpressionObj))
				{
					var arguments = new List<FormulaTypeReference>(propertyValueExpressionObj.Count);
					for (var i = 0; i < propertyValueExpressionObj.Count; i++)
					{
						var argumentIndex = GetIndexAsString(i);
						arguments.Add(GetTypeRef(propertyValueExpressionObj, argumentIndex, optional: false));
					}
					return arguments;
				}
	
				return Array.Empty<FormulaTypeReference>();
			}
			public static IReadOnlyDictionary<string, FormulaExpression> GetArguments(IReadOnlyDictionary<string, object> expressionObj, string propertyName)
			{
				if (expressionObj.TryGetValue(propertyName, out var propertyValue) &&
					TryGetExpressionDictionary(propertyValue, out var propertyValueExpressionObj))
				{
					var arguments = new Dictionary<string, FormulaExpression>(propertyValueExpressionObj.Count);
					foreach (var kv in propertyValueExpressionObj)
					{
						arguments[kv.Key] = GetExpression(propertyValueExpressionObj, kv.Key, optional: false);
					}
					return arguments;
				}
	
				return EmptyArguments;
			}
	
			private static bool TryGetExpressionDictionary(object value, out IReadOnlyDictionary<string, object> expressionObj)
			{
				if (value is IReadOnlyDictionary<string, object> readOnlyDictionary)
				{
					expressionObj = readOnlyDictionary;
					return true;
				}
				else if (value is IDictionary<string, object> dictionary)
				{
					expressionObj = new Dictionary<string, object>(dictionary);
					return true;
				}
	
				expressionObj = null;
				return false;
			}
			private static string GetIndexAsString(int index)
			{
				if (index >= 0 && index < 64)
				{
					return PositionNumbers[index];
				}
				return index.ToString();
			}
		}
	

		private sealed class Float32TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Float32TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast CompareOfFloatsByEqualityOperator
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<float>((_, arguments) => (float)unchecked(arguments[0].ToSingle() * arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<float>((_, arguments) => (float)checked(arguments[0].ToSingle() * arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<float>((_, arguments) => (float)unchecked(arguments[0].ToSingle() / arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<float>((_, arguments) => (float)checked(arguments[0].ToSingle() / arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<float>((_, arguments) => (double)Math.Pow(arguments[0].ToSingle(), arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<float>((_, arguments) => (float)(arguments[0].ToSingle() % arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<float>((_, arguments) => (float)unchecked(arguments[0].ToSingle() + arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<float>((_, arguments) => (float)checked(arguments[0].ToSingle() + arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<float>((_, arguments) => (float)unchecked(arguments[0].ToSingle() - arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<float>((_, arguments) => (float)checked(arguments[0].ToSingle() - arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() > arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() >= arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() < arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() <= arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() == arguments[1].ToSingle()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSingle() != arguments[1].ToSingle()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<float>((_, arguments) => (float)unchecked(+arguments[0].ToSingle()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<float>((_, arguments) => (float)unchecked(-arguments[0].ToSingle()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<float>((_, arguments) => (float)checked(-arguments[0].ToSingle()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToSingle())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToSingle())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToSingle())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToSingle())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToSingle())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToSingle())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToSingle())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToSingle())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToSingle())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToSingle())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToSingle())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToSingle())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToSingle())),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToSingle())),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToSingle())),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToSingle())),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToSingle())),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToSingle())),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToSingle())),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToSingle())),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToSingle())),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToSingle())),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToSingle())),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToSingle())),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast CompareOfFloatsByEqualityOperator
			}
			/// <inheritdoc />
			public Float32TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Single), isRequired: true),
								new ParameterDescription("value2", typeof(Single), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Single), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(Single), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class Float64TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Float64TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast CompareOfFloatsByEqualityOperator
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<double>((_, arguments) => (double)unchecked(arguments[0].ToDouble() * arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<double>((_, arguments) => (double)checked(arguments[0].ToDouble() * arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<double>((_, arguments) => (double)unchecked(arguments[0].ToDouble() / arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<double>((_, arguments) => (double)checked(arguments[0].ToDouble() / arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<double>((_, arguments) => (double)Math.Pow(arguments[0].ToDouble(), arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<double>((_, arguments) => (double)(arguments[0].ToDouble() % arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<double>((_, arguments) => (double)unchecked(arguments[0].ToDouble() + arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<double>((_, arguments) => (double)checked(arguments[0].ToDouble() + arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<double>((_, arguments) => (double)unchecked(arguments[0].ToDouble() - arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<double>((_, arguments) => (double)checked(arguments[0].ToDouble() - arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() > arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() >= arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() < arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() <= arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() == arguments[1].ToDouble()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToDouble() != arguments[1].ToDouble()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<double>((_, arguments) => (double)unchecked(+arguments[0].ToDouble()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<double>((_, arguments) => (double)unchecked(-arguments[0].ToDouble()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<double>((_, arguments) => (double)checked(-arguments[0].ToDouble()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToDouble())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToDouble())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToDouble())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToDouble())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToDouble())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToDouble())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToDouble())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToDouble())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToDouble())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToDouble())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToDouble())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToDouble())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToDouble())),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToDouble())),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToDouble())),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToDouble())),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToDouble())),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToDouble())),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToDouble())),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToDouble())),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToDouble())),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToDouble())),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToDouble())),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToDouble())),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast CompareOfFloatsByEqualityOperator
			}
			/// <inheritdoc />
			public Float64TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Double), isRequired: true),
								new ParameterDescription("value2", typeof(Double), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Double), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value1", typeof(Double), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class FormulaConstants
		{
			public const string EXPRESSION_TYPE_ATTRIBUTE = "expressionType";
			public const string EXPRESSION_ATTRIBUTE = "expression";
			public const string ARGUMENTS_ATTRIBUTE = "arguments";
			public const string LEFT_ATTRIBUTE = "left";
			public const string RIGHT_ATTRIBUTE = "right";
			public const string TEST_ATTRIBUTE = "test";
			public const string IF_TRUE_ATTRIBUTE = "ifTrue";
			public const string IF_FALSE_ATTRIBUTE = "ifFalse";
			public const string TYPE_ATTRIBUTE = "type";
			public const string VALUE_ATTRIBUTE = "value";
			public const string PROPERTY_OR_FIELD_NAME_ATTRIBUTE = "propertyOrFieldName";
			public const string NAME_ATTRIBUTE = "name";
			public const string USE_NULL_PROPAGATION_ATTRIBUTE = "useNullPropagation";
			// expression types
			public const string EXPRESSION_TYPE_PROPERTY_OR_FIELD = "PropertyOrField";
			public const string EXPRESSION_TYPE_MEMBER_RESOLVE = "MemberResolve";
			public const string EXPRESSION_TYPE_CONSTANT = "Constant";
			public const string EXPRESSION_TYPE_CONVERT = "Convert";
			public const string EXPRESSION_TYPE_CONVERT_CHECKED = "ConvertChecked";
			public const string EXPRESSION_TYPE_GROUP = "Group";
			public const string EXPRESSION_TYPE_INVOKE = "Invoke";
			public const string EXPRESSION_TYPE_LAMBDA = "Lambda";
			public const string EXPRESSION_TYPE_INDEX = "Index";
			public const string EXPRESSION_TYPE_UNCHECKED_SCOPE = "UncheckedScope";
			public const string EXPRESSION_TYPE_CHECKED_SCOPE = "CheckedScope";
			public const string EXPRESSION_TYPE_TYPE_OF = "TypeOf";
			public const string EXPRESSION_TYPE_DEFAULT = "Default";
			public const string EXPRESSION_TYPE_NEW = "New";
			public const string EXPRESSION_TYPE_NEW_ARRAY_BOUNDS = "NewArrayBounds";
			public const string EXPRESSION_TYPE_ADD = "Add";
			public const string EXPRESSION_TYPE_ADD_CHECKED = "AddChecked";
			public const string EXPRESSION_TYPE_SUBTRACT = "Subtract";
			public const string EXPRESSION_TYPE_SUBTRACT_CHECKED = "SubtractChecked";
			public const string EXPRESSION_TYPE_LEFT_SHIFT = "LeftShift";
			public const string EXPRESSION_TYPE_RIGHT_SHIFT = "RightShift";
			public const string EXPRESSION_TYPE_GREATER_THAN = "GreaterThan";
			public const string EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL = "GreaterThanOrEqual";
			public const string EXPRESSION_TYPE_LESS_THAN = "LessThan";
			public const string EXPRESSION_TYPE_LESS_THAN_OR_EQUAL = "LessThanOrEqual";
			public const string EXPRESSION_TYPE_NEGATE = "Negate";
			public const string EXPRESSION_TYPE_NEGATE_CHECKED = "NegateChecked";
			public const string EXPRESSION_TYPE_POWER = "Power";
			public const string EXPRESSION_TYPE_COMPLEMENT = "Complement";
			public const string EXPRESSION_TYPE_DIVIDE = "Divide";
			public const string EXPRESSION_TYPE_DIVIDE_CHECKED = "DivideChecked";
			public const string EXPRESSION_TYPE_MULTIPLY = "Multiply";
			public const string EXPRESSION_TYPE_MULTIPLY_CHECKED = "MultiplyChecked";
			public const string EXPRESSION_TYPE_MODULO = "Modulo";
			public const string EXPRESSION_TYPE_TYPE_IS = "TypeIs";
			public const string EXPRESSION_TYPE_TYPE_AS = "TypeAs";
			public const string EXPRESSION_TYPE_NOT = "Not";
			public const string EXPRESSION_TYPE_EQUAL = "Equal";
			public const string EXPRESSION_TYPE_NOT_EQUAL = "NotEqual";
			public const string EXPRESSION_TYPE_AND = "And";
			public const string EXPRESSION_TYPE_OR = "Or";
			public const string EXPRESSION_TYPE_EXCLUSIVE_OR = "ExclusiveOr";
			public const string EXPRESSION_TYPE_AND_ALSO = "AndAlso";
			public const string EXPRESSION_TYPE_OR_ELSE = "OrElse";
			public const string EXPRESSION_TYPE_COALESCE = "Coalesce";
			public const string EXPRESSION_TYPE_CONDITION = "Condition";
			public const string EXPRESSION_TYPE_UNARY_PLUS = "UnaryPlus";
			// known types
			public const string KNOWN_TYPE_ARRAY = "Array";
			public const string KNOWN_TYPE_SYSTEM_VOID = "System.Void";
			public const string KNOWN_TYPE_SYSTEM_CHAR = "System.Char";
			public const string KNOWN_TYPE_SYSTEM_BOOL = "System.Boolean";
			public const string KNOWN_TYPE_SYSTEM_BYTE = "System.Byte";
			public const string KNOWN_TYPE_SYSTEM_SBYTE = "System.SByte";
			public const string KNOWN_TYPE_SYSTEM_DECIMAL = "System.Decimal";
			public const string KNOWN_TYPE_SYSTEM_DATE_TIME = "System.DateTime";
			public const string KNOWN_TYPE_SYSTEM_TIME_SPAN = "System.TimeSpan";
			public const string KNOWN_TYPE_SYSTEM_DOUBLE = "System.Double";
			public const string KNOWN_TYPE_SYSTEM_SINGLE = "System.Single";
			public const string KNOWN_TYPE_SYSTEM_INT32 = "System.Int32";
			public const string KNOWN_TYPE_SYSTEM_UINT32 = "System.UInt32";
			public const string KNOWN_TYPE_SYSTEM_INT64 = "System.Int64";
			public const string KNOWN_TYPE_SYSTEM_UINT64 = "System.UInt64";
			public const string KNOWN_TYPE_SYSTEM_OBJECT = "System.Object";
			public const string KNOWN_TYPE_SYSTEM_INT16 = "System.Int16";
			public const string KNOWN_TYPE_SYSTEM_UINT16 = "System.UInt16";
			public const string KNOWN_TYPE_SYSTEM_STRING = "System.String";
			public const string KNOWN_TYPE_SYSTEM_TYPE = "System.Type";
			public const string KNOWN_TYPE_SYSTEM_ARRAY = "System.Array";
			// notations
			public const string NOTATION_TRUE_STRING = "true";
			public const string NOTATION_FALSE_STRING = "false";
			public const string NOTATION_NULL_STRING = "null";
			//
	
			public static readonly Dictionary<string, string> TypeAliases = new Dictionary<string, string>(StringComparer.Ordinal) {
				{ "void", KNOWN_TYPE_SYSTEM_VOID },
				{ "char", KNOWN_TYPE_SYSTEM_CHAR },
				{ "bool", KNOWN_TYPE_SYSTEM_BOOL },
				{ "byte", KNOWN_TYPE_SYSTEM_BYTE },
				{ "sbyte", KNOWN_TYPE_SYSTEM_SBYTE },
				{ "decimal", KNOWN_TYPE_SYSTEM_DECIMAL },
				{ "double", KNOWN_TYPE_SYSTEM_DOUBLE },
				{ "float", KNOWN_TYPE_SYSTEM_SINGLE },
				{ "int", KNOWN_TYPE_SYSTEM_INT32 },
				{ "uint", KNOWN_TYPE_SYSTEM_UINT32 },
				{ "long", KNOWN_TYPE_SYSTEM_INT64 },
				{ "ulong", KNOWN_TYPE_SYSTEM_UINT64 },
				{ "object", KNOWN_TYPE_SYSTEM_OBJECT },
				{ "short", KNOWN_TYPE_SYSTEM_INT16 },
				{ "ushort", KNOWN_TYPE_SYSTEM_UINT16 },
				{ "string", KNOWN_TYPE_SYSTEM_STRING },
			};
	
			public static readonly Dictionary<string, string> SystemTypes = new Dictionary<string, string>(StringComparer.Ordinal) {
				{ "Void", KNOWN_TYPE_SYSTEM_VOID },
				{ "Char", KNOWN_TYPE_SYSTEM_CHAR },
				{ "Boolean", KNOWN_TYPE_SYSTEM_BOOL },
				{ "Byte", KNOWN_TYPE_SYSTEM_BYTE },
				{ "SByte", KNOWN_TYPE_SYSTEM_SBYTE },
				{ "Decimal", KNOWN_TYPE_SYSTEM_DECIMAL },
				{ "Double", KNOWN_TYPE_SYSTEM_DOUBLE },
				{ "Single", KNOWN_TYPE_SYSTEM_SINGLE },
				{ "Int32", KNOWN_TYPE_SYSTEM_INT32 },
				{ "UInt32", KNOWN_TYPE_SYSTEM_UINT32 },
				{ "Int64", KNOWN_TYPE_SYSTEM_INT64 },
				{ "UInt64", KNOWN_TYPE_SYSTEM_UINT64 },
				{ "Object", KNOWN_TYPE_SYSTEM_OBJECT },
				{ "Int16", KNOWN_TYPE_SYSTEM_INT16 },
				{ "UInt16", KNOWN_TYPE_SYSTEM_UINT16 },
				{ "String", KNOWN_TYPE_SYSTEM_STRING },
				{ "Type", KNOWN_TYPE_SYSTEM_TYPE },
				{ "Array", KNOWN_TYPE_SYSTEM_ARRAY },
				{ "DateTime", KNOWN_TYPE_SYSTEM_DATE_TIME },
				{ "TimeSpan", KNOWN_TYPE_SYSTEM_TIME_SPAN },
			};
		}
	

		public class FormulaException : Exception
		{
			public FormulaException(string message) : base(message)
			{
	
			}
			public FormulaException(string message, Exception innerException) : base(message, innerException)
			{
	
			}
	
			public static Exception MissingBinaryOperation(BinaryOperationType binaryOperation, VariableValue leftValue, VariableValue rightValue)
			{
				throw new FormulaException($"Missing binary operation '{binaryOperation}' between types '{CSharpName(leftValue.Type)}' and '{CSharpName(rightValue.Type)}'.");
			}
			public static Exception MissingUnaryOperation(UnaryOperationType unaryOperation, VariableValue target)
			{
				throw new FormulaException($"Missing unary operation '{unaryOperation}' on type '{CSharpName(target.Type)}'.");
			}
			public static Exception UnknownUnaryExpression(string expressionType)
			{
				throw new FormulaException($"Unknown unary expression type '{expressionType}'.");
			}
			public static Exception UnknownBinaryExpression(string expressionType)
			{
				throw new FormulaException($"Unknown binary expression type '{expressionType}'.");
			}
			public static Exception UnknownExpressionType(string expressionType)
			{
				throw new FormulaException($"Unknown expression type '{expressionType}'.");
			}
			public static Exception CantAccessMemberOnNull(string name)
			{
				throw new FormulaException($"Can't access member with name '{name}' on null value.");
			}
			public static Exception CantFindMember(ITypeDescription targetType, string name)
			{
				throw new FormulaException($"Can't find member with name '{name}' on type '{targetType}'.");
			}
			public static Exception UnableToResolveGlobalName(string name)
			{
				throw new FormulaException($"Unable to find parameter with name '{name}' or type starting from this name or member on global object.");
			}
			public static Exception CanConvertNullToType(VariableValue value, ITypeDescription targetType)
			{
				throw new FormulaException($"Can't convert null value to type '{targetType}'.");
			}
			public static VariableValue WrongJunctionOperands(string junctionOperation, VariableValue leftValue, VariableValue rightValue)
			{
				throw new FormulaException($"There is no '{junctionOperation}' between '{CSharpName(leftValue.Type)}' and '{CSharpName(rightValue.Type)}' types.");
			}
			public static Exception CantFindIndexer(ITypeDescription targetType, Dictionary<string, VariableValue> indexArguments)
			{
				throw new FormulaException($"Can't find indexer on type '{targetType}' accepting {indexArguments.Count} arguments.");
			}
			public static Exception CantIndexOnNull()
			{
				throw new FormulaException("Can't apply indexing to null value.");
			}
			public static Exception CantCallOnNull()
			{
				throw new FormulaException("Can't invoke on null value.");
			}
			public static Exception UnableToInvokeNonMethodOrDelegate(VariableValue variableValue)
			{
				throw new FormulaException($"Can invoke on non-method member or non-delegate value of type '{CSharpName(variableValue.Type)}'.");
			}
			public static Exception InvalidConditionResultType(VariableValue testValue)
			{
				throw new FormulaException($"Can't use value of type '{CSharpName(testValue.Type)}' for condition result. A boolean value is expected.");
			}
			public static Exception CanConvertToType(VariableValue value, ITypeDescription targetTypeDescription)
			{
				throw new FormulaException($"There is no explicit/implicit conversion exists from '{CSharpName(value.Type)}' type to '{targetTypeDescription}' type.");
			}
			public static Exception UnableToBindMethodToParameters(string name, ITypeDescription targetTypeDescription, Dictionary<string, VariableValue> callArguments)
			{
				if (callArguments.Count != 0)
				{
					throw new FormulaException($"Can't find method with name '{name}' on type '{targetTypeDescription}' accepting {callArguments.Count} arguments of types '{string.Join(", ", callArguments.Values.Select(v => CSharpName(v.Type)))}'.");
				}
				else
				{
					throw new FormulaException($"Can't find method with name '{name}' on type '{targetTypeDescription}' accepting no arguments'.");
				}
			}
			public static Exception UnableToBindConstructorToParameters(ITypeDescription targetTypeDescription, Dictionary<string, VariableValue> callArguments)
			{
				if (callArguments.Count != 0)
				{
					throw new FormulaException($"Can't find constructor on type '{targetTypeDescription}' accepting arguments of types '{string.Join(", ", callArguments.Values.Select(v => CSharpName(v.Type)))}'.");
				}
				else
				{
					throw new FormulaException($"Can't find constructor on type '{targetTypeDescription}' accepting no arguments'.");
				}
			}
			public static Exception CanAccessMethodOrConstructorGroup(string name, ITypeDescription targetTypeDescription)
			{
				throw new FormulaException($"Can't access method group with name '{name}' on type '{targetTypeDescription}' in this context.");
			}
			public static Exception UnableToResolveType(FormulaTypeReference typeReference)
			{
				throw new FormulaException($"Can't find type with name '{typeReference}'. Add this type to list of known types before using it.");
			}
			public static Exception InvalidLambdaArgument(FormulaExpression lambdaArgument)
			{
				throw new FormulaException($"Invalid lambda argument expression '{lambdaArgument}'({lambdaArgument.GetType().Name}) while plain argument name is expected.");
			}
			public static Exception MissingRequiredAttributeInExpression(string propertyName)
			{
				throw new FormulaException($"Missing required attribute '{propertyName}' on expression object.");
			}
	
			private static string CSharpName(Type type)
			{
				return CSharpNameUtils.GetCSharpFullNameWithGenerics(type);
			}
		}
	

		public class FormulaExecutionContext
		{
			public bool AutoNullPropagation { get; }
			public VariableValue Global { get; }
			public IReadOnlyDictionary<string, VariableValue> Arguments { get; }
			public IFormulaTypeResolver TypeResolver { get; }
	
			public FormulaExecutionContext
			(
				IReadOnlyDictionary<string, VariableValue> arguments,
				VariableValue global = default,
				bool autoNullPropagation = false,
				IFormulaTypeResolver typeResolver = null)
			{
				this.Arguments = arguments;
				this.Global = global;
				this.AutoNullPropagation = autoNullPropagation;
				this.TypeResolver = typeResolver ?? KnownFormulaTypeResolver.Default;
			}
		}
	

		public abstract class FormulaExpression
		{
			public static FormulaExpression Create(IReadOnlyDictionary<string, object> expressionObj, Type expectedType = null)
			{
				var expressionType = ExpressionBuildHelper.GetString(expressionObj, FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE);
				FormulaExpression expression;
				switch (expressionType)
				{
	
					case FormulaConstants.EXPRESSION_TYPE_PROPERTY_OR_FIELD:
					case FormulaConstants.EXPRESSION_TYPE_MEMBER_RESOLVE: expression = new MemberExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_INVOKE: expression = new InvokeExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_LAMBDA: expression = new LambdaExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_INDEX: expression = new IndexExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_TYPE_OF: expression = new TypeOfExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_CONSTANT: expression = new ConstantExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_DEFAULT: expression = new DefaultExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_NEW: expression = new NewExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_NEW_ARRAY_BOUNDS: expression = new NewArrayBoundExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_ADD:
					case FormulaConstants.EXPRESSION_TYPE_ADD_CHECKED:
					case FormulaConstants.EXPRESSION_TYPE_SUBTRACT:
					case FormulaConstants.EXPRESSION_TYPE_SUBTRACT_CHECKED:
					case FormulaConstants.EXPRESSION_TYPE_LEFT_SHIFT:
					case FormulaConstants.EXPRESSION_TYPE_RIGHT_SHIFT:
					case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN:
					case FormulaConstants.EXPRESSION_TYPE_GREATER_THAN_OR_EQUAL:
					case FormulaConstants.EXPRESSION_TYPE_LESS_THAN:
					case FormulaConstants.EXPRESSION_TYPE_LESS_THAN_OR_EQUAL:
					case FormulaConstants.EXPRESSION_TYPE_POWER:
					case FormulaConstants.EXPRESSION_TYPE_DIVIDE:
					case FormulaConstants.EXPRESSION_TYPE_DIVIDE_CHECKED:
					case FormulaConstants.EXPRESSION_TYPE_MULTIPLY:
					case FormulaConstants.EXPRESSION_TYPE_MULTIPLY_CHECKED:
					case FormulaConstants.EXPRESSION_TYPE_MODULO:
					case FormulaConstants.EXPRESSION_TYPE_EQUAL:
					case FormulaConstants.EXPRESSION_TYPE_NOT_EQUAL:
					case FormulaConstants.EXPRESSION_TYPE_AND:
					case FormulaConstants.EXPRESSION_TYPE_OR:
					case FormulaConstants.EXPRESSION_TYPE_EXCLUSIVE_OR:
					case FormulaConstants.EXPRESSION_TYPE_AND_ALSO:
					case FormulaConstants.EXPRESSION_TYPE_OR_ELSE:
					case FormulaConstants.EXPRESSION_TYPE_COALESCE: expression = new BinaryExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_NEGATE:
					case FormulaConstants.EXPRESSION_TYPE_NEGATE_CHECKED:
					case FormulaConstants.EXPRESSION_TYPE_NOT:
					case FormulaConstants.EXPRESSION_TYPE_COMPLEMENT: expression = new UnaryExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_TYPE_IS: expression = new TypeIsExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_CONVERT:
					case FormulaConstants.EXPRESSION_TYPE_CONVERT_CHECKED:
					case FormulaConstants.EXPRESSION_TYPE_TYPE_AS: expression = new ConvertExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_CONDITION: expression = new ConditionExpression(expressionObj); break;
					case FormulaConstants.EXPRESSION_TYPE_GROUP:
					case FormulaConstants.EXPRESSION_TYPE_UNCHECKED_SCOPE:
					case FormulaConstants.EXPRESSION_TYPE_CHECKED_SCOPE:
					case FormulaConstants.EXPRESSION_TYPE_UNARY_PLUS: expression = new UnaryExpression(expressionObj); break;
					default: throw FormulaException.UnknownExpressionType(expressionType);
				}
	
				if (expectedType != null)
				{
					expression = new ConvertExpression(expression, expectedType, checkedScope: false);
				}
	
				return expression;
			}
	
			public static void RegisterFunc<Arg1T, Arg2T, Arg3T, Arg4T, ResultT>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Func<Arg1T, Arg2T, Arg3T, Arg4T, ResultT>(default, default, default); } }
			public static void RegisterFunc<Arg1T, Arg2T, Arg3T, ResultT>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Func<Arg1T, Arg2T, Arg3T, ResultT>(default, default, default); } }
			public static void RegisterFunc<Arg1T, Arg2T, ResultT>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Func<Arg1T, Arg2T, ResultT>(default, default, default); } }
			public static void RegisterFunc<Arg1T, ResultT>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Func<Arg1T, ResultT>(default, default, default); } }
			public static void RegisterFunc<ResultT>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Func<ResultT>(default, default, default); } }
	
			public static void RegisterAction<Arg1T, Arg2T, Arg3T, Arg4T>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Action<Arg1T, Arg2T, Arg3T, Arg4T>(default, default, default); } }
			public static void RegisterAction<Arg1T, Arg2T, Arg3T>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Action<Arg1T, Arg2T, Arg3T>(default, default, default); } }
			public static void RegisterAction<Arg1T, Arg2T>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Action<Arg1T, Arg2T>(default, default, default); } }
			public static void RegisterAction<Arg1T>() { if (typeof(object).FullName == string.Empty) { LambdaFunctions.Action<Arg1T>(default, default, default); } }
	
			public abstract VariableValue Execute(FormulaExecutionContext context);
	
			public abstract void BuildDebugView(StringBuilder stringBuilder);
	
			/// <inheritdoc />
			public sealed override string ToString()
			{
				var debugViewBuilder = new StringBuilder();
				this.BuildDebugView(debugViewBuilder);
				return debugViewBuilder.ToString();
			}
		}
	

		[Flags]
		public enum FormulaOptions
		{
			None = 0,
			UseDynamicMethods = 0x1 << 0,
			AllowReflectionApi = 0x1 << 1,
		}
	

		public sealed class FormulaTypeReference
		{
			public static readonly FormulaTypeReference Empty = new FormulaTypeReference(string.Empty, null, null);
			private static readonly IReadOnlyList<FormulaTypeReference> EmptyTypeReferences = Array.Empty<FormulaTypeReference>();
	
			private readonly FormulaTypeReference expression;
			private readonly IReadOnlyList<FormulaTypeReference> typeArguments;
			private string fullName;
			private string displayName;
	
			public string Name { get; }
			public string FullName => this.fullName ?? (this.fullName = this.GetFullName());
			public IReadOnlyList<FormulaTypeReference> TypeArguments => this.typeArguments;
			public bool IsEmpty => string.IsNullOrEmpty(this.Name) && this.expression == null && this.typeArguments.Count == 0;
	
			public FormulaTypeReference(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.Name = ExpressionBuildHelper.GetString(expressionObj, FormulaConstants.NAME_ATTRIBUTE);
				this.expression = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE, optional: true);
				this.typeArguments = ExpressionBuildHelper.GetTypeRefArguments(expressionObj, FormulaConstants.ARGUMENTS_ATTRIBUTE);
	
				if (this.expression != null && this.expression.TypeArguments.Count > 0)
				{
					this.typeArguments = this.expression.TypeArguments.Concat(this.typeArguments).ToArray();
				}
	
				this.displayName = string.Empty;
			}
			public FormulaTypeReference(string name, IReadOnlyList<FormulaTypeReference> typeArguments = null, FormulaTypeReference baseTypeReference = null)
			{
				if (name == null) throw new ArgumentNullException(nameof(name));
	
				this.Name = name;
				this.typeArguments = typeArguments ?? EmptyTypeReferences;
				this.expression = baseTypeReference;
	
				if (this.expression != null && this.expression.TypeArguments.Count > 0)
				{
					this.typeArguments = this.expression.TypeArguments.Concat(this.typeArguments).ToArray();
				}
			}
			public FormulaTypeReference(Type type)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				if (type.IsArray)
				{
					this.Name = nameof(Array);
					this.expression = new FormulaTypeReference(typeof(Array).Namespace);
					this.typeArguments = new[] {
						new FormulaTypeReference(type.GetElementType() ?? typeof(object))
					};
				}
				else
				{
					this.Name = type.Name;
					this.typeArguments = EmptyTypeReferences;
	
					if (type.DeclaringType != null)
					{
						this.expression = new FormulaTypeReference(type.DeclaringType);
					}
					else if (!string.IsNullOrEmpty(type.Namespace))
					{
						this.expression = new FormulaTypeReference(type.Namespace);
					}
	
					if (type.IsGenericType)
					{
						var genericArguments = type.GetGenericArguments();
						if (type.IsGenericTypeDefinition)
						{
							this.typeArguments = Array.ConvertAll(genericArguments, _ => Empty);
						}
						else
						{
							this.typeArguments = Array.ConvertAll(genericArguments, genericArgument => new FormulaTypeReference(genericArgument));
						}
					}
				}
			}
	
			private StringBuilder BuildFullName(StringBuilder nameBuilder, bool writeGenerics)
			{
				if (nameBuilder == null) throw new ArgumentNullException(nameof(nameBuilder));
	
				if (this.expression != null)
				{
					this.expression.BuildFullName(nameBuilder, writeGenerics);
					nameBuilder.Append(".");
				}
	
				nameBuilder.Append(this.Name);
				if (this.typeArguments.Count > 0 && writeGenerics)
				{
					nameBuilder.Append("<");
					foreach (var genericArgument in this.typeArguments)
					{
						genericArgument.BuildFullName(nameBuilder, writeGenerics = true);
						nameBuilder.Append(", ");
					}
					nameBuilder.Length -= 2;
					nameBuilder.Append(">");
				}
				return nameBuilder;
			}
	
			private string GetFullName()
			{
				return this.BuildFullName(new StringBuilder(), writeGenerics: false).ToString();
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				if (this.typeArguments.Count == 0 &&
					this.expression == null)
				{
					if (FormulaConstants.SystemTypes.TryGetValue(this.Name, out var systemTypeName) ||
						FormulaConstants.TypeAliases.TryGetValue(this.Name, out systemTypeName))
					{
						return systemTypeName;
					}
	
					return this.Name;
				}
				else if (!string.IsNullOrEmpty(this.displayName))
				{
					return this.displayName;
				}
				else if (this.expression == null && this.Name == FormulaConstants.KNOWN_TYPE_ARRAY && this.typeArguments.Count == 1)
				{
					return this.displayName = this.typeArguments[0] + "[]";
				}
				else
				{
					var nameBuilder = this.BuildFullName(new StringBuilder(), writeGenerics: true);
					return this.displayName = nameBuilder.ToString();
				}
			}
		}
	

		public sealed class GenericConstraint
		{
			private readonly Type[] requiredTypes;
			private readonly GenericParameterAttributes otherConstraints;
	
			public GenericConstraint(Type genericArgument)
			{
				if (genericArgument == null) throw new ArgumentNullException(nameof(genericArgument));
				if (!genericArgument.IsGenericParameter) throw new ArgumentException("Type should be generic parameter.", nameof(genericArgument));
	
				this.requiredTypes = genericArgument.GetGenericParameterConstraints();
				this.otherConstraints = genericArgument.GenericParameterAttributes;
			}
	
			public bool IsMatching(Type type)
			{
				// check required types
				if (this.requiredTypes != null && this.requiredTypes.Length > 0)
				{
					foreach (var requiredType in this.requiredTypes)
					{
						if (!requiredType.IsAssignableFrom(type))
						{
							return false;
						}
					}
				}
	
				// check other
				if ((this.otherConstraints & GenericParameterAttributes.ReferenceTypeConstraint) != 0 && type.IsValueType)
				{
					return false;
				}
	
				if ((this.otherConstraints & GenericParameterAttributes.NotNullableValueTypeConstraint) != 0 &&
					(Nullable.GetUnderlyingType(type) != null || !type.IsValueType))
				{
					return false;
				}
	
				if ((this.otherConstraints & GenericParameterAttributes.DefaultConstructorConstraint) != 0 &&
					type.GetConstructor(BindingFlags.Public | BindingFlags.Instance, null, Type.EmptyTypes, null) == null)
				{
					return false;
				}
	
				return true;
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				return $"Constraint, Types: {string.Join(", ", this.requiredTypes.Select(CSharpNameUtils.GetCSharpFullNameWithGenerics))}, Other: {this.otherConstraints}";
			}
		}
	

		public interface IFormulaTypeResolver
		{
			ITypeDescription GetTypeDescription(Type type);
			ITypeDescription GetTypeDescription(FormulaTypeReference typeReference);
	
			bool TryGetTypeDescription(FormulaTypeReference typeReference, out ITypeDescription typeDescription);
		}
	

		private class IndexExpression : FormulaExpression, INullPropagationExpression
		{
			private readonly IReadOnlyDictionary<string, FormulaExpression> arguments;
			private readonly FormulaExpression expression;
			private readonly bool useNullPropagation;
	
	
			/// <inheritdoc />
			public bool IsNullPropagationEnabled
			{
				get
				{
					if (this.useNullPropagation)
					{
						return true;
					}
	
					return (this.expression as INullPropagationExpression)?.IsNullPropagationEnabled ?? false;
				}
			}
	
			public IndexExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.arguments = ExpressionBuildHelper.GetArguments(expressionObj, FormulaConstants.ARGUMENTS_ATTRIBUTE);
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE, optional: false);
				this.useNullPropagation = ExpressionBuildHelper.GetBoolean(expressionObj, FormulaConstants.USE_NULL_PROPAGATION_ATTRIBUTE, optional: true)
					.GetValueOrDefault();
			}
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var target = this.expression.Execute(context);
				var isNullPropagation = context.AutoNullPropagation || this.IsNullPropagationEnabled;
	
				if (target.IsNull)
				{
					if (isNullPropagation)
					{
						return VariableValue.Null;
					}
					else
					{
						throw FormulaException.CantIndexOnNull();
					}
				}
	
				var indexArguments = new Dictionary<string, VariableValue>();
				foreach (var index in this.arguments)
				{
					indexArguments[index.Key] = index.Value.Execute(context);
				}
	
				var targetTypeDescriptor = context.TypeResolver.GetTypeDescription(target.Type);
				if (!targetTypeDescriptor.TryGetIndexer(indexArguments.Count, out var indexAccessor))
				{
					throw FormulaException.CantFindIndexer(targetTypeDescriptor, indexArguments);
				}
	
				if (indexAccessor.TryInvoke(target, indexArguments, expectedType: null, typeArguments: null, out var result))
				{
					return result;
				}
				throw FormulaException.CantFindIndexer(targetTypeDescriptor, indexArguments);
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				this.expression.BuildDebugView(stringBuilder);
				if (this.useNullPropagation)
				{
					stringBuilder.Append("?");
				}
				stringBuilder.Append("[");
				foreach (var argument in this.arguments)
				{
					if (!argument.Key.All(char.IsDigit))
					{
						stringBuilder.Append(argument.Key).Append(": ");
					}
					argument.Value.BuildDebugView(stringBuilder);
					stringBuilder.Append(", ");
				}
	
				if (this.arguments.Count > 0)
				{
					stringBuilder.Length -= 2;
				}
	
				stringBuilder.Append("]");
			}
		}
	

		private sealed class Int16TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Int16TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt16() & arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt16() | arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt16() ^ arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt16() * arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() * arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt16() / arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() / arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToInt16(), arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt16() % arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt16() + arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() + arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt16() - arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() - arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt16() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() > arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() >= arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() < arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() <= arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() == arguments[1].ToInt16()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt16() != arguments[1].ToInt16()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToInt16()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToInt16()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToInt16()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToInt16()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToInt16())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToInt16())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToInt16())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToInt16())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToInt16())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToInt16())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToInt16())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToInt16())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToInt16())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToInt16())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToInt16())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToInt16())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToInt16(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToInt16(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public Int16TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Int16), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(Int16), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Int16), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(Int16), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class Int32TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Int32TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt32() & arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt32() | arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt32() ^ arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt32() * arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() * arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt32() / arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() / arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToInt32(), arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToInt32() % arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt32() + arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() + arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToInt32() - arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() - arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() << arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToInt32() >> arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() > arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() >= arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() < arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() <= arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() == arguments[1].ToInt32()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt32() != arguments[1].ToInt32()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToInt32()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToInt32()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToInt32()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToInt32()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToInt32())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToInt32())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToInt32())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToInt32())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToInt32())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToInt32())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToInt32())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToInt32())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToInt32())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToInt32())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToInt32())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToInt32())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToInt32(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToInt32(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public Int32TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Int32), isRequired: true),
								new ParameterDescription("value2", typeof(Int32), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Int32), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new [] {
						new ParameterDescription("value", typeof(Int32), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class Int64TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Int64TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<long>((_, arguments) => (long)(arguments[0].ToInt64() & arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<long>((_, arguments) => (long)(arguments[0].ToInt64() | arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<long>((_, arguments) => (long)(arguments[0].ToInt64() ^ arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<long>((_, arguments) => (long)unchecked(arguments[0].ToInt64() * arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() * arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<long>((_, arguments) => (long)unchecked(arguments[0].ToInt64() / arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() / arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<long>((_, arguments) => (double)Math.Pow(arguments[0].ToInt64(), arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<long>((_, arguments) => (long)(arguments[0].ToInt64() % arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<long>((_, arguments) => (long)unchecked(arguments[0].ToInt64() + arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() + arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<long>((_, arguments) => (long)unchecked(arguments[0].ToInt64() - arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() - arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<long>((_, arguments) => (long)checked(arguments[0].ToInt64() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() > arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() >= arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() < arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() <= arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() == arguments[1].ToInt64()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToInt64() != arguments[1].ToInt64()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<long>((_, arguments) => (long)unchecked(+arguments[0].ToInt64()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<long>((_, arguments) => (long)unchecked(-arguments[0].ToInt64()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<long>((_, arguments) => (long)checked(-arguments[0].ToInt64()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<long>((_, arguments) => (long)unchecked(~arguments[0].ToInt64()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToInt64())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToInt64())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToInt64())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToInt64())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToInt64())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToInt64())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToInt64())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToInt64())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToInt64())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToInt64())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToInt64())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToInt64())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToInt64(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToInt64(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public Int64TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Int64), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(Int64), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Int64), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new [] {
						new ParameterDescription("value", typeof(Int64), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class Int8TypeDescription : ReflectionTypeDescription
		{
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static Int8TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToSByte() & arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToSByte() | arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToSByte() ^ arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToSByte() * arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() * arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToSByte() / arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() / arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToSByte(), arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToSByte() % arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToSByte() + arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() + arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToSByte() - arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() - arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToSByte() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() > arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() >= arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() < arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() <= arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() == arguments[1].ToSByte()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToSByte() != arguments[1].ToSByte()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToSByte()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToSByte()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToSByte()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToSByte()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToSByte())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToSByte())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToSByte())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToSByte())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToSByte())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToSByte())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToSByte())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToSByte())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToSByte())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToSByte())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToSByte())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToSByte())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToSByte(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToSByte(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public Int8TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(SByte), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(SByte), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(SByte), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(SByte), isRequired: true)
					});
			}
		}
	

		private interface INullPropagationExpression
		{
			bool IsNullPropagationEnabled { get; }
		}
	

		private class InvokeExpression : FormulaExpression, INullPropagationExpression
		{
			private readonly IReadOnlyDictionary<string, FormulaExpression> arguments;
			private readonly FormulaExpression expression;
	
			/// <inheritdoc />
			public bool IsNullPropagationEnabled => (this.expression as INullPropagationExpression)?.IsNullPropagationEnabled ?? false;
	
			public InvokeExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.arguments = ExpressionBuildHelper.GetArguments(expressionObj, FormulaConstants.ARGUMENTS_ATTRIBUTE);
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE, optional: false);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				string memberName;
				if (!(this.expression is MemberExpression targetMemberExpression))
				{
					// ex. (a + b)(param1, param2)
					return this.ExecutePlainInvoke(context);
				}
				else if (targetMemberExpression.TryGetTypeReferenceAndMemberName(out var typeReference, out memberName) &&
					context.TypeResolver.TryGetTypeDescription(typeReference, out var typeDescriptor))
				{
					// ex. System.Math.Add()
					return this.ExecuteStaticMethod(typeDescriptor, memberName, context);
				}
				if (targetMemberExpression.TryGetExpressionAndMemberName(out var memberExpression, out memberName))
				{
					// ex. my.hello();
					return this.ExecuteInstanceMethod(memberExpression, memberName, context);
				}
				else if (!context.Global.IsNull)
				{
					// ex. hello()
					var globalTypeDescriptor = context.TypeResolver.GetTypeDescription(context.Global.Type);
					if (globalTypeDescriptor.TryGetMember(targetMemberExpression.MemberName, out var memberAccessor))
					{
						return this.ExecuteAnyMethod(context.Global, globalTypeDescriptor, memberAccessor, context);
					}
					else if (globalTypeDescriptor.TryGetStaticMember(targetMemberExpression.MemberName, out memberAccessor))
					{
						return this.ExecuteAnyMethod(VariableValue.Null, globalTypeDescriptor, memberAccessor, context);
					}
				}
	
				return this.ExecutePlainInvoke(context);
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				this.expression.BuildDebugView(stringBuilder);
				stringBuilder.Append("(");
				foreach (var argument in this.arguments)
				{
					if (!argument.Key.All(char.IsDigit))
					{
						stringBuilder.Append(argument.Key).Append(": ");
					}
					argument.Value.BuildDebugView(stringBuilder);
					stringBuilder.Append(", ");
				}
	
				if (this.arguments.Count > 0)
				{
					stringBuilder.Length -= 2;
				}
	
				stringBuilder.Append(")");
			}
	
			private VariableValue ExecutePlainInvoke(FormulaExecutionContext context)
			{
				var isNullPropagation = context.AutoNullPropagation || this.IsNullPropagationEnabled;
				var target = this.expression.Execute(context);
				if (target.IsNull)
				{
					if (isNullPropagation)
					{
						return VariableValue.Null;
					}
					else
					{
						throw FormulaException.CantCallOnNull();
					}
				}
				var targetTypeDescriptor = context.TypeResolver.GetTypeDescription(target.Type);
				return this.InvokeDelegate(new VariableValue(target), targetTypeDescriptor, context);
			}
			private VariableValue ExecuteStaticMethod(ITypeDescription targetTypeDescription, string memberName, FormulaExecutionContext context)
			{
				if (!targetTypeDescription.TryGetStaticMember(memberName, out var memberAccessor))
				{
					throw FormulaException.CantFindMember(targetTypeDescription, memberName);
				}
	
				return this.ExecuteAnyMethod(VariableValue.Null, targetTypeDescription, memberAccessor, context);
			}
			private VariableValue ExecuteInstanceMethod(FormulaExpression memberExpression, string memberName, FormulaExecutionContext context)
			{
				var isNullPropagation = context.AutoNullPropagation || this.IsNullPropagationEnabled;
				var target = memberExpression.Execute(context);
				if (target.IsNull)
				{
					if (isNullPropagation)
					{
						return VariableValue.Null;
					}
					else
					{
						throw FormulaException.CantCallOnNull();
					}
				}
	
				var targetTypeDescriptor = context.TypeResolver.GetTypeDescription(target.Type);
				if (!targetTypeDescriptor.TryGetMember(memberName, out var memberAccessor))
				{
					throw FormulaException.CantFindMember(targetTypeDescriptor, memberName);
				}
	
				return this.ExecuteAnyMethod(target, targetTypeDescriptor, memberAccessor, context);
			}
			private VariableValue ExecuteAnyMethod(VariableValue target, ITypeDescription targetTypeDescription, MemberGroup memberAccessor, FormulaExecutionContext context)
			{
				var isNullPropagation = context.AutoNullPropagation || this.IsNullPropagationEnabled;
				if (memberAccessor.GroupType == MemberGroupType.Method)
				{
					return this.InvokeMethod(target, targetTypeDescription, memberAccessor, context, isDelegated: false);
				}
				else
				{
					memberAccessor.TryInvoke(target, callArguments: null, expectedType: null, typeArguments: null,out var delegateValue);
	
					if (delegateValue.IsNull)
					{
						if (isNullPropagation)
						{
							return VariableValue.Null;
						}
						else
						{
							throw FormulaException.CantCallOnNull();
						}
					}
					return this.InvokeDelegate(delegateValue, targetTypeDescription, context);
				}
			}
	
			private VariableValue InvokeDelegate(VariableValue delegateValue, ITypeDescription targetTypeDescription, FormulaExecutionContext context)
			{
				const string DELEGATE_INVOKE_METHOD = "Invoke";
	
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (delegateValue.IsNull) throw new ArgumentNullException(nameof(delegateValue));
	
				var delegateToCall = delegateValue.ToObject() as Delegate;
				if (delegateToCall == null)
				{
					throw FormulaException.UnableToInvokeNonMethodOrDelegate(delegateValue);
				}
	
				var delegateTypeDescriptor = context.TypeResolver.GetTypeDescription(delegateToCall.GetType());
				if (!delegateTypeDescriptor.TryGetMember(DELEGATE_INVOKE_METHOD, out var invokeMethodGroup))
				{
					throw FormulaException.CantFindMember(delegateTypeDescriptor, DELEGATE_INVOKE_METHOD);
				}
	
				return this.InvokeMethod(delegateValue, targetTypeDescription ?? delegateTypeDescriptor, invokeMethodGroup, context, isDelegated: true);
			}
			private VariableValue InvokeMethod(VariableValue target, ITypeDescription targetTypeDescription, MemberGroup memberGroup, FormulaExecutionContext context, bool isDelegated)
			{
				if (memberGroup == null) throw new ArgumentNullException(nameof(memberGroup));
				if (context == null) throw new ArgumentNullException(nameof(context));
	
				var callArguments = new Dictionary<string, VariableValue>();
				foreach (var index in this.arguments)
				{
					callArguments[index.Key] = index.Value.Execute(context);
				}
	
				var typeArguments = isDelegated ? Type.EmptyTypes : this.GetTypeArguments(context);
	
				if (memberGroup.TryInvoke(target, callArguments, expectedType: null, typeArguments, out var result))
				{
					return result;
				}
	
				var name = this.expression is MemberExpression targetMemberExpression ? targetMemberExpression.MemberName : "<unknown>";
				throw FormulaException.UnableToBindMethodToParameters(name, targetTypeDescription, callArguments);
			}
	
			private Type[] GetTypeArguments(FormulaExecutionContext context)
			{
				if (this.expression is MemberExpression targetMemberExpression &&
					targetMemberExpression.TypeArguments.Count > 0)
				{
					var resolvedTypeArguments = new Type[targetMemberExpression.TypeArguments.Count];
					for (var index = 0; index < targetMemberExpression.TypeArguments.Count; index++)
					{
						var typeArgument = targetMemberExpression.TypeArguments[index];
						resolvedTypeArguments[index] = context.TypeResolver.GetTypeDescription(typeArgument).Type;
					}
					return resolvedTypeArguments;
				}
	
				return Type.EmptyTypes;
			}
		}
	

		public interface ITypeDescription
		{
			bool CanBeNull { get; }
			Type Type { get; }
			VariableValue DefaultValue { get; }
	
			bool TryGetConstructors(out MemberGroup constructors);
			bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation);
			bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation);
			bool TryGetMember(string memberName, out MemberGroup memberAccessor);
			bool TryGetStaticMember(string memberName, out MemberGroup memberAccessor);
			bool TryGetIndexer(int rank, out MemberGroup indexAccessor);
			bool TryGetConversionOperation(out MemberGroup convertOperation);
			bool TryGetCheckedConversionOperation(out MemberGroup convertOperation);
		}
	

		public class KnownFormulaTypeResolver : IFormulaTypeResolver
		{
			public static readonly IFormulaTypeResolver Default;
			private static readonly HashSet<Type> BuildInTypes;
	
			private readonly FormulaOptions options;
			private readonly Dictionary<Type, ITypeDescription> typeDescriptions;
			private readonly Dictionary<string, List<Type>> knownTypesByFullName;
			private readonly Dictionary<string, List<Type>> knownTypesByName;
			private readonly HashSet<Type> knownTypes;
			private readonly IFormulaTypeResolver otherTypeResolver;
	
			static KnownFormulaTypeResolver()
			{
				BuildInTypes = new HashSet<Type>
				{
					typeof (object),
					typeof (bool),
					typeof (char),
					typeof (sbyte),
					typeof (byte),
					typeof (short),
					typeof (ushort),
					typeof (int),
					typeof (uint),
					typeof (long),
					typeof (ulong),
					typeof (float),
					typeof (double),
					typeof (decimal),
					typeof (DateTime),
					typeof (TimeSpan),
					typeof (string),
					typeof (Math),
					typeof (Array),
					typeof (Nullable<>),
					typeof (Func<>),
					typeof (Func<,>),
					typeof (Func<,,>),
					typeof (Func<,,,>),
					typeof (Func<,,,,>),
	#if UNITY_EDITOR || UNITY_STANDALONE || UNITY_WII || UNITY_IOS || UNITY_IPHONE || UNITY_ANDROID || UNITY_LUMIN || UNITY_TIZEN || UNITY_TVOS || UNITY_WSA || UNITY_WSA_10_0 || UNITY_WEBGL || UNITY_FACEBOOK
					typeof(UnityEngine.Mathf),
					typeof(UnityEngine.Quaternion),
					typeof(UnityEngine.Vector4),
					typeof(UnityEngine.Vector3),
					typeof(UnityEngine.Vector2),
					typeof(UnityEngine.Color),
					typeof(UnityEngine.Color32),
					typeof(UnityEngine.Matrix4x4),
					typeof(UnityEngine.Plane),
	#endif
				};
				Default = new KnownFormulaTypeResolver(Type.EmptyTypes, FormulaOptions.None);
			}
			public KnownFormulaTypeResolver(IEnumerable<Type> knownTypes, FormulaOptions options, IFormulaTypeResolver otherTypeResolver = null)
			{
				this.knownTypesByFullName = new Dictionary<string, List<Type>>(StringComparer.Ordinal);
				this.knownTypesByName = new Dictionary<string, List<Type>>(StringComparer.Ordinal);
	
				this.otherTypeResolver = otherTypeResolver;
				this.options = options;
				this.typeDescriptions = new Dictionary<Type, ITypeDescription>();
	
				this.knownTypes = new HashSet<Type>(knownTypes ?? Type.EmptyTypes);
				foreach (var buildInType in BuildInTypes)
				{
					this.knownTypes.Add(buildInType);
				}
				foreach (var type in this.knownTypes)
				{
					this.AddKnownType(type);
				}
			}
	
			private void AddKnownType(Type type)
			{
				var typeNames = CSharpNameUtils.GetTypeNames(type);
				if (!string.IsNullOrEmpty(typeNames.Key))
				{
					if (this.knownTypesByName.TryGetValue(typeNames.Key, out var typeList) == false)
					{
						this.knownTypesByName.Add(typeNames.Key, typeList = new List<Type>());
					}
	
					typeList.Add(type);
				}
	
				if (!string.IsNullOrEmpty(typeNames.Value))
				{
					if (this.knownTypesByName.TryGetValue(typeNames.Value, out var typeList) == false)
					{
						this.knownTypesByName.Add(typeNames.Value, typeList = new List<Type>());
					}
	
					typeList.Add(type);
				}
	
				var fullTypeNames = CSharpNameUtils.GetTypeFullNames(type);
				if (!string.IsNullOrEmpty(fullTypeNames.Key))
				{
					if (this.knownTypesByFullName.TryGetValue(fullTypeNames.Key, out var typeList) == false)
					{
						this.knownTypesByFullName.Add(fullTypeNames.Key, typeList = new List<Type>());
					}
	
					typeList.Add(type);
				}
	
				if (!string.IsNullOrEmpty(fullTypeNames.Value))
				{
					if (this.knownTypesByFullName.TryGetValue(fullTypeNames.Value, out var typeList) == false)
					{
						this.knownTypesByFullName.Add(fullTypeNames.Value, typeList = new List<Type>());
					}
	
					typeList.Add(type);
				}
			}
	
			/// <inheritdoc />
			public ITypeDescription GetTypeDescription(Type type)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				lock (this.typeDescriptions)
				{
					if (this.typeDescriptions.TryGetValue(type, out var typeDescriptor))
					{
						return typeDescriptor;
					}
	
					this.typeDescriptions[type] = typeDescriptor = this.CreateTypeDescription(type, this.options);
					return typeDescriptor;
				}
			}
			/// <inheritdoc />
			public ITypeDescription GetTypeDescription(FormulaTypeReference typeReference)
			{
				if (this.TryGetTypeDescription(typeReference, out var typeDescriptor))
				{
					return typeDescriptor;
				}
	
				throw FormulaException.UnableToResolveType(typeReference);
			}
			/// <inheritdoc />
			public bool TryGetTypeDescription(FormulaTypeReference typeReference, out ITypeDescription typeDescription)
			{
				if (typeReference == null) throw new ArgumentNullException(nameof(typeReference));
	
				if (this.TryGetType(typeReference, out var type))
				{
					typeDescription = this.GetTypeDescription(type);
					return true;
				}
	
				if (this.otherTypeResolver != null)
				{
					return this.otherTypeResolver.TryGetTypeDescription(typeReference, out typeDescription);
				}
	
				typeDescription = default;
				return false;
			}
	
			private bool TryGetType(FormulaTypeReference typeReference, out Type foundType)
			{
				foundType = default;
	
				var matches = 0;
				var genericTypeRequired = typeReference.TypeArguments.Count > 0;
	
				// search in full names
				if (this.knownTypesByFullName.TryGetValue(typeReference.FullName, out var typesToCheck))
				{
					foreach (var type in typesToCheck)
					{
						var typeInfo = type.GetTypeInfo();
						if (genericTypeRequired != typeInfo.IsGenericType) continue;
						if (genericTypeRequired && typeInfo.GetGenericArguments().Length != typeReference.TypeArguments.Count) continue;
	
						if (foundType != type)  // could be same type
							matches++;
						foundType = type;
					}
				}
	
				// search in short names
				if (this.knownTypesByName.TryGetValue(typeReference.FullName, out typesToCheck))
				{
					foreach (var type in typesToCheck)
					{
						var typeInfo = type.GetTypeInfo();
						if (genericTypeRequired != typeInfo.IsGenericType) continue;
						if (genericTypeRequired && typeInfo.GetGenericArguments().Length != typeReference.TypeArguments.Count) continue;
	
						if (foundType != type) // could be same type
							matches++;
						foundType = type;
					}
				}
	
				// special case for System.Array because it's not generic but TypeReference for Arrays are
				if (foundType == null && (string.Equals(typeReference.FullName, FormulaConstants.KNOWN_TYPE_SYSTEM_ARRAY, StringComparison.Ordinal) ||
						string.Equals(typeReference.Name, FormulaConstants.KNOWN_TYPE_ARRAY, StringComparison.Ordinal)))
				{
					foundType = typeof(Array);
					matches = 1;
				}
	
				if (matches != 1)
				{
					foundType = null;
					return false;
				}
	
				if (foundType == typeof(Array) &&
					this.TryMakeArrayType(typeReference, ref foundType))
				{
					return true;
				}
				else if (foundType != null && typeReference.TypeArguments.Count > 0 &&
						this.TryMakeGenericType(typeReference, ref foundType))
				{
					return true;
				}
				return foundType != null;
			}
	
			private bool TryMakeGenericType(FormulaTypeReference typeReference, ref Type foundType)
			{
				var genericParameters = default(Type[]);
				var foundTypeInfo = foundType.GetTypeInfo();
				if (foundTypeInfo.IsGenericType &&
					(genericParameters = foundTypeInfo.GetGenericArguments()).Length == typeReference.TypeArguments.Count)
				{
					var typeArguments = new Type[genericParameters.Length];
					var allArgumentBound = true;
					var isOpenType = true;
					for (var i = 0; i < typeArguments.Length; i++)
					{
						var genericArgumentTypeReference = typeReference.TypeArguments[i];
						if (genericArgumentTypeReference.IsEmpty)
						{
							typeArguments[i] = genericParameters[i];
						}
						else if (this.TryGetType(genericArgumentTypeReference, out typeArguments[i]))
						{
							isOpenType = false;
						}
						else
						{
							allArgumentBound = false;
						}
					}
	
					if (!foundTypeInfo.IsGenericTypeDefinition)
					{
						foundType = foundType.GetGenericTypeDefinition() ?? foundType;
					}
	
					if (allArgumentBound)
					{
						foundType = isOpenType ? foundType : foundType.MakeGenericType(typeArguments);
						return true;
					}
				}
	
				foundType = null;
				return false;
			}
			private bool TryMakeArrayType(FormulaTypeReference typeReference, ref Type foundType)
			{
				if (typeReference.TypeArguments.Count == 1)
				{
					if (this.TryGetType(typeReference.TypeArguments[0], out var elementType) == false)
					{
						return false;
					}
	
					foundType = elementType.MakeArrayType();
					return true;
				}
				else if (typeReference.TypeArguments.Count == 0)
				{
					return true;
				}
				foundType = null;
				return true;
			}
	
			protected virtual ITypeDescription CreateTypeDescription(Type type, FormulaOptions options)
			{
				if (type.IsArray)
				{
					return new ArrayTypeDescription(type, options);
				}
				else if (type.IsEnum)
				{
					return new EnumTypeDescription(type, options);
				}
				else if (type == typeof(char))
				{
					return new CharTypeDescription(type, options);
				}
				else if (type == typeof(byte))
				{
					return new UInt8TypeDescription(type, options);
				}
				else if (type == typeof(sbyte))
				{
					return new Int8TypeDescription(type, options);
				}
				else if (type == typeof(short))
				{
					return new Int16TypeDescription(type, options);
				}
				else if (type == typeof(ushort))
				{
					return new UInt16TypeDescription(type, options);
				}
				else if (type == typeof(int))
				{
					return new Int32TypeDescription(type, options);
				}
				else if (type == typeof(uint))
				{
					return new UInt32TypeDescription(type, options);
				}
				else if (type == typeof(long))
				{
					return new Int64TypeDescription(type, options);
				}
				else if (type == typeof(ulong))
				{
					return new UInt64TypeDescription(type, options);
				}
				else if (type == typeof(float))
				{
					return new Float32TypeDescription(type, options);
				}
				else if (type == typeof(double))
				{
					return new Float64TypeDescription(type, options);
				}
				else if (type == typeof(bool))
				{
					return new BooleanTypeDescription(type, options);
				}
				else if (type == typeof(object))
				{
					return new ObjectTypeDescription(type, options);
				}
				else if (type == typeof(string))
				{
					return new StringTypeDescription(type, options);
				}
				else if ((typeof(Type).IsAssignableFrom(type) || type.Namespace == typeof(MemberInfo).Namespace) &&
						(options & FormulaOptions.AllowReflectionApi) == 0)
				{
					return new RestrictedReflectionTypeDescription(type, options);
				}
				return new ReflectionTypeDescription(type, options);
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				return $"KnownTypeResolver, Type Count: {this.knownTypes.Count}";
			}
		}
	

		private class LambdaExpression : FormulaExpression
		{
			private readonly FormulaExpression body;
			private readonly KeyValuePair<string, FormulaTypeReference>[] arguments;
	
			public LambdaExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.body = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE, optional: false);
	
				var arguments = ExpressionBuildHelper.GetArguments(expressionObj, FormulaConstants.ARGUMENTS_ATTRIBUTE);
				this.arguments = new KeyValuePair<string, FormulaTypeReference>[arguments.Count];
				var argumentIndex = 0;
				foreach (var argumentByIndex in arguments)
				{
					if (argumentByIndex.Value is MemberExpression argumentMember)
					{
						this.arguments[argumentIndex++] = new KeyValuePair<string, FormulaTypeReference>(argumentMember.MemberName, null);
						continue;
					}
					throw FormulaException.InvalidLambdaArgument(argumentByIndex.Value);
				}
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var parameters = Array.Empty<KeyValuePair<string, Type>>();
				if (this.arguments.Length > 0)
				{
					parameters = new KeyValuePair<string, Type>[this.arguments.Length];
					for (var index = 0; index < this.arguments.Length; index++)
					{
						var argument = this.arguments[index];
						var parameterType = argument.Value == null ? null : context.TypeResolver.GetTypeDescription(argument.Value).Type;
						parameters[index] = new KeyValuePair<string, Type>(argument.Key, parameterType);
					}
				}
				return new VariableValue(new UnboundLambda(this.body, parameters, context));
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append("(");
				foreach (var argument in this.arguments)
				{
					if (argument.Value != null)
					{
						stringBuilder.Append(argument.Value);
						stringBuilder.Append(" ");
					}
					stringBuilder.Append(argument.Key);
					stringBuilder.Append(", ");
				}
				if (this.arguments.Length > 0)
				{
					stringBuilder.Length -= 2;
				}
				stringBuilder.Append(") => ");
				this.body.BuildDebugView(stringBuilder);
			}
		}
	

		private sealed class LambdaFunctions
		{
			public static Func<ResultT> Func<ResultT>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 0) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return () =>
				{
					var newContext = new FormulaExecutionContext(context.Arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					var convertResult = new ConvertExpression(body, typeof(ResultT), checkedScope: false);
					var result = convertResult.Execute(newContext);
					return result.To<ResultT>();
				};
			}
			public static Func<Arg1T, ResultT> Func<Arg1T, ResultT>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 1) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					var convertResult = new ConvertExpression(body, typeof(ResultT), checkedScope: false);
					var result = convertResult.Execute(newContext);
					return result.To<ResultT>();
				};
			}
			public static Func<Arg1T, Arg2T, ResultT> Func<Arg1T, Arg2T, ResultT>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 2) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					var convertResult = new ConvertExpression(body, typeof(ResultT), checkedScope: false);
					var result = convertResult.Execute(newContext);
					return result.To<ResultT>();
				};
			}
			public static Func<Arg1T, Arg2T, Arg3T, ResultT> Func<Arg1T, Arg2T, Arg3T, ResultT>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 3) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2, arg3) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
					arguments[parameters[2].Key] = new VariableValue(arg3);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					var convertResult = new ConvertExpression(body, typeof(ResultT), checkedScope: false);
					var result = convertResult.Execute(newContext);
					return result.To<ResultT>();
				};
			}
			public static Func<Arg1T, Arg2T, Arg3T, Arg4T, ResultT> Func<Arg1T, Arg2T, Arg3T, Arg4T, ResultT>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 4) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2, arg3, arg4) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
					arguments[parameters[2].Key] = new VariableValue(arg3);
					arguments[parameters[3].Key] = new VariableValue(arg4);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					var convertResult = new ConvertExpression(body, typeof(ResultT), checkedScope: false);
					var result = convertResult.Execute(newContext);
					return result.To<ResultT>();
				};
			}
	
			public static Action Action(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 0) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return () =>
				{
					var newContext = new FormulaExecutionContext(context.Arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					body.Execute(newContext);
				};
			}
			public static Action<Arg1T> Action<Arg1T>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 1) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					body.Execute(newContext);
				};
			}
			public static Action<Arg1T, Arg2T> Action<Arg1T, Arg2T>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 2) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					body.Execute(newContext);
				};
			}
			public static Action<Arg1T, Arg2T, Arg3T> Action<Arg1T, Arg2T, Arg3T>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 3) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2, arg3) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
					arguments[parameters[2].Key] = new VariableValue(arg3);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					body.Execute(newContext);
				};
			}
			public static Action<Arg1T, Arg2T, Arg3T, Arg4T> Action<Arg1T, Arg2T, Arg3T, Arg4T>(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (parameters.Length != 4) throw new ArgumentOutOfRangeException(nameof(parameters));
	
				return (arg1, arg2, arg3, arg4) =>
				{
					var arguments = CopyArguments(parameters, context);
					arguments[parameters[0].Key] = new VariableValue(arg1);
					arguments[parameters[1].Key] = new VariableValue(arg2);
					arguments[parameters[2].Key] = new VariableValue(arg3);
					arguments[parameters[3].Key] = new VariableValue(arg4);
	
					var newContext = new FormulaExecutionContext(arguments, context.Global, context.AutoNullPropagation, context.TypeResolver);
					body.Execute(newContext);
				};
			}
	
			private static Dictionary<string, VariableValue> CopyArguments(KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				var arguments = new Dictionary<string, VariableValue>(context.Arguments.Count + parameters.Length);
				foreach (var contextArgument in context.Arguments)
				{
					arguments[contextArgument.Key] = contextArgument.Value;
				}
	
				return arguments;
			}
		}
	

		public sealed class MemberDescription
		{
			private static readonly ParameterDescription[] EmptyParameters = Array.Empty<ParameterDescription>();
			private static readonly GenericConstraint[] EmptyTypeParameters = Array.Empty<GenericConstraint>();
	
			private readonly Func<VariableValue, VariableValue[], VariableValue> invokeFunc;
			private readonly Lazy<Func<VariableValue, VariableValue[], VariableValue>> lazyInvokeFunc;
			private readonly MemberInfo originalMember;
			private readonly FormulaOptions options;
			private readonly Dictionary<TypeTuple, MemberDescription> methodInstantiations; // null for non-MethodInfo members
	
			public IReadOnlyList<GenericConstraint> TypeParameters { get; }
			public IReadOnlyList<ParameterDescription> Parameters { get; }
			public Type ResultType { get; }
			public int RequiredParameterCount { get; }
	
			public MemberDescription
			(
				Func<VariableValue, VariableValue[], VariableValue> invokeFunc,
				Type resultType,
				IReadOnlyList<ParameterDescription> parameters
			)
			{
				if (invokeFunc == null) throw new ArgumentNullException(nameof(invokeFunc));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (parameters.Count > 64) throw new ArgumentOutOfRangeException(nameof(parameters));
	
	
				this.invokeFunc = invokeFunc;
				this.ResultType = resultType;
				this.Parameters = parameters;
				this.RequiredParameterCount = parameters.Count(parameter => parameter.IsRequired);
				this.TypeParameters = EmptyTypeParameters;
			}
			public MemberDescription(MethodBase methodBase, FormulaOptions options)
			{
				if (methodBase == null) throw new ArgumentNullException(nameof(methodBase));
				if (methodBase.DeclaringType == null) throw new ArgumentException("Method should have declaring type.", nameof(methodBase));
	
				this.originalMember = methodBase;
				this.options = options;
				this.Parameters = EmptyParameters;
				this.TypeParameters = EmptyTypeParameters;
	
				var parameters = methodBase.GetParameters();
				if (parameters.Length > 0)
				{
					var parameterDescriptors = new ParameterDescription[parameters.Length];
					for (var parameterIndex = 0; parameterIndex < parameters.Length; parameterIndex++)
					{
						var parameter = parameters[parameterIndex];
						var defaultValue = VariableValue.Null;
						if (parameter.IsOptional)
						{
							if (parameter.HasDefaultValue)
							{
								defaultValue = new VariableValue(parameter.DefaultValue);
							}
							else if (parameter.ParameterType.IsValueType)
							{
								defaultValue = new VariableValue(Activator.CreateInstance(parameter.ParameterType));
							}
							else
							{
								defaultValue = VariableValue.Null;
							}
						}
						parameterDescriptors[parameterIndex] = new ParameterDescription(parameter.Name, parameter.ParameterType, !parameter.IsOptional, defaultValue);
					}
					this.Parameters = parameterDescriptors;
				}
	
				this.ResultType = methodBase is ConstructorInfo constructorInfo ? constructorInfo.DeclaringType : ((MethodInfo)methodBase).ReturnType;
				this.RequiredParameterCount = this.Parameters.Count(parameter => parameter.IsRequired);
	
				if (methodBase is MethodInfo methodInfo && methodInfo.IsGenericMethod && methodInfo.IsGenericMethodDefinition)
				{
					var genericArguments = methodInfo.GetGenericArguments();
					var genericConstraints = new GenericConstraint[genericArguments.Length];
					for (var index = 0; index < genericArguments.Length; index++)
					{
						var genericArgument = genericArguments[index];
						genericConstraints[index] = new GenericConstraint(genericArgument);
					}
	
					this.methodInstantiations = new Dictionary<TypeTuple, MemberDescription>();
					this.TypeParameters = genericConstraints;
					this.invokeFunc = ReflectionMethodInvoke(methodBase, parameters); // will throw exception on invoke
				}
				else
				{
					if ((options & FormulaOptions.UseDynamicMethods) != 0)
					{
						this.lazyInvokeFunc = new Lazy<Func<VariableValue, VariableValue[], VariableValue>>(() => ExpressionMethodInvoke(methodBase, parameters), LazyThreadSafetyMode.ExecutionAndPublication);
					}
					else
					{
						this.invokeFunc = ReflectionMethodInvoke(methodBase, parameters);
					}
				}
	
			}
			public MemberDescription(FieldInfo fieldInfo, FormulaOptions options)
			{
				if (fieldInfo == null) throw new ArgumentNullException(nameof(fieldInfo));
				if (fieldInfo.DeclaringType == null) throw new ArgumentException("Field should have declaring type.", nameof(fieldInfo));
	
				this.originalMember = fieldInfo;
				this.options = options;
				this.Parameters = EmptyParameters;
				this.RequiredParameterCount = 0;
				this.TypeParameters = EmptyTypeParameters;
	
				if ((options & FormulaOptions.UseDynamicMethods) != 0)
				{
					this.lazyInvokeFunc = new Lazy<Func<VariableValue, VariableValue[], VariableValue>>(() => ExpressionFieldGet(fieldInfo), LazyThreadSafetyMode.ExecutionAndPublication);
				}
				else
				{
					this.invokeFunc = ReflectionFieldGet(fieldInfo);
				}
			}
			public MemberDescription(PropertyInfo propertyInfo, FormulaOptions options)
			{
				if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));
				if (propertyInfo.DeclaringType == null) throw new ArgumentException("Property should have declaring type.", nameof(propertyInfo));
	
				this.originalMember = propertyInfo;
				this.options = options;
				this.Parameters = EmptyParameters;
				this.RequiredParameterCount = 0;
				this.TypeParameters = EmptyTypeParameters;
	
				if ((options & FormulaOptions.UseDynamicMethods) != 0)
				{
					this.lazyInvokeFunc = new Lazy<Func<VariableValue, VariableValue[], VariableValue>>(() => ExpressionPropertyGet(propertyInfo), LazyThreadSafetyMode.ExecutionAndPublication);
				}
				else
				{
					this.invokeFunc = ReflectionPropertyGet(propertyInfo);
				}
			}
	
			private static Func<VariableValue, VariableValue[], VariableValue> ReflectionFieldGet(FieldInfo fieldInfo)
			{
				if (fieldInfo == null) throw new ArgumentNullException(nameof(fieldInfo));
	
				return (target, _) =>
				{
					try
					{
						var targetObj = fieldInfo.IsStatic || target.IsNull ? null : target.ToType(fieldInfo.DeclaringType);
						var result = fieldInfo.GetValue(targetObj);
						return new VariableValue(result);
					}
					catch (TargetInvocationException te)
					{
						if (te.InnerException == null)
						{
							throw;
						}
	#if !NET35 && !NET20
						var exceptionDispatchInfo = System.Runtime.ExceptionServices.ExceptionDispatchInfo.Capture(te.InnerException);
						exceptionDispatchInfo.Throw();
	#endif
						throw te.InnerException;
					}
				};
			}
			private static Func<VariableValue, VariableValue[], VariableValue> ExpressionFieldGet(FieldInfo fieldInfo)
			{
				if (fieldInfo == null) throw new ArgumentNullException(nameof(fieldInfo));
	
				var target = Expression.Parameter(typeof(VariableValue), "target");
				var arguments = Expression.Parameter(typeof(VariableValue), "arguments");
	
				return Expression.Lambda<Func<VariableValue, VariableValue[], VariableValue>>(
					body: VariableValue.ToVariableValueExpression(
						Expression.Field(
							VariableValue.FromVariableValueExpression(target, fieldInfo.DeclaringType),
							fieldInfo
						)),
					parameters: new[] { target, arguments },
					name: "Get" + GetMemberName(fieldInfo) + "WithVariableValuesCall"
				).Compile();
			}
	
			private static Func<VariableValue, VariableValue[], VariableValue> ReflectionPropertyGet(PropertyInfo propertyInfo)
			{
				if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));
	
				return (target, _) =>
				{
					try
					{
						var targetObj = (propertyInfo.GetMethod?.IsStatic).GetValueOrDefault() || target.IsNull ? null : target.ToType(propertyInfo.DeclaringType);
						var result = propertyInfo.GetValue(targetObj);
						return new VariableValue(result);
					}
					catch (TargetInvocationException te)
					{
						if (te.InnerException == null)
						{
							throw;
						}
	#if !NET35 && !NET20
						var exceptionDispatchInfo = System.Runtime.ExceptionServices.ExceptionDispatchInfo.Capture(te.InnerException);
						exceptionDispatchInfo.Throw();
	#endif
						throw te.InnerException;
					}
				};
			}
			private static Func<VariableValue, VariableValue[], VariableValue> ExpressionPropertyGet(PropertyInfo propertyInfo)
			{
				if (propertyInfo == null) throw new ArgumentNullException(nameof(propertyInfo));
	
				var target = Expression.Parameter(typeof(VariableValue), "target");
				var arguments = Expression.Parameter(typeof(VariableValue), "arguments");
	
				return Expression.Lambda<Func<VariableValue, VariableValue[], VariableValue>>(
					body: VariableValue.ToVariableValueExpression(
						Expression.Property(
							VariableValue.FromVariableValueExpression(target, propertyInfo.DeclaringType),
							propertyInfo
						)),
					parameters: new[] { target, arguments },
					name: "Get" + GetMemberName(propertyInfo) + "WithVariableValuesCall"
				).Compile();
			}
	
			private static Func<VariableValue, VariableValue[], VariableValue> ReflectionMethodInvoke(MethodBase methodBase, ParameterInfo[] parameters)
			{
				if (methodBase == null) throw new ArgumentNullException(nameof(methodBase));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
	
				var isStatic = methodBase is MethodInfo methodInfo && methodInfo.IsStatic;
				return (target, arguments) =>
				{
					try
					{
						var argumentList = new object[arguments.Length];
						for (var i = 0; i < arguments.Length; i++)
						{
							argumentList[i] = arguments[i].ToType(parameters[i].ParameterType);
						}
	
						if (methodBase is ConstructorInfo constructorInfo)
						{
							var result = constructorInfo.Invoke(argumentList);
							return new VariableValue(result);
						}
						else
						{
							var targetObj = isStatic || target.IsNull ? null : target.ToType(methodBase.DeclaringType);
							var result = methodBase.Invoke(targetObj, argumentList);
							return new VariableValue(result);
						}
					}
					catch (TargetInvocationException te)
					{
						if (te.InnerException == null)
						{
							throw;
						}
	#if !NET35 && !NET20
						var exceptionDispatchInfo = System.Runtime.ExceptionServices.ExceptionDispatchInfo.Capture(te.InnerException);
						exceptionDispatchInfo.Throw();
	#endif
						throw te.InnerException;
					}
				};
			}
			private static Func<VariableValue, VariableValue[], VariableValue> ExpressionMethodInvoke(MethodBase methodBase, ParameterInfo[] parameters)
			{
				if (methodBase == null) throw new ArgumentNullException(nameof(methodBase));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
	
				var target = Expression.Parameter(typeof(VariableValue), "target");
				var arguments = Expression.Parameter(typeof(VariableValue[]), "arguments");
	
				var argumentExpressions = new Expression[parameters.Length];
				for (var argumentIndex = 0; argumentIndex < argumentExpressions.Length; argumentIndex++)
				{
					argumentExpressions[argumentIndex] = VariableValue.FromVariableValueExpression(
						Expression.ArrayIndex(arguments, Expression.Constant(argumentIndex)),
						parameters[argumentIndex].ParameterType
					);
				}
	
				if (methodBase is ConstructorInfo constructorInfo)
				{
					return Expression.Lambda<Func<VariableValue, VariableValue[], VariableValue>>(
						body: VariableValue.ToVariableValueExpression(
							Expression.New(
								constructorInfo,
								argumentExpressions
							)),
						parameters: new[] { target, arguments },
						name: "Invoke" + constructorInfo.Name + "WithVariableValuesCall"
					).Compile();
				}
				else
				{
					return Expression.Lambda<Func<VariableValue, VariableValue[], VariableValue>>(
						body: VariableValue.ToVariableValueExpression(
							Expression.Call(
								VariableValue.FromVariableValueExpression(target, parameters[0].ParameterType),
								(MethodInfo)methodBase,
								argumentExpressions
							)),
						parameters: new[] { target, arguments },
						name: "Invoke" + GetMemberName(methodBase) + "WithVariableValuesCall"
					).Compile();
				}
			}
	
			private static string GetMemberName(MemberInfo member)
			{
				if (member == null) throw new ArgumentNullException(nameof(member));
	
				return (member.DeclaringType?.FullName + "." + member.Name).Replace(".", "_");
			}
	
			public VariableValue Invoke(VariableValue target, VariableValue[] arguments)
			{
				if (this.invokeFunc != null)
				{
					return this.invokeFunc(target, arguments);
				}
				else
				{
					return this.lazyInvokeFunc.Value(target, arguments);
				}
			}
	
			public MemberDescription MakeGenericMethod(Type[] typeArguments)
			{
				if (typeArguments == null) throw new ArgumentNullException(nameof(typeArguments));
				if (!(this.originalMember is MethodInfo info)) throw new InvalidOperationException($"Can't instantiate not method '{this.originalMember}'.");
				if (this.TypeParameters.Count <= 0) throw new InvalidOperationException($"Can't instantiate non-generic method '{this.originalMember}'.");
	
				var key = new TypeTuple(typeArguments);
				var instantiatedMethodDescription = default(MemberDescription);
				lock (this.methodInstantiations)
				{
					if (this.methodInstantiations.TryGetValue(key, out instantiatedMethodDescription))
						return instantiatedMethodDescription;
	
					var instantiatedMethod = info.MakeGenericMethod(typeArguments);
					instantiatedMethodDescription = new MemberDescription(instantiatedMethod, this.options);
					this.methodInstantiations[key] = instantiatedMethodDescription;
				}
				return instantiatedMethodDescription;
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				var memberRef = this.originalMember != null ? GetMemberName(this.originalMember) : this.invokeFunc.Method.ToString();
				var parameters = string.Join(", ", this.Parameters.Select(p => p.ParameterType.Name));
	
				return $"({parameters}) -> {this.ResultType.Name}, Member: {memberRef}";
			}
	
		}
	

		private class MemberExpression : FormulaExpression, INullPropagationExpression
		{
			private readonly bool useNullPropagation;
			private readonly FormulaExpression expression;
			private FormulaTypeReference skipSelfTypeReference;
			private FormulaTypeReference typeReference;
	
			/// <inheritdoc />
			public bool IsNullPropagationEnabled
			{
				get
				{
					if (this.useNullPropagation)
					{
						return true;
					}
	
					return (this.expression as INullPropagationExpression)?.IsNullPropagationEnabled ?? false;
				}
			}
			public string MemberName { get; }
			public IReadOnlyList<FormulaTypeReference> TypeArguments { get; }
	
			public MemberExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.MemberName = ExpressionBuildHelper.GetString(expressionObj, FormulaConstants.PROPERTY_OR_FIELD_NAME_ATTRIBUTE, optional: true) ??
					ExpressionBuildHelper.GetString(expressionObj, FormulaConstants.NAME_ATTRIBUTE, optional: false);
				this.TypeArguments = ExpressionBuildHelper.GetTypeRefArguments(expressionObj, FormulaConstants.ARGUMENTS_ATTRIBUTE);
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE, optional: true);
				this.useNullPropagation = ExpressionBuildHelper.GetBoolean(expressionObj, FormulaConstants.USE_NULL_PROPAGATION_ATTRIBUTE, optional: true)
					.GetValueOrDefault();
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var isNullPropagation = context.AutoNullPropagation || this.IsNullPropagationEnabled;
	
				if (this.TryGetTypeReferenceAndMemberName(out var typeReference, out var memberName) &&
					context.TypeResolver.TryGetTypeDescription(typeReference, out var typeDescriptor) &&
					typeDescriptor.TryGetStaticMember(memberName, out var memberAccessor))
				{
					memberAccessor.TryInvoke(VariableValue.Null, callArguments: null, expectedType: null, typeArguments: null, out var result);
					return result;
				}
				else if (this.expression != null)
				{
					var target = this.expression.Execute(context);
					if (target.IsNull)
					{
						if (isNullPropagation)
						{
							return VariableValue.Null;
						}
	
						throw FormulaException.CantAccessMemberOnNull(this.MemberName);
					}
	
					var targetTypeDescriptor = context.TypeResolver.GetTypeDescription(target.Type);
					if (this.TryGetMemberValue(targetTypeDescriptor, target, out var memberValue))
					{
						return memberValue;
					}
					throw FormulaException.CantFindMember(targetTypeDescriptor, this.MemberName);
				}
				else if (this.MemberName == FormulaConstants.NOTATION_TRUE_STRING)
				{
					return true;
				}
				else if (this.MemberName == FormulaConstants.NOTATION_FALSE_STRING)
				{
					return false;
				}
				else if (this.MemberName == FormulaConstants.NOTATION_NULL_STRING)
				{
					return VariableValue.Null;
				}
				else if (context.Arguments.TryGetValue(this.MemberName, out var argumentValue))
				{
					return argumentValue;
				}
				else if (!context.Global.IsNull &&
						this.TryGetMemberValue(context.TypeResolver.GetTypeDescription(context.Global.Type), context.Global, out var globalMemberValue))
				{
					return globalMemberValue;
				}
				else
				{
					throw FormulaException.UnableToResolveGlobalName(this.MemberName);
				}
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				if (this.expression != null)
				{
					this.expression.BuildDebugView(stringBuilder);
					if (this.useNullPropagation)
					{
						stringBuilder.Append("?");
					}
					stringBuilder.Append(".");
				}
				stringBuilder.Append(this.MemberName);
				if (this.TypeArguments != null && this.TypeArguments.Count > 0)
				{
					stringBuilder.Append("<");
					foreach (var typeArgument in this.TypeArguments)
					{
						stringBuilder.Append(typeArgument);
						stringBuilder.Append(", ");
					}
					stringBuilder.Length -= 2;
					stringBuilder.Append(">");
				}
			}
	
			public bool TryGetExpressionAndMemberName(out FormulaExpression expression, out string memberName)
			{
				if (this.expression != null)
				{
					memberName = this.MemberName;
					expression = this.expression;
					return true;
				}
				else
				{
					expression = default;
					memberName = default;
					return false;
				}
			}
	
			public bool TryGetTypeReferenceAndMemberName(out FormulaTypeReference typeReference, out string memberName)
			{
				if (this.TryGetTypeReference(out typeReference, skipSelf: true))
				{
					memberName = this.MemberName;
					return true;
				}
	
				memberName = default;
				return false;
			}
			private bool TryGetTypeReference(out FormulaTypeReference typeReference, bool skipSelf = false)
			{
				if (skipSelf && this.skipSelfTypeReference != null)
				{
					typeReference = this.skipSelfTypeReference;
					return true;
				}
				else if (!skipSelf && this.typeReference != null)
				{
					typeReference = this.typeReference;
					return true;
				}
	
				if (this.useNullPropagation)
				{
					typeReference = default;
					return false; // null propagation ?. is not type reference
				}
	
				var baseTypeReference = default(FormulaTypeReference);
				if (this.expression != null && !(this.expression is MemberExpression))
				{
					typeReference = default;
					return false; // base expression is not member expression
				}
	
				if (this.expression != null && ((MemberExpression)this.expression).TryGetTypeReference(out baseTypeReference, skipSelf: false) == false)
				{
					typeReference = default;
					return false; // base expression is not a type reference
				}
	
				if (skipSelf)
				{
					this.skipSelfTypeReference = typeReference = baseTypeReference;
				}
				else
				{
					this.typeReference = typeReference = new FormulaTypeReference(this.MemberName, this.TypeArguments, baseTypeReference);
				}
				return typeReference != null;
			}
	
			private bool TryGetMemberValue(ITypeDescription targetTypeDescription, VariableValue target, out VariableValue memberValue)
			{
				if (targetTypeDescription == null) throw new ArgumentNullException(nameof(targetTypeDescription));
	
				if (!targetTypeDescription.TryGetMember(this.MemberName, out var memberDescriptor))
				{
					memberValue = default;
					return false;
				}
	
				if (memberDescriptor.GroupType == MemberGroupType.Method ||
					memberDescriptor.GroupType == MemberGroupType.Constructor)
				{
					throw FormulaException.CanAccessMethodOrConstructorGroup(this.MemberName, targetTypeDescription);
				}
	
				// TODO wrap errors for better message
				return memberDescriptor.TryInvoke(target, callArguments: null, expectedType: null, typeArguments: null, out memberValue);
			}
		}
	

		public sealed class MemberGroup
		{
			private enum ParameterMatchQuality { None, Coerced, Cast, Exact }
			private static readonly Dictionary<string, VariableValue> EmptyArguments = new Dictionary<string, VariableValue>();
	
			private static readonly string[] PositionNumbers = Enumerable.Range(0, 64).Select(p => p.ToString()).ToArray();
	
			private readonly IReadOnlyList<MemberDescription> members;
	
			public MemberGroupType GroupType { get; }
	
			public MemberGroup(MemberGroupType groupType, IReadOnlyList<MemberDescription> members)
			{
				if (members == null) throw new ArgumentNullException(nameof(members));
	
				this.members = members;
				this.GroupType = groupType;
			}
	
			public bool TryInvoke(VariableValue target, Dictionary<string, VariableValue> callArguments, Type expectedType, Type[] typeArguments, out VariableValue result)
			{
				callArguments = callArguments ?? EmptyArguments;
				typeArguments = typeArguments ?? Type.EmptyTypes;
	
				var bestMatchMethod = MatchMember(this.members, callArguments, expectedType, typeArguments, out var argumentOrder);
				if (bestMatchMethod == null || !TryPrepareArguments(bestMatchMethod, callArguments, argumentOrder, out var arguments))
				{
					result = default;
					return false;
				}
	
				result = bestMatchMethod.Invoke(target, arguments);
				return true;
			}
	
			private static MemberDescription MatchMember(IReadOnlyList<MemberDescription> members, Dictionary<string, VariableValue> callArguments, Type expectedType, Type[] typeArguments, out string[] argumentOrder)
			{
				if (members == null) throw new ArgumentNullException(nameof(members));
				if (callArguments == null) throw new ArgumentNullException(nameof(callArguments));
	
				argumentOrder = PositionNumbers;
	
				var bestMatchMethod = default(MemberDescription);
				var bestMatchParametersQuality = ParameterMatchQuality.Coerced;
				var bestMatchResultQuality = ParameterMatchQuality.Coerced;
	
				for (var index = 0; index < members.Count; index++)
				{
					var method = members[index];
					if (method.RequiredParameterCount > callArguments.Count)
					{
						continue;
					}
	
					if (method.TypeParameters.Count != typeArguments.Length ||
						!AreMatching(method.TypeParameters, typeArguments))
					{
						continue;
					}
	
					if (method.TypeParameters.Count > 0)
					{
						method = method.MakeGenericMethod(typeArguments);
					}
	
					if (!TryBindParameters(method, callArguments, out var argumentsOrder, out var parametersQuality))
					{
						continue;
					}
	
					var resultQuality = ParameterMatchQuality.Exact;
					if (expectedType != null && !TryMatchResultType(method.ResultType, expectedType, out resultQuality))
					{
						continue;
					}
	
					if (resultQuality < bestMatchResultQuality || parametersQuality < bestMatchParametersQuality)
					{
						continue;
					}
	
					bestMatchMethod = method;
					argumentOrder = argumentsOrder;
					bestMatchParametersQuality = parametersQuality;
					bestMatchResultQuality = resultQuality;
				}
	
				return bestMatchMethod;
			}
	
			private static bool TryBindParameters(MemberDescription member, Dictionary<string, VariableValue> callArguments, out string[] argumentOrder, out ParameterMatchQuality quality)
			{
				var parameterCount = member.Parameters.Count;
				if (parameterCount == 0 && callArguments.Count == 0)
				{
					argumentOrder = PositionNumbers;
					quality = ParameterMatchQuality.Exact;
					return true;
				}
	
				for (var parameterIndex = 0; parameterIndex < callArguments.Count; parameterIndex++)
				{
					var parameterName = GetIndexAsString(parameterIndex);
					if (!callArguments.ContainsKey(parameterName))
					{
						return TryBindMixedParameters(member, callArguments, out argumentOrder, out quality);
					}
				}
				return TryBindPositionalParameters(member, callArguments, out argumentOrder, out quality);
			}
			private static bool TryBindPositionalParameters(MemberDescription member, Dictionary<string, VariableValue> callArguments, out string[] parameterOrder, out ParameterMatchQuality quality)
			{
				var parameterCount = member.Parameters.Count;
	
				parameterOrder = PositionNumbers;
				quality = ParameterMatchQuality.Exact;
	
				// bind positional parameters
				for (var parameterIndex = 0; parameterIndex < parameterCount; parameterIndex++)
				{
					var parameter = member.Parameters[parameterIndex];
					var parameterType = parameter.ParameterType;
					var parameterName = GetIndexAsString(parameterIndex);
	
					if (!callArguments.TryGetValue(parameterName, out var parameterValue) &&
						!TryGetDefaultValue(parameter, ref parameterValue))
					{
						quality = ParameterMatchQuality.None;
						return false; // unable to find parameter
					}
	
					if (parameterValue.Type == parameterType)
					{
						quality = MinQuality(quality, ParameterMatchQuality.Exact);
					}
					else if (TryCastValue(parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Cast);
					}
					else if (TryCoercePrimitive(ref parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Coerced);
					}
					else
					{
						quality = ParameterMatchQuality.None;
						return false;  // unable to bind parameter by type
					}
				}
	
				return true;
			}
			private static bool TryBindMixedParameters(MemberDescription member, Dictionary<string, VariableValue> callArguments, out string[] parameterOrder, out ParameterMatchQuality quality)
			{
				var parameterCount = member.Parameters.Count;
				var boundArguments = 0UL;
				var parameterValue = default(VariableValue);
	
				parameterOrder = new string[parameterCount];
				quality = ParameterMatchQuality.Exact;
	
				// bind named arguments
				for (var parameterIndex = 0; parameterIndex < parameterCount; parameterIndex++)
				{
					var parameter = member.Parameters[parameterIndex];
					var parameterName = parameter.Name;
					if (callArguments.TryGetValue(parameterName, out parameterValue))
					{
						boundArguments |= 1UL << parameterIndex;
						parameterOrder[parameterIndex] = parameterName;
					}
					else
					{
						continue;
					}
	
					var parameterType = parameter.ParameterType;
					if (parameterValue.Type == parameterType)
					{
						quality = MinQuality(quality, ParameterMatchQuality.Exact);
					}
					else if (TryCastValue(parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Cast);
					}
					else if (TryCoercePrimitive(ref parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Coerced);
					}
					else
					{
						quality = ParameterMatchQuality.None;
						return false;  // unable to bind parameter by type
					}
				}
	
				// bind positional parameters
				var lastPositionIndex = 0;
				for (var parameterIndex = 0; parameterIndex < parameterCount; parameterIndex++)
				{
					var parameter = member.Parameters[parameterIndex];
	
					if ((boundArguments & 1UL << parameterIndex) != 0)
					{
						continue; // already bound
					}
	
					if ((boundArguments & 1UL << parameterIndex) == 0) // try to bind by position
					{
						while (lastPositionIndex < parameterCount)
						{
							var parameterName = GetIndexAsString(lastPositionIndex++);
							if (callArguments.TryGetValue(parameterName, out parameterValue))
							{
								boundArguments |= 1UL << parameterIndex;
								parameterOrder[parameterIndex] = parameterName;
								break;
							}
						}
					}
	
					if ((boundArguments & 1UL << parameterIndex) == 0 &&
						!TryGetDefaultValue(parameter, ref parameterValue))
					{
						return false; // required and not bound by position and not bound by name
					}
	
	
					var parameterType = member.Parameters[parameterIndex].ParameterType;
					if (parameterValue.Type == parameterType)
					{
						quality = MinQuality(quality, ParameterMatchQuality.Exact);
					}
					else if (TryCastValue(parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Cast);
					}
					else if (TryCoercePrimitive(ref parameterValue, parameterType))
					{
						quality = MinQuality(quality, ParameterMatchQuality.Coerced);
					}
					else
					{
						quality = ParameterMatchQuality.None;
						return false;  // unable to bind parameter by type
					}
				}
	
				return true;
			}
			private static bool TryPrepareArguments(MemberDescription member, Dictionary<string, VariableValue> callArguments, string[] parameterOrder, out VariableValue[] arguments)
			{
				var parameterCount = member.Parameters.Count;
				arguments = new VariableValue[parameterCount];
				for (var parameterIndex = 0; parameterIndex < parameterCount; parameterIndex++)
				{
					var parameterName = parameterIndex < parameterOrder.Length ? parameterOrder[parameterIndex] : string.Empty;
					var parameter = member.Parameters[parameterIndex];
					var parameterType = parameter.ParameterType;
					if (!(callArguments.TryGetValue(parameterName, out var parameterValue) || TryGetDefaultValue(parameter, ref parameterValue)) ||
							!TryCastValue(parameterValue, parameterType) &&
							!TryCoercePrimitive(ref parameterValue, parameterType) &&
							!TryBindLambda(ref parameterValue, parameterType))
					{
						return false;
					}
	
					arguments[parameterIndex] = parameterValue;
				}
	
				return true;
			}
			private static bool TryGetDefaultValue(ParameterDescription parameter, ref VariableValue parameterValue)
			{
				if (parameter.IsRequired)
				{
					return false;
				}
	
				parameterValue = parameter.DefaultValue;
				return true;
			}
	
			private static bool TryBindLambda(ref VariableValue parameterValue, Type parameterType)
			{
				if (parameterValue.Type != typeof(UnboundLambda) ||
					!typeof(Delegate).IsAssignableFrom(parameterType))
				{
					return false;
				}
	
				var unboundLambdaExpression = (UnboundLambda)parameterValue.ToObject();
				parameterValue = new VariableValue(unboundLambdaExpression.BindTo(parameterType));
				return true;
			}
			private static bool TryCoercePrimitive(ref VariableValue parameterValue, Type parameterType)
			{
				if (parameterValue.IsNull)
				{
					return false;
				}
	
				var expectedTypeCode = TypeCodes.GetTypeCode(parameterType);
				if (parameterValue.TypeCode == expectedTypeCode)
				{
					return true;
				}
	
				if (parameterValue.TypeCode == expectedTypeCode)
				{
					return true;
				}
	
				if (!parameterValue.CanFitInto(expectedTypeCode))
				{
					return false;
				}
	
				// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
				switch (expectedTypeCode)
				{
					case TypeCode.Boolean: parameterValue = parameterValue.ToBoolean(); return true;
					case TypeCode.Char: parameterValue = parameterValue.ToChar(); return true;
					case TypeCode.SByte: parameterValue = parameterValue.ToSByte(); return true;
					case TypeCode.Byte: parameterValue = parameterValue.ToByte(); return true;
					case TypeCode.Int16: parameterValue = parameterValue.ToInt16(); return true;
					case TypeCode.UInt16: parameterValue = parameterValue.ToUInt16(); return true;
					case TypeCode.Int32: parameterValue = parameterValue.ToInt32(); return true;
					case TypeCode.UInt32: parameterValue = parameterValue.ToUInt32(); return true;
					case TypeCode.Int64: parameterValue = parameterValue.ToInt64(); return true;
					case TypeCode.UInt64: parameterValue = parameterValue.ToUInt64(); return true;
					case TypeCode.Single: parameterValue = parameterValue.ToSingle(); return true;
					case TypeCode.Double: parameterValue = parameterValue.ToDouble(); return true;
					case TypeCode.Decimal: parameterValue = parameterValue.ToDecimal(); return true;
					default: return false;
				}
			}
			private static bool TryCastValue(VariableValue parameterValue, Type parameterType)
			{
				if (parameterType == typeof(object))
				{
					return true;
				}
				if (parameterValue.IsNull && (!parameterType.IsValueType || IsNullableType(parameterType)))
				{
					return true;
				}
	
				if (parameterValue.Type == typeof(UnboundLambda) &&
					typeof(Delegate).IsAssignableFrom(parameterType))
				{
					return ((UnboundLambda)parameterValue.ToObject()).IsSignatureMatching(parameterType);
				}
	
				return parameterType.IsAssignableFrom(parameterValue.Type);
			}
			private static bool TryMatchResultType(Type resultType, Type expectedResultType, out ParameterMatchQuality quality)
			{
				if (resultType == expectedResultType)
				{
					quality = ParameterMatchQuality.Exact;
					return true;
				}
				else if (expectedResultType.IsAssignableFrom(resultType))
				{
					quality = ParameterMatchQuality.Cast;
					return true;
				}
	
				var resultTypeCode = TypeCodes.GetTypeCode(resultType);
				var expectedResultTypeCode = TypeCodes.GetTypeCode(expectedResultType);
				if (TypeCodes.CanCoerceNumberLike(expectedResultTypeCode, resultTypeCode))
				{
					quality = ParameterMatchQuality.Coerced;
					return true;
				}
	
				quality = default;
				return false;
			}
			private static bool IsNullableType(Type parameterType)
			{
				return Nullable.GetUnderlyingType(parameterType) != null;
			}
			private static bool AreMatching(IReadOnlyList<GenericConstraint> typeParameters, Type[] typeArguments)
			{
				if (typeParameters == null) throw new ArgumentNullException(nameof(typeParameters));
				if (typeParameters.Count != typeArguments.Length) throw new ArgumentOutOfRangeException(nameof(typeArguments));
	
				for (var index = 0; index < typeParameters.Count; index++)
				{
					if (typeParameters[index].IsMatching(typeArguments[index]) == false)
					{
						return false;
					}
				}
	
				return true;
			}
			private static string GetIndexAsString(int index)
			{
				if (index >= 0 && index < 64)
				{
					return PositionNumbers[index];
				}
				return index.ToString();
			}
	
			private static ParameterMatchQuality MinQuality(ParameterMatchQuality value1, ParameterMatchQuality value2)
			{
				return value1 < value2 ? value1 : value2;
			}
			/// <inheritdoc />
			public override string ToString()
			{
				return "MemberGroup, Members: " + string.Join("\r\n\t", this.members.Select(member => member.ToString()).ToArray());
			}
		}
	

		public enum MemberGroupType
		{
			Field,
			Property,
			Constructor,
			Method
		}
	

		private class NewArrayBoundExpression : FormulaExpression
		{
			private readonly IReadOnlyDictionary<string, FormulaExpression> arguments;
			private readonly FormulaTypeReference type;
	
			public NewArrayBoundExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.arguments = ExpressionBuildHelper.GetArguments(expressionObj, FormulaConstants.ARGUMENTS_ATTRIBUTE);
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.TYPE_ATTRIBUTE, optional: false);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var typeDescription = context.TypeResolver.GetTypeDescription(this.type);
				var arrayTypeDescription = context.TypeResolver.GetTypeDescription(typeDescription.Type.MakeArrayType(this.arguments.Count));
	
				var constructorArguments = new Dictionary<string, VariableValue>();
				foreach (var index in this.arguments)
				{
					constructorArguments[index.Key] = index.Value.Execute(context);
				}
	
				if (arrayTypeDescription.TryGetConstructors(out var constructors) &&
					constructors.TryInvoke(VariableValue.Null, constructorArguments, expectedType: null, typeArguments: null, out var result))
				{
					return result;
				}
	
				throw FormulaException.UnableToBindConstructorToParameters(typeDescription, constructorArguments);
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append(this.type);
				stringBuilder.Length -= 2;
				stringBuilder.Append("[");
				foreach (var argument in this.arguments)
				{
					argument.Value.BuildDebugView(stringBuilder);
					stringBuilder.Append(", ");
				}
				if (this.arguments.Count > 0)
				{
					stringBuilder.Length -= 2;
				}
				stringBuilder.Append("]");
			}
		}
	

		private class NewExpression : FormulaExpression
		{
			private readonly IReadOnlyDictionary<string, FormulaExpression> arguments;
			private readonly FormulaTypeReference type;
	
			public NewExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.arguments = ExpressionBuildHelper.GetArguments(expressionObj, FormulaConstants.ARGUMENTS_ATTRIBUTE);
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.TYPE_ATTRIBUTE, optional: false);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var typeDescription = context.TypeResolver.GetTypeDescription(this.type);
	
				if (this.arguments.Count == 1 &&
					this.arguments.Values.First() is LambdaExpression lambdaExpression &&
					typeof(Delegate).IsAssignableFrom(typeDescription.Type))
				{
					return this.ExecuteLambdaConstructor(context, typeDescription, lambdaExpression);
				}
				else
				{
					return this.ExecuteConstructor(context, typeDescription);
				}
			}
	
			private VariableValue ExecuteLambdaConstructor(FormulaExecutionContext context, ITypeDescription typeDescription, LambdaExpression lambdaExpression)
			{
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (typeDescription == null) throw new ArgumentNullException(nameof(typeDescription));
				if (lambdaExpression == null) throw new ArgumentNullException(nameof(lambdaExpression));
	
				var unboundLambdaValue = lambdaExpression.Execute(context);
				var unboundLambda = (UnboundLambda)unboundLambdaValue.ToObject();
				var boundLambda = unboundLambda.BindTo(typeDescription.Type);
				return new VariableValue(boundLambda);
			}
	
			private VariableValue ExecuteConstructor(FormulaExecutionContext context, ITypeDescription typeDescription)
			{
				if (context == null) throw new ArgumentNullException(nameof(context));
				if (typeDescription == null) throw new ArgumentNullException(nameof(typeDescription));
	
				var constructorArguments = new Dictionary<string, VariableValue>();
				foreach (var index in this.arguments)
				{
					constructorArguments[index.Key] = index.Value.Execute(context);
				}
	
				if (typeDescription.TryGetConstructors(out var constructors) &&
					constructors.TryInvoke(VariableValue.Null, constructorArguments, expectedType: null, typeArguments: null, out var result))
				{
					return result;
				}
	
				throw FormulaException.UnableToBindConstructorToParameters(typeDescription, constructorArguments);
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append("new ").Append(this.type).Append("(");
				stringBuilder.Append("(");
				foreach (var argument in this.arguments)
				{
					if (!argument.Key.All(char.IsDigit))
					{
						stringBuilder.Append(argument.Key).Append(": ");
					}
					argument.Value.BuildDebugView(stringBuilder);
					stringBuilder.Append(", ");
				}
	
				if (this.arguments.Count > 0)
				{
					stringBuilder.Length -= 2;
				}
	
				stringBuilder.Append(")");
			}
		}
	

		private sealed class ObjectTypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
	
			static ObjectTypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToObject() == arguments[1].ToObject()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToObject() != arguments[1].ToObject()));
			}
			/// <inheritdoc />
			public ObjectTypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Object), isRequired: true),
								new ParameterDescription("value2", typeof(Object), isRequired: true)
							})
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		public sealed class ParameterDescription
		{
			public Type ParameterType { get; }
			public string Name { get; }
			public bool IsRequired { get; }
			public VariableValue DefaultValue { get; }
	
			public ParameterDescription(string name, Type parameterType, bool isRequired, VariableValue defaultValue = default)
			{
				if (name == null) throw new ArgumentNullException(nameof(name));
				if (parameterType == null) throw new ArgumentNullException(nameof(parameterType));
				if (string.IsNullOrEmpty(name)) throw new ArgumentException("Value cannot be null or empty.", nameof(name));
	
				this.ParameterType = parameterType;
				this.IsRequired = isRequired;
				this.DefaultValue = defaultValue;
				this.Name = name;
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				return $"Parameter, Name: {this.Name}, Type: {this.ParameterType}, Required: {this.IsRequired}, Default Value: {this.DefaultValue}";
			}
		}
	

		private class ReflectionTypeDescription : ITypeDescription
		{
			private readonly Lazy<MemberGroup> lazyConstructors;
			private readonly Lazy<Dictionary<MemberGroupType, Dictionary<string, Lazy<MemberGroup>>>> lazyAllMembers;
			private readonly Lazy<Dictionary<MemberGroupType, Dictionary<string, Lazy<MemberGroup>>>> lazyAllStaticMembers;
			private readonly Lazy<Dictionary<bool, Lazy<MemberGroup>>> lazyConvertMethods;
	
			/// <inheritdoc />
			public bool CanBeNull { get; }
			/// <inheritdoc />
			public Type Type { get; }
			/// <inheritdoc />
			public VariableValue DefaultValue { get; }
	
			public ReflectionTypeDescription(Type type, FormulaOptions options)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				this.CanBeNull = !type.IsValueType || Nullable.GetUnderlyingType(type) != null;
				this.Type = type;
				this.DefaultValue = type.IsValueType ? new VariableValue(Activator.CreateInstance(type)) : VariableValue.Null;
	
				this.lazyAllMembers = new Lazy<Dictionary<MemberGroupType, Dictionary<string, Lazy<MemberGroup>>>>(
					() => GetAllMembers(type, BindingFlags.Instance | BindingFlags.Public, options),
					LazyThreadSafetyMode.ExecutionAndPublication
				);
				this.lazyAllStaticMembers = new Lazy<Dictionary<MemberGroupType, Dictionary<string, Lazy<MemberGroup>>>>(
					() => GetAllMembers(type, BindingFlags.Static | BindingFlags.Public, options),
					LazyThreadSafetyMode.ExecutionAndPublication
				);
				this.lazyConstructors = new Lazy<MemberGroup>(
					() => GetConstructors(type, options),
					LazyThreadSafetyMode.ExecutionAndPublication
				);
				this.lazyConvertMethods = new Lazy<Dictionary<bool, Lazy<MemberGroup>>>(
					() => GetConvertMethods(type, options),
					LazyThreadSafetyMode.ExecutionAndPublication
				);
			}
	
			/// <inheritdoc />
			public virtual bool TryGetConstructors(out MemberGroup constructors)
			{
				constructors = this.lazyConstructors.Value;
				return constructors != null;
			}
			/// <inheritdoc />
			public virtual bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				string methodName;
				switch (operationType)
				{
					case BinaryOperationType.And: methodName = "op_BitwiseAnd"; break;
					case BinaryOperationType.Or: methodName = "op_BitwiseOr"; break;
					case BinaryOperationType.ExclusiveOr: methodName = "op_ExclusiveOr"; break;
					case BinaryOperationType.Multiply: methodName = "op_Multiply"; break;
					case BinaryOperationType.MultiplyChecked: methodName = "op_CheckedMultiply"; break;
					case BinaryOperationType.Divide: methodName = "op_Division"; break;
					case BinaryOperationType.DivideChecked: methodName = "op_CheckedDivision"; break;
					case BinaryOperationType.Power: methodName = ""; break;
					case BinaryOperationType.Modulo: methodName = "op_Modulus"; break;
					case BinaryOperationType.Add: methodName = "op_Addition"; break;
					case BinaryOperationType.AddChecked: methodName = "op_CheckedAddition"; break;
					case BinaryOperationType.Subtract: methodName = "op_Subtraction"; break;
					case BinaryOperationType.SubtractChecked: methodName = "op_CheckedSubtraction"; break;
					case BinaryOperationType.LeftShift: methodName = "op_Multiply"; break;
					case BinaryOperationType.RightShift: methodName = "op_RightShift"; break;
					case BinaryOperationType.GreaterThan: methodName = "op_GreaterThan"; break;
					case BinaryOperationType.GreaterThanOrEqual: methodName = "op_GreaterThanOrEqual"; break;
					case BinaryOperationType.LessThan: methodName = "op_LessThan"; break;
					case BinaryOperationType.LessThanOrEqual: methodName = "op_LessThanOrEqual"; break;
					case BinaryOperationType.Equal: methodName = "op_Equality"; break;
					case BinaryOperationType.NotEqual: methodName = "op_Inequality"; break;
					case BinaryOperationType.AndAlso: methodName = ""; break;
					case BinaryOperationType.OrElse: methodName = ""; break;
					case BinaryOperationType.Coalesce: methodName = ""; break;
					default: throw new ArgumentOutOfRangeException(nameof(operationType), operationType, null);
				}
	
				if (!string.IsNullOrEmpty(methodName) &&
					this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Method, out var memberGroupsByName) &&
					memberGroupsByName.TryGetValue(methodName, out var lazyMemberGroup))
				{
					binaryOperation = lazyMemberGroup.Value;
					return true;
				}
	
				binaryOperation = null;
				return false;
			}
			/// <inheritdoc />
			public virtual bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				string methodName;
				switch (operationType)
				{
					case UnaryOperationType.UnaryPlus: methodName = "op_UnaryPlus"; break;
					case UnaryOperationType.Negate: methodName = "op_UnaryNegation"; break;
					case UnaryOperationType.NegateChecked: methodName = "op_CheckedUnaryNegation"; break;
					case UnaryOperationType.Not: methodName = "op_LogicalNot"; break;
					case UnaryOperationType.Complement: methodName = "op_OnesComplement"; break;
					case UnaryOperationType.UncheckedScope: methodName = ""; break;
					case UnaryOperationType.CheckedScope: methodName = ""; break;
					case UnaryOperationType.Group: methodName = ""; break;
					default: throw new ArgumentOutOfRangeException(nameof(operationType), operationType, null);
				}
	
				if (!string.IsNullOrEmpty(methodName) &&
					this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Method, out var memberGroupsByName) &&
					memberGroupsByName.TryGetValue(methodName, out var lazyMemberGroup))
				{
					unaryOperation = lazyMemberGroup.Value;
					return true;
				}
	
				unaryOperation = null;
				return false;
			}
			/// <inheritdoc />
			public virtual bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				var methodName = "get_Item";
	
				if (!string.IsNullOrEmpty(methodName) &&
					this.lazyAllMembers.Value.TryGetValue(MemberGroupType.Method, out var memberGroupsByName) &&
					memberGroupsByName.TryGetValue(methodName, out var lazyMemberGroup))
				{
					indexAccessor = lazyMemberGroup.Value;
					return true;
				}
	
				indexAccessor = null;
				return false;
			}
			/// <inheritdoc />
			public virtual bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				if (this.lazyConvertMethods.Value.TryGetValue( /*checked scope*/ false, out var lazyMemberGroup))
				{
					convertOperation = lazyMemberGroup.Value;
					return true;
				}
				else
				{
					convertOperation = null;
					return false;
				}
			}
			/// <inheritdoc />
			public virtual bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				if (this.lazyConvertMethods.Value.TryGetValue( /*checked scope*/ true, out var lazyMemberGroup))
				{
					convertOperation = lazyMemberGroup.Value;
					return true;
				}
				else
				{
					convertOperation = null;
					return false;
				}
			}
			/// <inheritdoc />
			public virtual bool TryGetMember(string memberName, out MemberGroup memberAccessor)
			{
				if (memberName == null) throw new ArgumentNullException(nameof(memberName));
	
				if (string.IsNullOrEmpty(memberName))
				{
					memberAccessor = null;
					return false;
				}
	
				if (this.lazyAllMembers.Value.TryGetValue(MemberGroupType.Method, out var memberGroupsByName) &&
					memberGroupsByName.TryGetValue(memberName, out var lazyMemberGroup) ||
					this.lazyAllMembers.Value.TryGetValue(MemberGroupType.Field, out memberGroupsByName) &&
						memberGroupsByName.TryGetValue(memberName, out lazyMemberGroup) ||
					this.lazyAllMembers.Value.TryGetValue(MemberGroupType.Property, out memberGroupsByName) &&
						memberGroupsByName.TryGetValue(memberName, out lazyMemberGroup))
				{
					memberAccessor = lazyMemberGroup.Value;
					return true;
				}
	
				memberAccessor = null;
				return false;
			}
			/// <inheritdoc />
			public virtual bool TryGetStaticMember(string memberName, out MemberGroup memberAccessor)
			{
				if (string.IsNullOrEmpty(memberName))
				{
					memberAccessor = null;
					return false;
				}
	
				if (this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Method, out var memberGroupsByName) &&
						memberGroupsByName.TryGetValue(memberName, out var lazyMemberGroup) ||
						this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Field, out memberGroupsByName) &&
						memberGroupsByName.TryGetValue(memberName, out lazyMemberGroup) ||
						this.lazyAllStaticMembers.Value.TryGetValue(MemberGroupType.Property, out memberGroupsByName) &&
						memberGroupsByName.TryGetValue(memberName, out lazyMemberGroup))
				{
					memberAccessor = lazyMemberGroup.Value;
					return true;
				}
	
				memberAccessor = null;
				return false;
			}
	
			private static Dictionary<MemberGroupType, Dictionary<string, Lazy<MemberGroup>>> GetAllMembers(Type type, BindingFlags bindingFlags, FormulaOptions options)
			{
				return type
					.GetMembers(bindingFlags)
					.Where(memberInfo => !HasByRefLikeAttribute(memberInfo) && HasGetter(memberInfo))
					.ToLookup(MapToGroupType)
					.Where(group => group.Key != null)
					.ToDictionary(
						group => group.Key.GetValueOrDefault(),
						group => group
							.ToLookup(member => member.Name)
							.ToDictionary(
								members => members.Key,
								members => new Lazy<MemberGroup>(() => GroupMembers(members.ToList(), options), LazyThreadSafetyMode.ExecutionAndPublication)));
			}
	
			private static MemberGroup GroupMembers(List<MemberInfo> members, FormulaOptions options)
			{
				if (members == null) throw new ArgumentNullException(nameof(members));
	
				var memberDescriptors = new List<MemberDescription>(members.Count);
				var groupType = default(MemberGroupType?);
				foreach (var memberInfo in members)
				{
					groupType = MapToGroupType(memberInfo);
					if (memberInfo is ConstructorInfo constructorInfo)
					{
						memberDescriptors.Add(new MemberDescription(constructorInfo, options));
					}
					else if (memberInfo is MethodBase methodBase)
					{
						memberDescriptors.Add(new MemberDescription(methodBase, options));
					}
					else if (memberInfo is PropertyInfo propertyInfo)
					{
						memberDescriptors.Add(new MemberDescription(propertyInfo, options));
					}
					else if (memberInfo is FieldInfo fieldInfo)
					{
						memberDescriptors.Add(new MemberDescription(fieldInfo, options));
					}
				}
				if (groupType == null)
				{
					throw new InvalidOperationException("Member group doesn't contains any members.");
				}
				return new MemberGroup(groupType.Value, memberDescriptors);
			}
			private static MemberGroup GetConstructors(Type type, FormulaOptions options)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				var constructors = type.GetConstructors(BindingFlags.Instance | BindingFlags.Public)
					.Where(constructorInfo => !HasByRefLikeAttribute(constructorInfo))
					.Select(member => (MemberInfo)member)
					.ToList();
				if (constructors.Count == 0)
				{
					return null;
				}
				return GroupMembers(constructors, options);
			}
			private static Dictionary<bool, Lazy<MemberGroup>> GetConvertMethods(Type type, FormulaOptions options)
			{
				var allMethods = type
					.GetMethods(BindingFlags.Public | BindingFlags.Static)
					.Where(methodInfo => !HasByRefLikeAttribute(methodInfo));
	
				var checkedConvertMethods = new List<MemberInfo>(10);
				var uncheckedConvertMethods = new List<MemberInfo>(10);
	
				foreach (var method in allMethods)
				{
					if (method.Name == "op_CheckedImplicit" || method.Name == "op_CheckedExplicit")
					{
						checkedConvertMethods.Add(method);
					}
					else if (method.Name == "op_Implicit" || method.Name == "op_Explicit")
					{
						checkedConvertMethods.Add(method);
						uncheckedConvertMethods.Add(method);
					}
				}
	
				var convertOperations = new Dictionary<bool, Lazy<MemberGroup>>();
				if (checkedConvertMethods.Count > 0)
				{
					convertOperations[true] = new Lazy<MemberGroup>(() => GroupMembers(checkedConvertMethods, options), LazyThreadSafetyMode.ExecutionAndPublication);
				}
				if (uncheckedConvertMethods.Count > 0)
				{
					convertOperations[false] = new Lazy<MemberGroup>(() => GroupMembers(uncheckedConvertMethods, options), LazyThreadSafetyMode.ExecutionAndPublication);
				}
				return convertOperations;
			}
	
			private static MemberGroupType? MapToGroupType(MemberInfo memberInfo)
			{
				if (memberInfo is ConstructorInfo)
				{
					return MemberGroupType.Constructor;
				}
				else if (memberInfo is MethodBase)
				{
					return MemberGroupType.Method;
				}
				else if (memberInfo is PropertyInfo)
				{
					return MemberGroupType.Property;
				}
				else if (memberInfo is FieldInfo)
				{
					return MemberGroupType.Field;
				}
				else
				{
					return null;
				}
			}
	
			private static bool HasByRefLikeAttribute(MethodBase methodBase)
			{
				if (methodBase is MethodInfo methodInfo)
				{
					return HasByRefLikeAttribute(methodInfo.ReturnParameter?.ParameterType) ||
						methodInfo.GetParameters().Any(HasByRefLikeAttribute);
				}
				else
				{
					return methodBase.GetParameters().Any(HasByRefLikeAttribute);
				}
			}
			private static bool HasByRefLikeAttribute(ParameterInfo parameterInfo)
			{
				if (parameterInfo.Member.Name == "ToString" && parameterInfo.Position == -1 /* return value */)
				{
					return false; // fix for https://github.com/mono/mono/issues/17192
				}
				return HasByRefLikeAttribute(parameterInfo.ParameterType);
			}
			private static bool HasByRefLikeAttribute(Type type)
			{
				if (type == null) return false;
				return type.GetTypeInfo().GetCustomAttributes(inherit: true).Any(attribute => IsByRefLikeAttributeType(attribute.GetType()));
			}
			private static bool HasByRefLikeAttribute(MemberInfo memberInfo)
			{
				if (memberInfo is MethodBase methodBase)
				{
					return HasByRefLikeAttribute(methodBase);
				}
				else if (memberInfo is PropertyInfo propertyInfo)
				{
					return HasByRefLikeAttribute(propertyInfo.PropertyType);
				}
				else if (memberInfo is FieldInfo fieldInfo)
				{
					return HasByRefLikeAttribute(fieldInfo.FieldType);
				}
				return false;
			}
			private static bool IsByRefLikeAttributeType(Type attributeType)
			{
				return string.Equals(attributeType.Namespace, "System.Runtime.CompilerServices", StringComparison.Ordinal) &&
					string.Equals(attributeType.Name, "IsByRefLikeAttribute", StringComparison.Ordinal);
			}
			private static bool HasGetter(MemberInfo memberInfo)
			{
				return !(memberInfo is PropertyInfo propertyInfo) || propertyInfo.GetMethod != null;
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				return CSharpNameUtils.GetCSharpFullNameWithGenerics(this.Type);
			}
		}
	

		private sealed class RestrictedReflectionTypeDescription : ReflectionTypeDescription
		{
			public RestrictedReflectionTypeDescription(Type type, FormulaOptions options)
				: base(type, options)
			{
	
			}
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				if (operationType == BinaryOperationType.Equal || operationType == BinaryOperationType.NotEqual)
				{
					return base.TryGetBinaryOperation(operationType, out binaryOperation);
				}
				binaryOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConstructors(out MemberGroup constructors)
			{
				constructors = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetMember(string memberName, out MemberGroup memberAccessor)
			{
				if (memberName == nameof(this.Type.Name) ||
					memberName == nameof(this.Type.Namespace) ||
					memberName == nameof(this.Type.FullName))
				{
					return base.TryGetMember(memberName, out memberAccessor);
				}
	
				memberAccessor = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetStaticMember(string memberName, out MemberGroup memberAccessor)
			{
				memberAccessor = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				unaryOperation = default;
				return false;
			}
		}
	

		private sealed class StringTypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup IndexAccessor;
	
			static StringTypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<String>((_, arguments) => (arguments[0].ToString() + arguments[1].ToString()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<String>((_, arguments) => (arguments[0].ToString() + arguments[1].ToString()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].IsNull == arguments[1].IsNull && string.Equals(arguments[0].ToString(), arguments[1].ToString(), StringComparison.Ordinal)));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].IsNull != arguments[1].IsNull || !string.Equals(arguments[0].ToString(), arguments[1].ToString(), StringComparison.Ordinal)));
	
				IndexAccessor = new MemberGroup(MemberGroupType.Method, new[] {
					new MemberDescription(
						invokeFunc: (stringValue, indexes) => ((string)stringValue.ToObject())[indexes[0].ToInt32()],
						resultType: typeof(char),
						new []{ new ParameterDescription("index", typeof(int), isRequired: true, defaultValue: VariableValue.Null) }
					)
				});
			}
			/// <inheritdoc />
			public StringTypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = null;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = IndexAccessor;
				return true;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(String), isRequired: true),
								new ParameterDescription("value2", typeof(String), isRequired: true)
							})
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class TypeCodes
		{
			public const TypeCode TIME_SPAN_CODE = (TypeCode)20;
	
			public static TypeCode GetTypeCode(Type type)
			{
				if (type == null) throw new ArgumentNullException(nameof(type));
	
				if (type == typeof(TimeSpan))
				{
					return TIME_SPAN_CODE;
				}
				else if (type.IsEnum)
				{
					// there is a b_u_g in some Mono implementation then GetTypeCode(enumType) gives TypeCode.Object instead of type code of underlying type
					return Type.GetTypeCode(Enum.GetUnderlyingType(type));
				}
				else
				{
					return Type.GetTypeCode(type);
				}
			}
	
			public static bool CanCoerceNumberLike(TypeCode toTypeCode, TypeCode fromTypeCode)
			{
				const int DOUBLE_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Double;
				const int DECIMAL_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Decimal;
				const int SINGLE_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double;
				const int BYTE_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Byte | 1 << (int)TypeCode.UInt16 | 1 << (int)TypeCode.Int16 | 1 << (int)TypeCode.UInt32 | 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int CHAR_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Char | 1 << (int)TypeCode.UInt16 | 1 << (int)TypeCode.UInt32 | 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int UINT16_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.UInt16 | 1 << (int)TypeCode.UInt32 | 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int UINT32_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.UInt32 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int UINT64_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.UInt64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int SBYTE_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.SByte | 1 << (int)TypeCode.Int16 | 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int INT16_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Int16 | 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int INT32_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Int32 | 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
				const int INT64_IMPLICIT_CONVERSIONS = 1 << (int)TypeCode.Int64 | 1 << (int)TypeCode.Single | 1 << (int)TypeCode.Double | 1 << (int)TypeCode.Decimal;
	
	
				// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
				switch (fromTypeCode)
				{
					case TypeCode.Char: return (CHAR_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.SByte: return (SBYTE_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Byte: return (BYTE_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Int16: return (INT16_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.UInt16: return (UINT16_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Int32: return (INT32_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.UInt32: return (UINT32_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Int64: return (INT64_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.UInt64: return (UINT64_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Single: return (SINGLE_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Double: return (DOUBLE_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					case TypeCode.Decimal: return (DECIMAL_IMPLICIT_CONVERSIONS & (1 << (int)toTypeCode)) != 0;
					default: return false;
				}
			}
	
			public static bool IsInteger(TypeCode typeCode)
			{
				return typeCode == TypeCode.Byte ||
					typeCode == TypeCode.SByte ||
					typeCode == TypeCode.Int16 ||
					typeCode == TypeCode.UInt16 ||
					typeCode == TypeCode.Int32 ||
					typeCode == TypeCode.UInt32 ||
					typeCode == TypeCode.Int64 ||
					typeCode == TypeCode.UInt64;
			}
			public static bool IsNumberLike(TypeCode typeCode)
			{
				return IsFloat(typeCode) || IsInteger(typeCode) || typeCode == TypeCode.Decimal || typeCode == TypeCode.Char;
			}
			public static bool IsFloat(TypeCode typeCode)
			{
				return typeCode == TypeCode.Single || typeCode == TypeCode.Double;
			}
			public static bool IsSignedInteger(TypeCode typeCode)
			{
				return typeCode == TypeCode.SByte || typeCode == TypeCode.Int16 || typeCode == TypeCode.Int32 || typeCode == TypeCode.Int64;
			}
			public static bool IsUnsignedInteger(TypeCode typeCode)
			{
				return typeCode == TypeCode.Byte || typeCode == TypeCode.UInt16 || typeCode == TypeCode.UInt32 || typeCode == TypeCode.UInt64;
			}
			public static TypeCode MakeUnsigned(TypeCode typeCode)
			{
				switch (typeCode)
				{
					case TypeCode.UInt64: return TypeCode.UInt64;
					case TypeCode.UInt32: return TypeCode.UInt32;
					case TypeCode.UInt16: return TypeCode.UInt16;
					case TypeCode.Int64: return TypeCode.UInt64;
					case TypeCode.Int32: return TypeCode.UInt32;
					case TypeCode.Int16: return TypeCode.UInt16;
					case TypeCode.Byte: return TypeCode.Byte;
					case TypeCode.SByte: return TypeCode.Byte;
					case TypeCode.Boolean:
					case TypeCode.Char:
					case TypeCode.DateTime:
					case TypeCode.DBNull:
					case TypeCode.Decimal:
					case TypeCode.Double:
					case TypeCode.Empty:
					case TypeCode.Object:
					case TypeCode.Single:
					case TypeCode.String:
					default: throw new ArgumentOutOfRangeException(nameof(typeCode), typeCode, null);
				}
			}
		}
	

		private sealed class TypeIsExpression : FormulaExpression
		{
			private readonly FormulaTypeReference type;
			private readonly FormulaExpression expression;
	
			public TypeIsExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.TYPE_ATTRIBUTE, optional: false);
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var target = this.expression.Execute(context);
				var typeDescription = context.TypeResolver.GetTypeDescription(this.type);
				return typeDescription.Type.IsAssignableFrom(target.Type);
			}
	
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				this.expression.BuildDebugView(stringBuilder);
				stringBuilder.Append(" is ").Append(this.type);
			}
		}
	

		private sealed class TypeOfExpression : FormulaExpression
		{
			private readonly FormulaTypeReference type;
	
			public TypeOfExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.type = ExpressionBuildHelper.GetTypeRef(expressionObj, FormulaConstants.TYPE_ATTRIBUTE, optional: false);
			}
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var typeDescription = context.TypeResolver.GetTypeDescription(this.type);
				return new VariableValue(typeDescription.Type);
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				stringBuilder.Append("typeof(").Append(this.type).Append(")");
			}
		}
	

		private readonly struct TypeTuple : IEquatable<TypeTuple>
		{
			private readonly int hashCode;
	
			public readonly Type[] Types;
	
			public TypeTuple(params Type[] types)
			{
				if (types == null) throw new ArgumentNullException(nameof(types));
	
				this.Types = types;
	
				unchecked
				{
					this.hashCode = 17;
					foreach (var type in types)
					{
						if (type == null) throw new ArgumentException("One of array's element is null.", nameof(types));
	
						this.hashCode = this.hashCode * 23 + type.GetHashCode();
					}
				}
			}
	
			public bool Equals(TypeTuple other)
			{
				if (this.Types == other.Types) return true;
				if (this.Types == null || other.Types == null) return false;
				if (this.Types.Length != other.Types.Length) return false;
	
				for (var i = 0; i < this.Types.Length; i++)
					if (this.Types[i] != other.Types[i])
						return false;
				return true;
			}
			public override int GetHashCode()
			{
				return this.hashCode;
			}
			public override bool Equals(object obj)
			{
				if (obj is TypeTuple tuple)
				{
					return this.Equals(tuple);
				}
				return false;
			}
	
			public override string ToString()
			{
				if (this.Types != null)
				{
					var sb = new System.Text.StringBuilder();
					foreach (var type in this.Types)
						sb.Append(type.Name).Append(", ");
					if (sb.Length > 2)
						sb.Length -= 2;
					return sb.ToString();
				}
				else
					return "empty";
			}
		}
	

		private sealed class UInt16TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static UInt16TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToUInt16() & arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToUInt16() | arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToUInt16() ^ arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToUInt16() * arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() * arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToUInt16() / arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() / arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToUInt16(), arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToUInt16() % arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToUInt16() + arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() + arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToUInt16() - arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() - arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToUInt16() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() > arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() >= arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() < arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() <= arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() == arguments[1].ToUInt16()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt16() != arguments[1].ToUInt16()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToUInt16()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToUInt16()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToUInt16()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToUInt16()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToUInt16())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToUInt16())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToUInt16())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToUInt16())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToUInt16())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToUInt16())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToUInt16())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToUInt16())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToUInt16())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToUInt16())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToUInt16())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToUInt16())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToUInt16(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToUInt16(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public UInt16TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(UInt16), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(UInt16), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(UInt16), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value1", typeof(UInt16), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class UInt32TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static UInt32TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<uint>((_, arguments) => (uint)(arguments[0].ToUInt32() & arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<uint>((_, arguments) => (uint)(arguments[0].ToUInt32() | arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<uint>((_, arguments) => (uint)(arguments[0].ToUInt32() ^ arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<uint>((_, arguments) => (uint)unchecked(arguments[0].ToUInt32() * arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<uint>((_, arguments) => (int)checked(arguments[0].ToUInt32() * arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<uint>((_, arguments) => (uint)unchecked(arguments[0].ToUInt32() / arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<uint>((_, arguments) => (uint)checked(arguments[0].ToUInt32() / arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<uint>((_, arguments) => (double)Math.Pow(arguments[0].ToUInt32(), arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<uint>((_, arguments) => (uint)(arguments[0].ToUInt32() % arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<uint>((_, arguments) => (uint)unchecked(arguments[0].ToUInt32() + arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<uint>((_, arguments) => (uint)checked(arguments[0].ToUInt32() + arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<uint>((_, arguments) => (uint)unchecked(arguments[0].ToUInt32() - arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<uint>((_, arguments) => (uint)checked(arguments[0].ToUInt32() - arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<uint>((_, arguments) => (uint)checked(arguments[0].ToUInt32() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<uint>((_, arguments) => (uint)checked(arguments[0].ToUInt32() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() > arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() >= arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() < arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() <= arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() == arguments[1].ToUInt32()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt32() != arguments[1].ToUInt32()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<uint>((_, arguments) => (uint)unchecked(+arguments[0].ToUInt32()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<long>((_, arguments) => (long)unchecked(-arguments[0].ToUInt32()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<long>((_, arguments) => (long)checked(-arguments[0].ToUInt32()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<uint>((_, arguments) => (uint)unchecked(~arguments[0].ToUInt32()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToUInt32())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToUInt32())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToUInt32())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToUInt32())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToUInt32())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToUInt32())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToUInt32())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToUInt32())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToUInt32())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToUInt32())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToUInt32())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToUInt32())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToUInt32(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToUInt32(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public UInt32TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(UInt32), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(UInt32), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(UInt32), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(UInt32), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class UInt64TypeDescription : ReflectionTypeDescription
		{
			// ReSharper disable BuiltInTypeReferenceStyle
	
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static UInt64TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)(arguments[0].ToUInt64() & arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)(arguments[0].ToUInt64() | arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)(arguments[0].ToUInt64() ^ arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)unchecked(arguments[0].ToUInt64() * arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<ulong>((_, arguments) => (int)checked(arguments[0].ToUInt64() * arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)unchecked(arguments[0].ToUInt64() / arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<ulong>((_, arguments) => (uint)checked(arguments[0].ToUInt64() / arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<ulong>((_, arguments) => (double)Math.Pow(arguments[0].ToUInt64(), arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)(arguments[0].ToUInt64() % arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)unchecked(arguments[0].ToUInt64() + arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)checked(arguments[0].ToUInt64() + arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)unchecked(arguments[0].ToUInt64() - arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)checked(arguments[0].ToUInt64() - arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)checked(arguments[0].ToUInt64() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<ulong>((_, arguments) => (ulong)checked(arguments[0].ToUInt64() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() > arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() >= arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() < arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() <= arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() == arguments[1].ToUInt64()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToUInt64() != arguments[1].ToUInt64()));
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<ulong>((_, arguments) => (ulong)unchecked(+arguments[0].ToUInt64()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<uint>((_, arguments) => (ulong)unchecked(~arguments[0].ToUInt64()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToUInt64())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToUInt64())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToUInt64())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToUInt64())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToUInt64())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToUInt64())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToUInt64())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToUInt64())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToUInt64())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToUInt64())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToUInt64())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToUInt64())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToUInt64(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToUInt64(uncheckedConversion: true))),
				});
				// ReSharper enable RedundantOverflowCheckingContext RedundantCast
			}
			/// <inheritdoc />
			public UInt64TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(UInt64), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(UInt64), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(UInt64), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(UInt64), isRequired: true)
					});
			}
			// ReSharper enable BuiltInTypeReferenceStyle
		}
	

		private sealed class UInt8TypeDescription : ReflectionTypeDescription
		{
			private static readonly MemberGroup[] BinaryOperations;
			private static readonly MemberGroup[] UnaryOperations;
			private static readonly MemberGroup CheckedConversions;
			private static readonly MemberGroup UncheckedConversions;
	
			static UInt8TypeDescription()
			{
				// ReSharper disable RedundantOverflowCheckingContext RedundantCast
				var lastBinaryOperation = Enum.GetValues(typeof(BinaryOperationType)).Cast<int>().Max();
				BinaryOperations = new MemberGroup[lastBinaryOperation + 1];
				BinaryOperations[(int)BinaryOperationType.And] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToByte() & arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Or] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToByte() | arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.ExclusiveOr] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToByte() ^ arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Multiply] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToByte() * arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.MultiplyChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() * arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Divide] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToByte() / arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.DivideChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() / arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Power] = CreateBinaryOperation<int>((_, arguments) => (double)Math.Pow(arguments[0].ToByte(), arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Modulo] = CreateBinaryOperation<int>((_, arguments) => (int)(arguments[0].ToByte() % arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Add] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToByte() + arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.AddChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() + arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Subtract] = CreateBinaryOperation<int>((_, arguments) => (int)unchecked(arguments[0].ToByte() - arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.SubtractChecked] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() - arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.LeftShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() << arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.RightShift] = CreateBinaryOperation<int>((_, arguments) => (int)checked(arguments[0].ToByte() >> arguments[1].ToInt32()), isShift: true);
				BinaryOperations[(int)BinaryOperationType.GreaterThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() > arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.GreaterThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() >= arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.LessThan] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() < arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.LessThanOrEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() <= arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.Equal] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() == arguments[1].ToByte()));
				BinaryOperations[(int)BinaryOperationType.NotEqual] = CreateBinaryOperation<bool>((_, arguments) => (bool)(arguments[0].ToByte() != arguments[1].ToByte()));
				// ReSharper enable RedundantOverflowCheckingContext
	
				var lastUnaryOperation = Enum.GetValues(typeof(UnaryOperationType)).Cast<int>().Max();
				UnaryOperations = new MemberGroup[lastUnaryOperation + 1];
				UnaryOperations[(int)UnaryOperationType.UnaryPlus] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(+arguments[0].ToByte()));
				UnaryOperations[(int)UnaryOperationType.Negate] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(-arguments[0].ToByte()));
				UnaryOperations[(int)UnaryOperationType.NegateChecked] = CreateUnaryOperation<int>((_, arguments) => (int)checked(-arguments[0].ToByte()));
				UnaryOperations[(int)UnaryOperationType.Complement] = CreateUnaryOperation<int>((_, arguments) => (int)unchecked(~arguments[0].ToByte()));
	
				CheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => checked((char)arguments[0].ToByte())),
					CreateConvertTo<sbyte>((_, arguments) => checked((sbyte)arguments[0].ToByte())),
					CreateConvertTo<byte>((_, arguments) => checked((byte)arguments[0].ToByte())),
					CreateConvertTo<short>((_, arguments) => checked((short)arguments[0].ToByte())),
					CreateConvertTo<ushort>((_, arguments) => checked((ushort)arguments[0].ToByte())),
					CreateConvertTo<int>((_, arguments) => checked((int)arguments[0].ToByte())),
					CreateConvertTo<uint>((_, arguments) => checked((uint)arguments[0].ToByte())),
					CreateConvertTo<long>((_, arguments) => checked((long)arguments[0].ToByte())),
					CreateConvertTo<ulong>((_, arguments) => checked((ulong)arguments[0].ToByte())),
					CreateConvertTo<float>((_, arguments) => checked((float)arguments[0].ToByte())),
					CreateConvertTo<double>((_, arguments) => checked((double)arguments[0].ToByte())),
					CreateConvertTo<decimal>((_, arguments) => checked((decimal)arguments[0].ToByte())),
				});
				UncheckedConversions = new MemberGroup(MemberGroupType.Method, new[] {
					CreateConvertTo<char>((_, arguments) => unchecked((char)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<sbyte>((_, arguments) => unchecked((sbyte)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<byte>((_, arguments) => unchecked((byte)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<short>((_, arguments) => unchecked((short)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<ushort>((_, arguments) => unchecked((ushort)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<int>((_, arguments) => unchecked((int)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<uint>((_, arguments) => unchecked((uint)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<long>((_, arguments) => unchecked((long)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<ulong>((_, arguments) => unchecked((ulong)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<float>((_, arguments) => unchecked((float)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<double>((_, arguments) => unchecked((double)arguments[0].ToByte(uncheckedConversion: true))),
					CreateConvertTo<decimal>((_, arguments) => unchecked((decimal)arguments[0].ToByte(uncheckedConversion: true))),
				});
			}
			/// <inheritdoc />
			public UInt8TypeDescription(Type type, FormulaOptions options) : base(type, options)
			{
			}
	
			/// <inheritdoc />
			public override bool TryGetBinaryOperation(BinaryOperationType operationType, out MemberGroup binaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < BinaryOperations.Length)
				{
					binaryOperation = BinaryOperations[operationIndex];
					if (binaryOperation != null)
					{
						return true;
					}
				}
	
				binaryOperation = default;
				return false;
	
			}
			/// <inheritdoc />
			public override bool TryGetUnaryOperation(UnaryOperationType operationType, out MemberGroup unaryOperation)
			{
				var operationIndex = (int)operationType;
				if (operationIndex >= 0 && operationIndex < UnaryOperations.Length)
				{
					unaryOperation = UnaryOperations[operationIndex];
					if (unaryOperation != null)
					{
						return true;
					}
				}
	
				unaryOperation = default;
				return false;
			}
			/// <inheritdoc />
			public override bool TryGetCheckedConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = CheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetConversionOperation(out MemberGroup convertOperation)
			{
				convertOperation = UncheckedConversions;
				return true;
			}
			/// <inheritdoc />
			public override bool TryGetIndexer(int rank, out MemberGroup indexAccessor)
			{
				indexAccessor = default;
				return false;
			}
	
			private static MemberGroup CreateBinaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation, bool isShift = false)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value1", typeof(Byte), isRequired: true),
								new ParameterDescription("value2", isShift ? typeof(Int32) : typeof(Byte), isRequired: true)
							})
					});
			}
			private static MemberGroup CreateUnaryOperation<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberGroup(
					MemberGroupType.Method,
					new[] {
						new MemberDescription(
							invokeFunc: operation,
							resultType: typeof(T),
							parameters: new [] {
								new ParameterDescription("value", typeof(Byte), isRequired: true)
							})
					});
			}
			private static MemberDescription CreateConvertTo<T>(Func<VariableValue, VariableValue[], VariableValue> operation)
			{
				return new MemberDescription(
					invokeFunc: operation,
					resultType: typeof(T),
					parameters: new[] {
						new ParameterDescription("value", typeof(Byte), isRequired: true)
					});
			}
		}
	

		private class UnaryExpression : FormulaExpression
		{
			private readonly FormulaExpression expression;
			private readonly UnaryOperationType unaryOperationType;
			private readonly UnaryOperationType fallbackUnaryOperationType;
	
			public UnaryExpression(IReadOnlyDictionary<string, object> expressionObj)
			{
				if (expressionObj == null) throw new ArgumentNullException(nameof(expressionObj));
	
				this.expression = ExpressionBuildHelper.GetExpression(expressionObj, FormulaConstants.EXPRESSION_ATTRIBUTE);
	
				var expressionType = ExpressionBuildHelper.GetString(expressionObj, FormulaConstants.EXPRESSION_TYPE_ATTRIBUTE);
				this.unaryOperationType = MapUnaryOperationType(expressionType);
	
				// ReSharper disable once SwitchStatementHandlesSomeKnownEnumValuesWithDefault
				switch (this.unaryOperationType)
				{
					case UnaryOperationType.NegateChecked: this.fallbackUnaryOperationType = UnaryOperationType.Negate; break;
					default: this.fallbackUnaryOperationType = this.unaryOperationType; break;
				}
			}
	
	
			/// <inheritdoc />
			public override VariableValue Execute(FormulaExecutionContext context)
			{
				var operand = this.expression.Execute(context);
				if (operand.IsNull)
				{
					return VariableValue.Null;
				}
	
				switch (this.unaryOperationType)
				{
					case UnaryOperationType.Group:
					case UnaryOperationType.UncheckedScope:
					case UnaryOperationType.CheckedScope: return operand;
					case UnaryOperationType.UnaryPlus:
					case UnaryOperationType.Negate:
					case UnaryOperationType.NegateChecked:
					case UnaryOperationType.Not:
					case UnaryOperationType.Complement: break;
					default: throw FormulaException.UnknownUnaryExpression(this.unaryOperationType.ToString());
				}
	
				var arguments = new Dictionary<string, VariableValue> {
					{ "0", operand }
				};
	
				var leftValueType = context.TypeResolver.GetTypeDescription(operand.Type);
				if (leftValueType.TryGetUnaryOperation(this.unaryOperationType, out var binaryOperation) &&
					binaryOperation.TryInvoke(VariableValue.Null, arguments, expectedType: null, typeArguments: null, out var result))
				{
					return result;
				}
				else if (this.fallbackUnaryOperationType != this.unaryOperationType && // try fallback unary operation
						leftValueType.TryGetUnaryOperation(this.fallbackUnaryOperationType, out binaryOperation) &&
						binaryOperation.TryInvoke(VariableValue.Null, arguments, expectedType: null, typeArguments: null, out result))
				{
					return result;
				}
				throw FormulaException.MissingUnaryOperation(this.unaryOperationType, operand);
			}
			/// <inheritdoc />
			public override void BuildDebugView(StringBuilder stringBuilder)
			{
				var enclose = !(this.expression is ConstantExpression);
				switch (this.unaryOperationType)
				{
					case UnaryOperationType.UnaryPlus: stringBuilder.Append("+"); break;
					case UnaryOperationType.Negate:
					case UnaryOperationType.NegateChecked: stringBuilder.Append("-"); break;
					case UnaryOperationType.Not: stringBuilder.Append("!"); break;
					case UnaryOperationType.Complement: stringBuilder.Append("~"); break;
					case UnaryOperationType.UncheckedScope:
						enclose = true;
						stringBuilder.Append("unchecked");
						break;
					case UnaryOperationType.CheckedScope:
						enclose = true;
						stringBuilder.Append("checked");
						break;
					case UnaryOperationType.Group:
						enclose = true;
						break;
					default: stringBuilder.Append(this.unaryOperationType); break;
				}
				if (enclose)
				{
					stringBuilder.Append("(");
				}
				this.expression.BuildDebugView(stringBuilder);
				if (enclose)
				{
					stringBuilder.Append(")");
				}
			}
	
			private static UnaryOperationType MapUnaryOperationType(string expressionType)
			{
				UnaryOperationType unaryOperationType;
				switch (expressionType)
				{
					case FormulaConstants.EXPRESSION_TYPE_UNCHECKED_SCOPE: unaryOperationType = UnaryOperationType.UncheckedScope; break;
					case FormulaConstants.EXPRESSION_TYPE_CHECKED_SCOPE: unaryOperationType = UnaryOperationType.CheckedScope; break;
					case FormulaConstants.EXPRESSION_TYPE_GROUP: unaryOperationType = UnaryOperationType.Group; break;
					case FormulaConstants.EXPRESSION_TYPE_UNARY_PLUS: unaryOperationType = UnaryOperationType.UnaryPlus; break;
					case FormulaConstants.EXPRESSION_TYPE_NEGATE: unaryOperationType = UnaryOperationType.Negate; break;
					case FormulaConstants.EXPRESSION_TYPE_NEGATE_CHECKED: unaryOperationType = UnaryOperationType.NegateChecked; break;
					case FormulaConstants.EXPRESSION_TYPE_NOT: unaryOperationType = UnaryOperationType.Not; break;
					case FormulaConstants.EXPRESSION_TYPE_COMPLEMENT: unaryOperationType = UnaryOperationType.Complement; break;
					default: throw FormulaException.UnknownUnaryExpression(expressionType);
				}
				return unaryOperationType;
			}
		}
	

		public enum UnaryOperationType
		{
			UnaryPlus,
			Negate,
			NegateChecked,
			Not,
			Complement,
			UncheckedScope,
			CheckedScope,
			Group,
		}
	

		private sealed class UnboundLambda
		{
			private readonly KeyValuePair<string, Type>[] parameters;
			private readonly FormulaExpression body;
			private readonly FormulaExecutionContext context;
	
			public UnboundLambda(FormulaExpression body, KeyValuePair<string, Type>[] parameters, FormulaExecutionContext context)
			{
				if (body == null) throw new ArgumentNullException(nameof(body));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
				if (context == null) throw new ArgumentNullException(nameof(context));
	
				this.parameters = parameters;
				this.body = body;
				this.context = context;
			}
	
			public bool IsSignatureMatching(Type delegateType)
			{
				var invokeMethod = delegateType.GetMethod(nameof(Action.Invoke), BindingFlags.Public | BindingFlags.Instance);
				if (invokeMethod == null)
				{
					return false;
				}
				var parameters = invokeMethod.GetParameters();
				if (parameters.Length != this.parameters.Length)
				{
					return false;
				}
	
				for (var index = 0; index < parameters.Length; index++)
				{
					var parameter = parameters[index];
					var argument = this.parameters[index];
					if (argument.Value == null)
					{
						continue;
					}
	
					if (!parameter.ParameterType.IsAssignableFrom(argument.Value))
					{
						return false;
					}
				}
	
				return true;
			}
	
			public Delegate BindTo(Type delegateType)
			{
				if (delegateType == null) throw new ArgumentNullException(nameof(delegateType));
	
				var invokeMethod = delegateType.GetMethod(nameof(Action.Invoke), BindingFlags.Public | BindingFlags.Instance);
				if (invokeMethod == null) throw new ArgumentException($"Missing required method 'Invoke' on '{delegateType}' delegate type.");
	
				var isVoidResult = invokeMethod.ReturnType == typeof(void);
				var parameters = invokeMethod.GetParameters();
				var signature = GetFuncSignature(invokeMethod, parameters);
	
				var boundLambdaFuncType = isVoidResult ? Expression.GetActionType(signature) : Expression.GetFuncType(signature);
	
				var boundLambdaFuncInvokeMethod = boundLambdaFuncType.GetMethod(nameof(Action.Invoke), BindingFlags.Public | BindingFlags.Instance);
				if (boundLambdaFuncInvokeMethod == null) throw new ArgumentException($"Missing required method 'Invoke' on '{boundLambdaFuncType}' delegate type.");
	
				var prepareMethodDefinition = typeof(LambdaFunctions)
					.GetMethods(BindingFlags.Static | BindingFlags.Public)
					.FirstOrDefault(m =>
						m.Name == (isVoidResult ? nameof(LambdaFunctions.Action) : nameof(LambdaFunctions.Func)) &&
						m.GetGenericArguments().Length == signature.Length);
	
				if (prepareMethodDefinition == null) throw new ArgumentException($"Missing '{nameof(LambdaFunctions.Action)}' or '{nameof(LambdaFunctions.Func)}' on '{typeof(LambdaFunctions)}' type with {signature.Length} generic arguments.");
				var prepareMethod = prepareMethodDefinition.MakeGenericMethod(signature);
				var boundLambdaFunc = prepareMethod.Invoke(null, new object[] { this.body, this.parameters, this.context });
	
				return Delegate.CreateDelegate(delegateType, boundLambdaFunc, boundLambdaFuncInvokeMethod, throwOnBindFailure: true);
			}
	
			private static Type[] GetFuncSignature(MethodInfo methodInfo, ParameterInfo[] parameters)
			{
				if (methodInfo == null) throw new ArgumentNullException(nameof(methodInfo));
				if (parameters == null) throw new ArgumentNullException(nameof(parameters));
	
				var isVoidResult = methodInfo.ReturnType == typeof(void);
				var signature = new Type[parameters.Length + (isVoidResult ? 0 : 1)];
				for (var i = 0; i < parameters.Length; i++)
				{
					signature[i] = parameters[i].ParameterType;
				}
	
				if (!isVoidResult)
				{
					signature[signature.Length - 1] = methodInfo.ReturnType;
				}
	
				return signature;
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				var parameters = string.Join(", ", this.parameters.Select(p => p.Key));
				return $"({parameters}) -> any";
	
			}
		}
	

		public readonly struct VariableValue
		{
			private class TypeCodeRef
			{
				public static readonly TypeCodeRef Boolean = new TypeCodeRef(TypeCode.Boolean, typeof(bool));
				public static readonly TypeCodeRef Char = new TypeCodeRef(TypeCode.Char, typeof(char));
				public static readonly TypeCodeRef SByte = new TypeCodeRef(TypeCode.SByte, typeof(sbyte));
				public static readonly TypeCodeRef Byte = new TypeCodeRef(TypeCode.Byte, typeof(byte));
				public static readonly TypeCodeRef Int16 = new TypeCodeRef(TypeCode.Int16, typeof(short));
				public static readonly TypeCodeRef UInt16 = new TypeCodeRef(TypeCode.UInt16, typeof(ushort));
				public static readonly TypeCodeRef Int32 = new TypeCodeRef(TypeCode.Int32, typeof(int));
				public static readonly TypeCodeRef UInt32 = new TypeCodeRef(TypeCode.UInt32, typeof(uint));
				public static readonly TypeCodeRef Int64 = new TypeCodeRef(TypeCode.Int64, typeof(long));
				public static readonly TypeCodeRef UInt64 = new TypeCodeRef(TypeCode.UInt64, typeof(ulong));
				public static readonly TypeCodeRef Single = new TypeCodeRef(TypeCode.Single, typeof(float));
				public static readonly TypeCodeRef Double = new TypeCodeRef(TypeCode.Double, typeof(double));
				public static readonly TypeCodeRef DateTime = new TypeCodeRef(TypeCode.DateTime, typeof(DateTime));
				public static readonly TypeCodeRef TimeSpan = new TypeCodeRef(TypeCodes.TIME_SPAN_CODE, typeof(TimeSpan));
	
				private static readonly Dictionary<Type, TypeCodeRef> EnumTypeCodes = new Dictionary<Type, TypeCodeRef>();
	
				public readonly TypeCode TypeCode;
				public readonly Type Type;
	
				private TypeCodeRef(TypeCode typeCode, Type type)
				{
					if (type == null) throw new ArgumentNullException(nameof(type));
	
					this.TypeCode = typeCode;
					this.Type = type;
				}
	
				public static TypeCodeRef GetOrCreateEnumTypeCodeRef(Type enumType)
				{
					lock (EnumTypeCodes)
					{
						if (EnumTypeCodes.TryGetValue(enumType, out var enumTypeCodeRef))
						{
							return enumTypeCodeRef;
						}
	
						EnumTypeCodes[enumType] = enumTypeCodeRef = new TypeCodeRef(TypeCodes.GetTypeCode(enumType), enumType);
						return enumTypeCodeRef;
					}
				}
			}
	
			public static readonly VariableValue Null = new VariableValue(null);
	
			private readonly long binaryValue;
			private readonly object refValue;
	
			public bool IsNull => this.binaryValue == 0 && this.refValue == null;
			public Type Type => this.GetValueType();
			public TypeCode TypeCode => this.GetValueTypeCode();
	
			private VariableValue(TypeCodeRef typeCodeRef, long binaryValue)
			{
				this.refValue = typeCodeRef;
				this.binaryValue = binaryValue;
			}
			public VariableValue(object value)
			{
				if (value is VariableValue variableValue)
				{
					this.binaryValue = variableValue.binaryValue;
					this.refValue = variableValue.refValue;
					return;
				}
				else if (value == null)
				{
					this.binaryValue = default;
					this.refValue = null;
					return;
				}
	
				var valueType = value.GetType();
				var valueTypeCode = TypeCodes.GetTypeCode(valueType);
				if (valueType.IsEnum)
				{
					this.refValue = TypeCodeRef.GetOrCreateEnumTypeCodeRef(valueType);
					if (Enum.GetUnderlyingType(valueType) == typeof(ulong))
					{
						this.binaryValue = unchecked((long)Convert.ToUInt64(value, CultureInfo.InvariantCulture));
					}
					else
					{
						this.binaryValue = Convert.ToInt64(value, CultureInfo.InvariantCulture);
					}
					return;
				}
	
				switch (valueTypeCode)
				{
					case TypeCode.Boolean:
						this.binaryValue = (bool)value ? 1 : 0;
						this.refValue = TypeCodeRef.Boolean;
						break;
					case TypeCode.Byte:
						this.binaryValue = (byte)value;
						this.refValue = TypeCodeRef.Byte;
						break;
					case TypeCode.SByte:
						this.binaryValue = (sbyte)value;
						this.refValue = TypeCodeRef.SByte;
						break;
					case TypeCode.Char:
						this.binaryValue = (char)value;
						this.refValue = TypeCodeRef.Char;
						break;
					case TypeCode.Double:
						this.binaryValue = BitConverter.DoubleToInt64Bits((double)value);
						this.refValue = TypeCodeRef.Double;
						break;
					case TypeCode.Int16:
						this.binaryValue = (short)value;
						this.refValue = TypeCodeRef.Int16;
						break;
					case TypeCode.Int32:
						this.binaryValue = (int)value;
						this.refValue = TypeCodeRef.Int32;
						break;
					case TypeCode.Int64:
						this.binaryValue = (long)value;
						this.refValue = TypeCodeRef.Int64;
						break;
					case TypeCode.Single:
						this.binaryValue = BitConverter.DoubleToInt64Bits((float)value);
						this.refValue = TypeCodeRef.Single;
						break;
					case TypeCode.UInt16:
						this.binaryValue = (ushort)value;
						this.refValue = TypeCodeRef.UInt16;
						break;
					case TypeCode.UInt32:
						this.binaryValue = (uint)value;
						this.refValue = TypeCodeRef.UInt32;
						break;
					case TypeCode.UInt64:
						this.binaryValue = unchecked((long)(ulong)value);
						this.refValue = TypeCodeRef.UInt64;
						break;
					case TypeCodes.TIME_SPAN_CODE:
						this.binaryValue = ((TimeSpan)value).Ticks;
						this.refValue = TypeCodeRef.TimeSpan;
						break;
					case TypeCode.DateTime:
						this.binaryValue = ((DateTime)value).ToBinary();
						this.refValue = TypeCodeRef.DateTime;
						break;
					case TypeCode.DBNull:
					case TypeCode.Decimal:
					case TypeCode.Empty:
					case TypeCode.Object:
					case TypeCode.String:
					default:
						this.binaryValue = 0;
						this.refValue = value;
						break;
				}
			}
			public VariableValue(char value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.Char;
			}
			public VariableValue(bool value)
			{
				this.binaryValue = value ? 1 : 0;
				this.refValue = TypeCodeRef.Boolean;
			}
			public VariableValue(byte value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.Byte;
			}
			public VariableValue(sbyte value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.SByte;
			}
			public VariableValue(short value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.Int16;
			}
			public VariableValue(ushort value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.UInt16;
			}
			public VariableValue(int value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.Int32;
			}
			public VariableValue(uint value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.UInt32;
			}
			public VariableValue(long value)
			{
				this.binaryValue = value;
				this.refValue = TypeCodeRef.Int64;
			}
			public VariableValue(ulong value)
			{
				this.binaryValue = unchecked((long)value);
				this.refValue = TypeCodeRef.UInt64;
			}
			public VariableValue(float value)
			{
				this.binaryValue = BitConverter.DoubleToInt64Bits(value);
				this.refValue = TypeCodeRef.Single;
			}
			public VariableValue(double value)
			{
				this.binaryValue = BitConverter.DoubleToInt64Bits(value);
				this.refValue = TypeCodeRef.Double;
			}
			public VariableValue(DateTime value)
			{
				this.binaryValue = value.ToBinary();
				this.refValue = TypeCodeRef.DateTime;
			}
			public VariableValue(TimeSpan value)
			{
				this.binaryValue = value.Ticks;
				this.refValue = TypeCodeRef.TimeSpan;
			}
	
			private Type GetValueType()
			{
				if (this.refValue is TypeCodeRef typeCodeRef)
				{
					return typeCodeRef.Type;
				}
				else
				{
					return this.refValue?.GetType() ?? typeof(object);
				}
			}
			private TypeCode GetValueTypeCode()
			{
				if (this.refValue is TypeCodeRef typeCodeRef)
				{
					return typeCodeRef.TypeCode;
				}
				else
				{
					return TypeCodes.GetTypeCode(this.refValue?.GetType() ?? typeof(object));
				}
			}
			public object ToObject()
			{
				if (this.refValue is TypeCodeRef typeCodeRef)
				{
					var valueTypeCode = typeCodeRef.TypeCode;
					var result = default(object);
					switch (valueTypeCode)
					{
						case TypeCode.Boolean: result = this.binaryValue > 0; break;
						case TypeCode.Char: result = unchecked((char)this.binaryValue); break;
						case TypeCode.SByte: result = unchecked((sbyte)this.binaryValue); break;
						case TypeCode.Byte: result = unchecked((byte)this.binaryValue); break;
						case TypeCode.Int16: result = unchecked((short)this.binaryValue); break;
						case TypeCode.UInt16: result = unchecked((ushort)this.binaryValue); break;
						case TypeCode.Int32: result = unchecked((int)this.binaryValue); break;
						case TypeCode.UInt32: result = unchecked((uint)this.binaryValue); break;
						case TypeCode.Int64: result = this.binaryValue; break;
						case TypeCode.UInt64: result = unchecked((ulong)this.binaryValue); break;
						case TypeCode.Single: result = (float)BitConverter.Int64BitsToDouble(this.binaryValue); break;
						case TypeCode.Double: result = BitConverter.Int64BitsToDouble(this.binaryValue); break;
						case TypeCode.DateTime: result = DateTime.FromBinary(this.binaryValue); break;
						case TypeCodes.TIME_SPAN_CODE: result = TimeSpan.FromTicks(this.binaryValue); break;
						case TypeCode.String:
						case TypeCode.Empty:
						case TypeCode.Object:
						case TypeCode.Decimal:
						case TypeCode.DBNull:
						default: throw new ArgumentOutOfRangeException($"Unexpected type of TypeCodeRef '{valueTypeCode}' while one of blittable types are expected.");
					}
					if (typeCodeRef.Type.IsEnum)
					{
						result = Enum.ToObject(typeCodeRef.Type, result);
					}
					return result;
				}
				else
				{
					return this.refValue;
				}
			}
			public object ToType(Type toType)
			{
				if (toType == null) throw new ArgumentNullException(nameof(toType));
	
				var isNullable = toType.IsGenericType && Nullable.GetUnderlyingType(toType) != toType;
				if (isNullable && this.IsNull)
				{
					return null;
				}
	
				if (toType == typeof(object))
				{
					return this.ToObject();
				}
				else if (toType == typeof(string))
				{
					return this.ToString();
				}
				else if (toType == typeof(char))
				{
					return this.ToChar();
				}
				else if (toType == typeof(bool))
				{
					return this.ToBoolean();
				}
				else if (toType == typeof(byte))
				{
					return this.ToByte();
				}
				else if (toType == typeof(sbyte))
				{
					return this.ToSByte();
				}
				else if (toType == typeof(short))
				{
					return this.ToInt16();
				}
				else if (toType == typeof(ushort))
				{
					return this.ToUInt16();
				}
				else if (toType == typeof(int))
				{
					return this.ToInt32();
				}
				else if (toType == typeof(uint))
				{
					return this.ToUInt32();
				}
				else if (toType == typeof(long))
				{
					return this.ToInt64();
				}
				else if (toType == typeof(ulong))
				{
					return this.ToUInt64();
				}
				else if (toType == typeof(float))
				{
					return this.ToSingle();
				}
				else if (toType == typeof(double))
				{
					return this.ToDouble();
				}
				else if (toType == typeof(DateTime))
				{
					return this.ToDateTime();
				}
				else if (toType == typeof(TimeSpan))
				{
					return this.ToTimeSpan();
				}
				else if (toType == typeof(decimal))
				{
					return this.ToDecimal();
				}
				else if (toType.IsEnum)
				{
					var underlyingType = Enum.GetUnderlyingType(toType);
					return Enum.ToObject(toType, this.ToType(underlyingType));
				}
				else
				{
					var value = this.ToObject();
					if (toType.IsInstanceOfType(value))
					{
						return value;
					}
					else
					{
						throw new InvalidCastException($"Unable to cast value of type '{value?.GetType().FullName ?? "<null>"}' to type '{toType.FullName}'.");
					}
				}
			}
			public bool CanFitInto(TypeCode targetTypeCode)
			{
				var currentTypeCode = this.TypeCode;
				if (currentTypeCode == targetTypeCode)
				{
					return true;
				}
	
				// try compact integer type
				if (TypeCodes.IsInteger(currentTypeCode))
				{
					// ReSharper disable once SwitchStatementMissingSomeEnumCasesNoDefault
					switch (currentTypeCode)
					{
						case TypeCode.UInt64:
							currentTypeCode = TypeCode.UInt64;
							var uint64Value = unchecked((ulong)this.binaryValue);
							if (uint64Value <= long.MaxValue)
							{
								goto case TypeCode.Int64;
							}
							break;
						case TypeCode.Int64:
							currentTypeCode = TypeCode.Int64;
							if (this.binaryValue >= int.MinValue && this.binaryValue <= int.MaxValue) goto case TypeCode.Int32;
							else if (this.binaryValue >= uint.MinValue && this.binaryValue <= uint.MaxValue) goto case TypeCode.UInt32;
							break;
						case TypeCode.UInt32:
							currentTypeCode = TypeCode.UInt32;
							if (this.binaryValue >= short.MinValue && this.binaryValue <= short.MaxValue) goto case TypeCode.Int16;
							else if (this.binaryValue >= ushort.MinValue && this.binaryValue <= ushort.MaxValue) goto case TypeCode.UInt16;
							break;
						case TypeCode.Int32:
							currentTypeCode = TypeCode.Int32;
							if (this.binaryValue >= short.MinValue && this.binaryValue <= short.MaxValue) goto case TypeCode.Int16;
							else if (this.binaryValue >= ushort.MinValue && this.binaryValue <= ushort.MaxValue) goto case TypeCode.UInt16;
							break;
						case TypeCode.Int16:
							currentTypeCode = TypeCode.Int16;
							if (this.binaryValue >= sbyte.MinValue && this.binaryValue <= sbyte.MaxValue) goto case TypeCode.SByte;
							else if (this.binaryValue >= byte.MinValue && this.binaryValue <= byte.MaxValue) goto case TypeCode.Byte;
							break;
						case TypeCode.UInt16:
							currentTypeCode = TypeCode.UInt16;
							if (this.binaryValue >= sbyte.MinValue && this.binaryValue <= sbyte.MaxValue) goto case TypeCode.SByte;
							else if (this.binaryValue >= byte.MinValue && this.binaryValue <= byte.MaxValue) goto case TypeCode.Byte;
							break;
						case TypeCode.SByte:
							currentTypeCode = TypeCode.SByte;
							break;
						case TypeCode.Byte:
							currentTypeCode = TypeCode.Byte;
							break;
					}
				}
	
	
				if (TypeCodes.CanCoerceNumberLike(targetTypeCode, currentTypeCode))
				{
					return true;
				}
	
				if (TypeCodes.IsUnsignedInteger(targetTypeCode) &&
					TypeCodes.IsSignedInteger(currentTypeCode) && this.binaryValue >= 0 &&
					TypeCodes.CanCoerceNumberLike(targetTypeCode, TypeCodes.MakeUnsigned(currentTypeCode)))
				{
					return true;
				}
	
				if (targetTypeCode == TypeCode.Byte && currentTypeCode == TypeCode.SByte)
				{
					return this.binaryValue >= byte.MinValue && this.binaryValue <= byte.MaxValue;
				}
				else if (targetTypeCode == TypeCode.SByte && currentTypeCode == TypeCode.Byte)
				{
					return this.binaryValue >= sbyte.MinValue && this.binaryValue <= sbyte.MaxValue;
				}
	
				else if (targetTypeCode == TypeCode.Int64 && currentTypeCode == TypeCode.UInt64)
				{
					return unchecked((ulong)this.binaryValue) <= long.MaxValue;
				}
				return false;
			}
	
			public long ToInt64(bool uncheckedConversion = false)
			{
				var typeCode = this.TypeCode;
				if (typeCode == TypeCode.UInt64 && uncheckedConversion == false)
				{
					var uint64Value = unchecked((ulong)this.binaryValue);
					return checked((long)uint64Value);
				}
				else if (TypeCodes.IsInteger(typeCode))
				{
					return this.binaryValue;
				}
				else
				{
					return Convert.ToInt64(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public ulong ToUInt64(bool uncheckedConversion = false)
			{
				var typeCode = this.TypeCode;
				if (typeCode == TypeCode.UInt64)
				{
					return unchecked((ulong)this.binaryValue);
				}
				else if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((ulong)this.binaryValue) : checked((ulong)this.binaryValue);
				}
				else
				{
					return Convert.ToUInt64(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public int ToInt32(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((int)this.binaryValue) : checked((int)this.binaryValue);
				}
				else
				{
					return Convert.ToInt32(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public uint ToUInt32(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((uint)this.binaryValue) : checked((uint)this.binaryValue);
				}
				else
				{
					return Convert.ToUInt32(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public short ToInt16(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((short)this.binaryValue) : checked((short)this.binaryValue);
				}
				else
				{
					return Convert.ToInt16(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public ushort ToUInt16(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((ushort)this.binaryValue) : checked((ushort)this.binaryValue);
				}
				else
				{
					return Convert.ToUInt16(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public sbyte ToSByte(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((sbyte)this.binaryValue) : checked((sbyte)this.binaryValue);
				}
				else
				{
					return Convert.ToSByte(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public byte ToByte(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((byte)this.binaryValue) : checked((byte)this.binaryValue);
				}
				else
				{
					return Convert.ToByte(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public char ToChar(bool uncheckedConversion = false)
			{
				if (TypeCodes.IsInteger(this.TypeCode) || this.TypeCode == TypeCode.Char)
				{
					return uncheckedConversion ? unchecked((char)this.binaryValue) : checked((char)this.binaryValue);
				}
				else
				{
					return Convert.ToChar(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public double ToDouble()
			{
				var typeCode = this.TypeCode;
				if (TypeCodes.IsInteger(typeCode) || typeCode == TypeCode.Char)
				{
					return typeCode == TypeCode.UInt64 ? unchecked((ulong)this.binaryValue) : (double)this.binaryValue;
				}
				else if (typeCode == TypeCode.Single || typeCode == TypeCode.Double)
				{
					return BitConverter.Int64BitsToDouble(this.binaryValue);
				}
				else
				{
					return Convert.ToDouble(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public float ToSingle()
			{
				var typeCode = this.TypeCode;
				if (TypeCodes.IsInteger(typeCode) || typeCode == TypeCode.Char)
				{
					return typeCode == TypeCode.UInt64 ? unchecked((ulong)this.binaryValue) : (float)this.binaryValue;
				}
				else if (typeCode == TypeCode.Single || typeCode == TypeCode.Double)
				{
					return (float)BitConverter.Int64BitsToDouble(this.binaryValue);
				}
				else
				{
					return Convert.ToSingle(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public decimal ToDecimal()
			{
				var typeCode = this.TypeCode;
				if (TypeCodes.IsInteger(typeCode) || typeCode == TypeCode.Char)
				{
					return typeCode == TypeCode.UInt64 ? unchecked((ulong)this.binaryValue) : (decimal)this.binaryValue;
				}
				else if (typeCode == TypeCode.Single || typeCode == TypeCode.Double)
				{
					return (decimal)BitConverter.Int64BitsToDouble(this.binaryValue);
				}
				else
				{
					return Convert.ToDecimal(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public DateTime ToDateTime()
			{
				var typeCode = this.TypeCode;
				if (typeCode == TypeCode.DateTime)
				{
					return DateTime.FromBinary(this.binaryValue);
				}
				else
				{
					return Convert.ToDateTime(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public TimeSpan ToTimeSpan()
			{
				var typeCode = this.TypeCode;
				if (typeCode == TypeCodes.TIME_SPAN_CODE)
				{
					return TimeSpan.FromTicks(this.binaryValue);
				}
				else
				{
					return ToTimeSpan(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public bool ToBoolean()
			{
				var typeCode = this.TypeCode;
				if (typeCode == TypeCode.Boolean)
				{
					return this.binaryValue > 0;
				}
				else
				{
					return Convert.ToBoolean(this.ToObject(), CultureInfo.InvariantCulture);
				}
			}
			public T To<T>()
			{
				if (typeof(T) == typeof(long)) return (T)(object)this.ToInt64();
				else if (typeof(T) == typeof(ulong)) return (T)(object)this.ToUInt64();
				else if (typeof(T) == typeof(int)) return (T)(object)this.ToInt32();
				else if (typeof(T) == typeof(uint)) return (T)(object)this.ToUInt32();
				else if (typeof(T) == typeof(short)) return (T)(object)this.ToInt16();
				else if (typeof(T) == typeof(ushort)) return (T)(object)this.ToUInt16();
				else if (typeof(T) == typeof(sbyte)) return (T)(object)this.ToSByte();
				else if (typeof(T) == typeof(byte)) return (T)(object)this.ToByte();
				else if (typeof(T) == typeof(char)) return (T)(object)this.ToChar();
				else if (typeof(T) == typeof(double)) return (T)(object)this.ToDouble();
				else if (typeof(T) == typeof(float)) return (T)(object)this.ToSingle();
				else if (typeof(T) == typeof(decimal)) return (T)(object)this.ToDecimal();
				else if (typeof(T) == typeof(DateTime)) return (T)(object)this.ToDateTime();
				else if (typeof(T) == typeof(TimeSpan)) return (T)(object)this.ToTimeSpan();
				else if (typeof(T) == typeof(bool)) return (T)(object)this.ToBoolean();
				else
				{
					var objValue = this.ToObject();
					if (objValue is T typeValue)
					{
						return typeValue;
					}
					else if (typeof(T).IsEnum && objValue is string enumValueString)
					{
						return (T)Enum.Parse(typeof(T), enumValueString, ignoreCase: true);
					}
					else if (typeof(T).IsEnum)
					{
						return (T)Enum.ToObject(typeof(T), objValue);
					}
					else
					{
						return (T)Convert.ChangeType(this.ToObject(), typeof(T), CultureInfo.InvariantCulture);
					}
				}
			}
	
			public static implicit operator VariableValue(char value) { return new VariableValue(value); }
			public static implicit operator VariableValue(bool value) { return new VariableValue(value); }
			public static implicit operator VariableValue(byte value) { return new VariableValue(value); }
			public static implicit operator VariableValue(sbyte value) { return new VariableValue(value); }
			public static implicit operator VariableValue(short value) { return new VariableValue(value); }
			public static implicit operator VariableValue(ushort value) { return new VariableValue(value); }
			public static implicit operator VariableValue(int value) { return new VariableValue(value); }
			public static implicit operator VariableValue(uint value) { return new VariableValue(value); }
			public static implicit operator VariableValue(long value) { return new VariableValue(value); }
			public static implicit operator VariableValue(ulong value) { return new VariableValue(value); }
			public static implicit operator VariableValue(float value) { return new VariableValue(value); }
			public static implicit operator VariableValue(double value) { return new VariableValue(value); }
			public static implicit operator VariableValue(DateTime value) { return new VariableValue(value); }
			public static implicit operator VariableValue(TimeSpan value) { return new VariableValue(value); }
			public static implicit operator VariableValue(decimal value) { return new VariableValue(value); }
			public static implicit operator VariableValue(string value) { return new VariableValue(value); }
	
			public static VariableValue FromEnum(Type enumType, long value)
			{
				if (!enumType.IsEnum) throw new ArgumentException($"Type '{enumType}' should be enum type.");
	
				var typeCodeRef = TypeCodeRef.GetOrCreateEnumTypeCodeRef(enumType);
				return new VariableValue(typeCodeRef, value);
			}
	
			public static TimeSpan ToTimeSpan(object value, IFormatProvider formatProvider)
			{
				if (value == null) throw new ArgumentNullException(nameof(value));
	
				if (value is TimeSpan span)
				{
					return span;
				}
				if (value is byte byteValue)
				{
					return TimeSpan.FromTicks(byteValue);
				}
				else if (value is sbyte sByteValue)
				{
					return TimeSpan.FromTicks(sByteValue);
				}
				else if (value is short shortValue)
				{
					return TimeSpan.FromTicks(shortValue);
				}
				else if (value is ushort ushortValue)
				{
					return TimeSpan.FromTicks(ushortValue);
				}
				else if (value is int intValue)
				{
					return TimeSpan.FromTicks(intValue);
				}
				else if (value is uint uintValue)
				{
					return TimeSpan.FromTicks(uintValue);
				}
				else if (value is long longValue)
				{
					return TimeSpan.FromTicks(longValue);
				}
				else if (value is ulong ulongValue)
				{
					return TimeSpan.FromTicks((long)ulongValue);
				}
				else if (value is float floatValue)
				{
					return TimeSpan.FromTicks(checked((long)floatValue));
				}
				else if (value is double doubleValue)
				{
					return TimeSpan.FromTicks(checked((long)doubleValue));
				}
				else if (value is decimal decimalValue)
				{
					return TimeSpan.FromTicks((long)decimalValue);
				}
				else
				{
					var stringValue = Convert.ToString(value, formatProvider) ?? value.ToString();
					if (stringValue.All(char.IsDigit))
					{
						return TimeSpan.FromTicks(long.Parse(stringValue));
					}
					else
					{
						return TimeSpan.Parse(stringValue, formatProvider);
					}
				}
			}
	
			public static Expression ToVariableValueExpression(Expression valueExpression)
			{
				if (valueExpression == null) throw new ArgumentNullException(nameof(valueExpression));
	
				var expressionType = valueExpression.Type;
				var constructor = typeof(VariableValue).GetConstructor(new[] { expressionType });
				if (constructor != null)
				{
					return Expression.New(constructor, valueExpression);
				}
	
				constructor = typeof(VariableValue).GetConstructor(new[] { typeof(object) });
				if (constructor == null)
				{
					throw new InvalidOperationException($"There is no .ctr(object value) constructor on '{typeof(VariableValue)}' type. Make sure it is not removed by IL Linker.");
				}
				return Expression.New(constructor, Expression.Convert(valueExpression, typeof(object)));
			}
			public static Expression FromVariableValueExpression(Expression variableValueExpression, Type expectedType)
			{
				if (variableValueExpression == null) throw new ArgumentNullException(nameof(variableValueExpression));
				if (expectedType == null) throw new ArgumentNullException(nameof(expectedType));
	
				var convertMethod = typeof(VariableValue).GetMethod("op_Explicit", BindingFlags.Static | BindingFlags.Public, null, new[] { expectedType }, null);
				if (convertMethod != null)
				{
					return Expression.Call(convertMethod, variableValueExpression);
				}
	
				convertMethod = typeof(VariableValue)
					.GetMethods(BindingFlags.Instance | BindingFlags.Public)
					.FirstOrDefault(method => method.Name.StartsWith("To") && method.ReturnType == expectedType);
				if (convertMethod != null)
				{
					var parameterExpressions = Array.ConvertAll(convertMethod.GetParameters(), parameter => parameter.HasDefaultValue ?
						Expression.Constant(parameter.DefaultValue) :
						(Expression)Expression.Default(parameter.ParameterType)
					);
	
					return Expression.Call(variableValueExpression, convertMethod, parameterExpressions);
				}
	
				var toObjectCall = Expression.Call(variableValueExpression, nameof(ToObject), Type.EmptyTypes);
				return Expression.Convert(toObjectCall, expectedType);
			}
	
			/// <inheritdoc />
			public override string ToString()
			{
				var value = this.ToObject();
				return Convert.ToString(value, CultureInfo.InvariantCulture) ?? string.Empty;
			}
		}
	
	}
#endif
}


